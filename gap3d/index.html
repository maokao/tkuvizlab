<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Title -->
    <title>3D GAP Online Demo</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <!-- Favicon -->
    <link rel="Shortcut Icon" type="image/x-icon" href="img/gap.ico"/>

    <!-- awesome icon -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">

    <!-- Template -->
    <link rel="stylesheet" href="public/graindashboard/css/graindashboard.css">

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/colorbrewer.v1.min.js"></script>

    <!-- <script type="module" src="js/color.js"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata"></script>

    <script type="text/javascript" src="js/dendrogram.js"></script>
    <script type="text/javascript" src="js/seriation.js"></script>
    <!--<script type="text/javascript" src="r2e.js"></script>-->
    <script type="text/javascript" src="js/r2e_wasm.js"></script>
    <!--<script type="text/javascript" src="hctree.js"></script>-->
    <script type="text/javascript" src="js/hctree_wasm.js"></script>
    <script type="text/javascript" src="js/proximity_wasm.js"></script>
    <script src="js/color.js"></script>
    <script src="js/heatmap_class_utility.js"></script>
    <script src="js/heatmap_class.js"></script>
    <link rel="stylesheet" href="css/heatmap.css" />  
    <link rel="stylesheet" href="css/lightbox.css" />
    <script src="js/import_utility.js"></script>
    <script src="js/papaparse.min.js"></script>

    <script src="public/graindashboard/js/graindashboard.js"></script>
    <script src="public/graindashboard/js/graindashboard.vendor.js"></script>

    <!--for 雙按鈕滑動條-->
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="//code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    <script>
        // 全域解析 (上傳) 之資料
        var parsedData;

        // 上傳資料之 columns 數
        var colCount;

        // 全域變數來儲存目前的透明度值
        var currentOpacity = 0.5; // 初始值為 0.5
        
        var globalMin = 0; // 全域最小值
        var globalMax = 100; // 全域最大值

        // 數值滑動調之值
        var doubleslidercubesvalue;

        // 確保這些參數在函數外部被正確定義和更新
        var data_array = [];

        var fieldX, fieldY, fieldZ;

        var numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ;

        var uniqueX, uniqueY, uniqueZ;

        // 用於儲存所有立方體的 array (初始化為三維 array 的 cubes)
        var cubes = [];

        // for slices
        var selectedAxis;

        // for gap between each slice
        var sliceGap = 1;

        // for X 軸排序
        var Xindices = []; // 用於儲存軸標籤當前 X 軸 index 的 array

        // for Y 軸排序
        var Yindices = []; // 用於儲存軸標籤當前 Y 軸 index 的 array

        // for Z 軸排序
        var Zindices = []; // 用於儲存軸標籤當前 Z 軸 index 的 array

        var cellWidth = 24;

        var cellHeight = 6;

        var rowIsSimilarity = false;

        var firstRunRowTree = true;

        var firstRunColTree = true;

        var gapbwaxisandlabel = 0.08; // 軸與軸標籤之間的距離

        // 定義一個全域變數來追蹤目前最高的 z-index 值 (for 浮動視窗之順序)
        var highestZIndex = 1000;

        var rowProxData1D = [];

        var rowProxDataX = [];
        
        var rowProxDataY = [];

        var rowProxDataZ = [];

        let allowUpdateSizes = true; // 預設允許修改邊長

        let updateAxes = true; // 預設為 true 表示允許更新軸線與軸標籤

        // 儲存立方體的透明度狀態 (與 cubes 結構相同)
        let cubesOpacity = [];

        // 用於追蹤已選取的類別 (for bar chart)
        let categoryConditions = new Set();

        // 追蹤選取的 bar (for change bar's color of bar chart)
        let selectedBars = new Set();

        // 用於追蹤選中的範圍 (for histogram)
        let rangeConditions = new Set(); // 用於追蹤選中的範圍 (for histogram)

        // 追蹤選取的 bar (for change bar's color of histogram)
        let selectedHistogramBars = new Set();

        let lastClickedRange = null; // 用來追蹤最後一次點擊的範圍，用於切換顯示狀態 (for histogram)

        // for bar chart and histogram
        let isDragging = false;  // 是否正在拖曳
        let dragStartIndex = null;  // 拖曳起始 bar 索引
        let lastValidIndex = null;  // 最後一個有效的 bar 索引

        let matchesCategoryConditions;
        let matchesRangeConditions;

        var gapX;

        var gapY;

        var gapZ;

        // 設置初始值為聯集
        var selectionType = 'Union';

        var maxDimension; // 找到最大的維度
        
        var distance;

        // var newSize = 1;

        var minMaxByUniqueX = {};
        var minMaxByUniqueY = {};
        var minMaxByUniqueZ = {};

        // 全域變數來保存滑動條的目前值
        var globalSliderMin;
        var globalSliderMax;

        // 全域變數來保存X、Y、Z軸的排序與flipping的方法
        var now_sortXOrderSelect = "";
        var now_sortYOrderSelect = "";
        var now_sortZOrderSelect = "";
        var now_Xflip_side = "";
        var now_Yflip_side = "";
        var now_Zflip_side = "";
    </script>

    <script type="module">
        import Papa from 'https://cdn.skypack.dev/papaparse@5.3.0';
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        // import { TrackballControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/TrackballControls.js';

        $( function() {
            // 初始化雙按鈕滑動條
            $( "#double-slider" ).slider({
                range: true, // 啟用範圍選擇功能
                min: globalMin, // 設定最小值
                max: globalMax, // 設定最大值
                values: [ globalMin, globalMax ], // 設定初始的兩個按鈕位置
                create: function() {
                    // 建立顯示數值的標籤並附加到滑動條
                    var handles = $("#double-slider .ui-slider-handle");
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(0)).text(globalMin.toFixed(1));
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(1)).text(globalMax.toFixed(1));
                },
                slide: function(event, ui) {
                    // 根據滑動值更新步長
                    if (ui.value >= 0 && ui.value <= 1) {
                        $("#double-slider").slider("option", "step", 0.1);
                    } else {
                        $("#double-slider").slider("option", "step", 1);
                    }

                    // 更新按鈕位置顯示的值
                    $(ui.handle).find(".ui-slider-value").text(ui.value.toFixed(1));

                    // 更新全域變數
                    globalSliderMin = ui.values[0];
                    globalSliderMax = ui.values[1];
                    
                    // 每次滑動時更新顏色
                    updateCubeColorsBasedOnSlider(globalSliderMin, globalSliderMax);

                    // 重置 DisplayCondition 下拉式選單回到預設選項 (Range: Cube)
                    document.getElementById('DisplayCondition').selectedIndex = 0;
                }
            });
        });

        // 根據滑動條的值更新立方體顏色
        function updateCubeColorsBasedOnSlider(sliderMin, sliderMax) {
            var reverseColors = document.getElementById('reverseColors').checked; // 取得 reverseColors 的狀態

            scene.traverse(function(object) {
                if (object instanceof THREE.Mesh) {
                    var value = object.userData.value; // 立方體的值
                    var colorScheme = document.getElementById('colorSchemeSelect').value; // 目前選取的顏色方案
                    var colors = colorSchemes[colorScheme]; // 根據色彩方案取得顏色數組
                    var minColor = reverseColors ? colors[colors.length - 1] : colors[0]; // 考慮反轉的最小顏色
                    var maxColor = reverseColors ? colors[0] : colors[colors.length - 1]; // 考慮反轉的最大顏色

                    if (value < sliderMin) {
                        // 值小於滑動條最小值
                        object.material.color.set(minColor);
                    } else if (value > sliderMax) {
                        // 值大於滑動條最大值
                        object.material.color.set(maxColor);
                    } else {
                        // 值在滑動條選擇的範圍內
                        var colorIndex = mapValueToColor(value, colorScheme, sliderMin, sliderMax);
                        object.material.color.set(colorIndex);
                    }
                }
            });
        }

        $( function() {
            // 初始化雙按鈕滑動條
            $( "#double-slider-cubesvalue" ).slider({
                range: true, // 啟用範圍選擇功能
                min: globalMin, // 設定最小值
                max: globalMax, // 設定最大值
                values: [ globalMin, globalMax ], // 設定初始的兩個按鈕位置
                create: function() {
                    // 建立顯示數值的標籤並附加到滑動條
                    var handles = $("#double-slider-cubesvalue .ui-slider-handle");
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(0)).text(globalMin.toFixed(1));
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(1)).text(globalMax.toFixed(1));
                },
                slide: function(event, ui) {
                    // 根據滑動值更新步長
                    if (ui.value >= 0 && ui.value <= 1) {
                        $("#double-slider-cubesvalue").slider("option", "step", 0.1);
                    } else {
                        $("#double-slider-cubesvalue").slider("option", "step", 1);
                    }

                    // 更新按鈕位置顯示的值
                    $(ui.handle).find(".ui-slider-value").text(ui.value.toFixed(1));

                    // 更新全域變數
                    globalSliderMin = ui.values[0];
                    globalSliderMax = ui.values[1];

                    // // 更新全域變數
                    // doubleslidercubesvalue = ui.values;
                    // console.log(doubleslidercubesvalue[0], doubleslidercubesvalue[1]);

                    // 每次滑動時更新透明度
                    filterCubes();
                    //updateCubeOpacityBasedOnSlider(globalSliderMin, globalSliderMax);
                }
            });
        });

        // 根據滑動條的值更新立方體的透明度
        /*function updateCubeOpacityBasedOnSlider(sliderMin, sliderMax) {
            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // 更新 filter 掉之 cubes 透明度
            var filteropacityRange = document.getElementById('filteropacityRange');
            var filternewOpacity = parseFloat(filteropacityRange.value);
            //document.getElementById('filteropacityValue').textContent = filternewOpacity;

            cubes.forEach((cubeRow, i) => {
                cubeRow.forEach((cubeColumn, j) => {
                    cubeColumn.forEach((cube, k) => {
                        if (cube) {
                            var value = cube.userData.value; // 立方體的值

                            if (value == null) { // 如果為遺失值，透明度為 0
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                            } 
                            else{
                                if (categoryConditions.size == 0 && rangeConditions.size == 0) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                                    // 非遺失值值立方體根據滑動條更新透明度
                                    if (value < SliderMin || value > SliderMax) {
                                        // 值不在滑動條選擇的範圍內
                                        cube.material.opacity = 0;
                                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                                
                                    } else if (SliderMin <= value <= SliderMax) {
                                        // 值在滑動條選擇的範圍內
                                        cube.material.opacity = newOpacity;
                                        // 追蹤透明度值
                                        cubesOpacity[i][j][k] = cube.material.opacity; 
                                    }
                                }
                                else
                                {   
                                    // 非遺失值值立方體根據滑動條更新透明度
                                    if (value < SliderMin || value > SliderMax) {
                                        // 值不在滑動條選擇的範圍內
                                        cube.material.opacity = 0;
                                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                                
                                    } else if (SliderMin <= value <= SliderMax) {
                                        // 值在滑動條選擇的範圍內
                                        if(matchesCategoryConditions && matchesRangeConditions)
                                            cube.material.opacity = newOpacity;
                                        else
                                            cube.material.opacity = filternewOpacity; 
                                        cubesOpacity[i][j][k] = cube.material.opacity;

                                    }
                                }
                            }
                            cube.material.needsUpdate = true;
                        }
                    });
                });
            });
        }
        */

        // 創建場景
        var scene = new THREE.Scene();

        // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // const frustumSize = 80; // 根據需要調整這個值 (大小差很多)

        // var camera = new THREE.OrthographicCamera(
        //     frustumSize * window.innerWidth / window.innerHeight / -2,
        //     frustumSize * window.innerWidth / window.innerHeight / 2,
        //     frustumSize / 2,
        //     frustumSize / -2,
        //     1,
        //     1000
        // );

        // Function to set up the camera based on the selected option
        function setupInitialCamera() {
            const selectedCamera = document.querySelector('input[name="Camera"]:checked').value;
            return PeorOrcamera(selectedCamera);
        }

        // Global variable for the camera
        var camera = setupInitialCamera();

        // 設定相機投影方式 (透視 or 正交)
        function PeorOrcamera(selectedCamera) {
            switch (selectedCamera) {
                case 'Pe':
                    // 創建透視相機
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    break;
                case 'Or':
                    // 設置正交相機
                    const frustumSize = 80; // 根據需要調整這個值 (大小差很多)

                    camera = new THREE.OrthographicCamera(
                        frustumSize * window.innerWidth / window.innerHeight / -2,
                        frustumSize * window.innerWidth / window.innerHeight / 2,
                        frustumSize / 2,
                        frustumSize / -2,
                        1,
                        1000
                    );
                    break;
            }

            return camera; // Return the camera object so it can be used outside this function
        }

        // 偵測 radio 按鈕的變化
        document.getElementById("PeorOrCamera").addEventListener("change", function(event) {
            // 取得選取的軸
            let selectedcamera = event.target.value;

            // console.log(selectedcamera);

            // 呼叫 PeorOrcamera 函數，傳入選中的軸
            camera = PeorOrcamera(selectedcamera);

            controls = new OrbitControls(camera, renderer.domElement);

            setDefaultCameraPosition();

            // renderer.render(scene, camera);

            // 設定控制相機的參數
            controls.rotateSpeed = .5;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 1.8;
            controls.noZoom = false;
            controls.noPan = false;

            animate();
        });

        // 創建渲染器
        var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // 消除鋸齒、允許設置透明度
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('threejs-container').appendChild(renderer.domElement);

        // 初始化鼠標頂點
        var closestVertex = new THREE.Vector3();

        // 初始化視角頂點
        var closestVertex_camera = new THREE.Vector3();

        // 設定相機位置，以便我們可以看到對象
        camera.position.z = 5;
                
        //---- functions ----//
        //---- functions ----//

        // 提取 data 中所有 column 之唯一值，以創建 data_array
        function getUniqueColumnValues(dataArray, columnName) {
            // 從 dataArray 中提取 columnName 欄位的值
            var columnValues = dataArray.map(function(item) {
                return item[columnName];
            }).filter(function(value) {
                return value !== undefined && value !== null && value !== ""; // 過濾掉 undefined、null 和空字符串
            });
            return Array.from(new Set(columnValues));
        }

        // 創建資料結構
        function createDataArray(X, Y, Z) {
            var array = new Array(X.length);
            for (var i = 0; i < X.length; i++) {
                array[i] = new Array(Y.length);
                for (var j = 0; j < Y.length; j++) {
                    array[i][j] = new Array(Z.length).fill(null);
                }
            }
            return array;
        }

        // 根據所選欄位來填充資料結構
        function fillDataArray(data, dataArray, X, Y, Z, fieldX, fieldY, fieldZ) {
            var selectedValueField = document.getElementById('singleSelect').value; // 獲取單選下拉式選單中選擇的欄位
            data.forEach(function(row) {
                var i = X.indexOf(row[fieldX]);
                var j = Y.indexOf(row[fieldY]);
                var k = Z.indexOf(row[fieldZ]);
                if (i > -1 && j > -1 && k > -1) {
                    var value = parseFloat(row[selectedValueField]); // 使用所選欄位的值
                    dataArray[i][j][k] = isNaN(value) ? null : value;
                }
            });
        }

        // 更新透明度
        function updateOpacity() {
            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // 更新 filter 掉之 cubes 透明度
            var filteropacityRange = document.getElementById('filteropacityRange');
            var filternewOpacity = parseFloat(filteropacityRange.value);
            document.getElementById('filteropacityValue').textContent = filternewOpacity;

            cubes.forEach((cubeRow, i) => {
                cubeRow.forEach((cubeColumn, j) => {
                    cubeColumn.forEach((cube, k) => {
                        if (cube) {
                            var value = cube.userData.value; // 立方體的值
                            if (value == null) { // 如果為遺失值，透明度為 0
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                            } else if (cubesOpacity[i][j][k] > 0 && categoryConditions.size == 0 && rangeConditions.size == 0 && value != null) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                                // 非遺失值值立方體根據滑動條更新透明度
                                //cube.material.opacity = newOpacity;
                                //cubesOpacity[i][j][k] = newOpacity; // 追蹤透明度值
                                if (value < globalSliderMin || value > globalSliderMax) {
                                    // 值不在滑動條選擇的範圍內
                                    cube.material.opacity = filteropacityValue;
                                    cubesOpacity[i][j][k] = filteropacityValue; // 追蹤透明度值
                                    // console.log(cubesOpacity);
                                    
                                } else if (globalSliderMin <= value <= globalSliderMax) {
                                    // 值在滑動條選擇的範圍內
                                    cube.material.opacity = newOpacity;
                                    cubesOpacity[i][j][k] = newOpacity; // 追蹤透明度值
                                    //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);
                                }
                            }
                            cube.material.needsUpdate = true;
                        }
                    });
                });
            });

            // 重新渲染場景以應用透明度更改
            // renderer.render(scene, camera);
        }

        // 滑動條值改變時呼叫 updateOpacity、filterCubes函數
        document.getElementById('opacityRange').addEventListener('input', function() {
            currentOpacity = parseFloat(this.value);
            //updateOpacity();
            filterCubes();
        });

        // 滑動條值改變時呼叫 filterCubes 函數
        document.getElementById('filteropacityRange').addEventListener('input', function() {
            filterCubes();
        });

        // 填充下拉式選單選項
        function fillSelectOptions(selectId, options) {
            var select = document.getElementById(selectId);
            select.innerHTML = ''; // 清空現有選項

            // 添加預設選項
            var defaultOption = document.createElement('option');
            defaultOption.value = "null";
            defaultOption.textContent = "-----";
            defaultOption.disabled = true; // 如果你想要這個選項是不可選的
            defaultOption.selected = true; // 讓它成為預設選中的選項
            select.appendChild(defaultOption);

            options.forEach(function(option) {
                var opt = document.createElement('option');
                opt.value = option;
                opt.innerHTML = option;
                select.appendChild(opt);
            });
        }

        // 訪問下拉式選單的選項並獲取其值
        function getSelectedOptions(selectId) {
            var select = document.getElementById(selectId);
            var selectedOptions = Array.from(select.selectedOptions);
            var selectedValues = selectedOptions.map(option => option.value);
            return selectedValues;
        }

        // 更新單選下拉式選單的選項，移除已被複選下拉式選單選中的選項
        function updateSelectOptions(singleSelectId, selectedXId, selectedYId, selectedZId, allOptions) {
            var singleSelect = document.getElementById(singleSelectId);
            var XSelect = document.getElementById(selectedXId);
            var YSelect = document.getElementById(selectedYId);
            var ZSelect = document.getElementById(selectedZId);

            // 取得三個單選下拉式選單中選取的選項值
            var selectedXValue = XSelect.value;
            var selectedYValue = YSelect.value;
            var selectedZValue = ZSelect.value;

            // 篩選出已被選中的選項值
            var selectedValues = [selectedXValue, selectedYValue, selectedZValue].filter(value => value !== "null");

            // 清空單選下拉式選單的選項
            singleSelect.innerHTML = '';

            // 添加預設 "-----" 選項
            var defaultOption = document.createElement('option');
            defaultOption.value = "null";
            defaultOption.textContent = "-----";
            defaultOption.selected = true; // 讓它成為預設選中的選項
            singleSelect.appendChild(defaultOption);

            // 創建並添加其它選項
            allOptions.forEach(function(option) {
                if (!selectedValues.includes(option)) {
                    var opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    singleSelect.appendChild(opt);
                }
            });

            // 預設選項保持選中狀態
            singleSelect.value = "null";
        }

        // // 填充 2d heatmap 之下拉式菜单
        // function fillSelectfor2dheatmap(selectorId, items) {
        //     const select = document.getElementById(selectorId);
        //     items.forEach(item => {
        //         const option = document.createElement('option');
        //         option.value = option.textContent = item;
        //         select.appendChild(option);
        //     });
        // }

        // 找出資料之最小值和最大值
        function findMinMax(data, valueField) {
            var min = Infinity;
            var max = -Infinity;
            data.forEach(function (row) {
                var value = parseFloat(row[valueField]);
                if (!isNaN(value)) {
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            });
            return { min: min, max: max };
        }

        // 正規化資料值
        function normalize(value, min, max) {
            // 防止除以零
            if (max === min) {
                return 0.5; // 或者根據需要返回其他合理的值
            }
            return (value - min) / (max - min);
        }

        // 顏色映射函數
        function mapValueToColor(value, colorScheme, min, max) {
            switch (colorScheme) {
                case 'RdYlGn':
                    return mapValueTocolorSchemes("RdYlGn", value, min, max);
                case 'Blues':
                    return mapValueTocolorSchemes("Blues", value, min, max);
                case 'Reds':
                    return mapValueTocolorSchemes("Reds", value, min, max);
                case 'Greys':
                    return mapValueTocolorSchemes("Greys", value, min, max);
                case 'YlGnBu':
                    return mapValueTocolorSchemes("YlGnBu", value, min, max);
                case 'YlOrRd':
                    return mapValueTocolorSchemes("YlOrRd", value, min, max);
                case 'RdYlBu':
                    return mapValueTocolorSchemes("RdYlBu", value, min, max);
                case 'RdGy':
                    return mapValueTocolorSchemes("RdGy", value, min, max);
                case 'RdBu':
                    return mapValueTocolorSchemes("RdBu", value, min, max);
                case 'PiYG':
                    return mapValueTocolorSchemes("PiYG", value, min, max);
                case 'PRGn':
                    return mapValueTocolorSchemes("PRGn", value, min, max);
                case 'BrBG':
                    return mapValueTocolorSchemes("BrBG", value, min, max);
                case 'PuOr':
                    return mapValueTocolorSchemes("PuOr", value, min, max);
                case 'YlOrBr':
                    return mapValueTocolorSchemes("YlOrBr", value, min, max);
                case 'YlGn':
                    return mapValueTocolorSchemes("YlGn", value, min, max);
                case 'RdPu':
                    return mapValueTocolorSchemes("RdPu", value, min, max);
                case 'Purples':
                    return mapValueTocolorSchemes("Purples", value, min, max);
                case 'PuRd':
                    return mapValueTocolorSchemes("PuRd", value, min, max);
                case 'PuBuGn':
                    return mapValueTocolorSchemes("PuBuGn", value, min, max);
                case 'PuBu':
                    return mapValueTocolorSchemes("PuBu", value, min, max);
                case 'OrRd':
                    return mapValueTocolorSchemes("OrRd", value, min, max);
                case 'Oranges':
                    return mapValueTocolorSchemes("Oranges", value, min, max);
                case 'Greens':
                    return mapValueTocolorSchemes("Greens", value, min, max);
                case 'GnBu':
                    return mapValueTocolorSchemes("GnBu", value, min, max);
                case 'BuPu':
                    return mapValueTocolorSchemes("BuPu", value, min, max);
                case 'BuGn':
                    return mapValueTocolorSchemes("BuGn", value, min, max);
                case 'Spectral':
                    return mapValueTocolorSchemes("Spectral", value, min, max)
                case 'Set3':
                    return mapValueTocolorSchemes("Set3", value, min, max);
                case 'Set2':
                    return mapValueTocolorSchemes("Set2", value, min, max);
                case 'Set1':
                    return mapValueTocolorSchemes("Set1", value, min, max);
                case 'Pastel2':
                    return mapValueTocolorSchemes("Pastel2", value, min, max);
                case 'Pastel1':
                    return mapValueTocolorSchemes("Pastel1", value, min, max);
                case 'Paired':
                    return mapValueTocolorSchemes("Paired", value, min, max);
                case 'Dark2':
                    return mapValueTocolorSchemes("Dark2", value, min, max);
                case 'Accent':
                    return mapValueTocolorSchemes("Accent", value, min, max);
                case 'GAP_Rainbow':
                    return mapValueTocolorSchemes("GAP_Rainbow", value, min, max);
                case 'GAP_Blue_White_Red':
                    return mapValueTocolorSchemes("GAP_Blue_White_Red",value, min, max);
                default:
                    return new THREE.Color(0xffffff); // 預設白色
            }
        }

        // 更新顏色方案
        function updateColorScheme() {
            var colorSchemeSelect = document.getElementById('colorSchemeSelect');
            var selectedColorScheme = colorSchemeSelect.value;

            // 確保 globalMin 和 globalMax 已被定義
            if (typeof globalMin === 'number' && typeof globalMax === 'number') {
                scene.traverse(function (object) {
                    if (object instanceof THREE.Mesh) {
                        var value = object.userData.value;
                        // 確保 value 是有效的數字
                        if (typeof value === 'number' && !isNaN(value)) {
                            object.material.color = mapValueToColor(value, selectedColorScheme, globalMin, globalMax);
                            object.material.needsUpdate = true;
                        }
                    }
                });
            }
        }

        // 定義顏色方案的映射 (colorbrewer)
        const colorSchemes = {
        RdYlGn: ['#D73027', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#D9EF8B', '#A6D96A', '#66BD63', '#1A9850'],
        Blues: ['#EFF3FF', '#C6DBEF', '#9ECAE1', '#6BAED6', '#3182BD', '#08519C'],
        Reds: ['#FFF5F0', '#FEE0D2', '#FCBBA1', '#FC9272', '#FB6A4A', '#EF3B2C', '#CB181D', '#A50F15', '#67000D'],
        Greys: ['#f7f7f7', '#cccccc', '#969696', '#636363', '#252525'],
        YlGnBu: ['#ffffcc', '#a1dab4', '#41b6c4', '#2c7fb8', '#253494'],
        YlOrRd: ['#ffffb2', '#fecc5c', '#fd8d3c', '#f03b20', '#bd0026'],
        RdYlBu: ['#d73027', '#fc8d59', '#fee090', '#e0f3f8', '#91bfdb', '#4575b4'],
        RdGy: ['#ef3b2c', '#fcbba1', '#ffffff', '#bababa', '#878787', '#4d4d4d'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#d01c8b', '#f1b6da', '#f7f7f7', '#b8e186', '#4dac26'],
        PRGn: ['#762a83', '#af8dc3', '#e7d4e8', '#d9f0d3', '#7fbf7b', '#1b7837'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
        dYlGn: ['#D73027', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#D9EF8B', '#A6D96A', '#66BD63', '#1A9850'],
        YlOrBr: ['#FFFFD4', '#FEE391', '#FEC44F', '#FE9929', '#EC7014', '#CC4C02', '#993404', '#662506'],
        YlGn: ['#FFFFCC', '#C7E9C0', '#A1D99B', '#74C476', '#41AB5D', '#238B45', '#006D2C', '#00441B'],
        RdPu: ['#FEEBE2', '#FCC5C0', '#FA9FB5', '#F768A1', '#DD3497', '#AE017E', '#7A0177'],
        Purples: ['#FCFBFD', '#EFEDF5', '#DADAEB', '#BCBDDC', '#9E9AC8', '#807DBA', '#6A51A3', '#54278F', '#3F007D'],
        PuRd: ['#F7F4F9', '#E7E1EF', '#D4B9DA', '#C994C7', '#DF65B0', '#E7298A', '#CE1256', '#980043', '#67001F'],
        PuBuGn: ['#F6EFF7', '#D0D1E6', '#A6BDDB', '#67A9CF', '#3690C0', '#02818A', '#016C59', '#014636'],
        PuBu: ['#F1EEF6', '#D0D1E6', '#A6BDDB', '#74A9CF', '#3690C0', '#0570B0', '#045A8D', '#023858'],
        OrRd: ['#FFF7EC', '#FEE8C8', '#FDD49E', '#FDBB84', '#FC8D59', '#EF6548', '#D7301F', '#B30000', '#7F0000'],
        Oranges: ['#FFF5EB', '#FEE6CE', '#FDD0A2', '#FDAE6B', '#FD8D3C', '#F16913', '#D94801', '#A63603', '#7F2704'],
        Greens: ['#F7FCF5', '#E5F5E0', '#C7E9C0', '#A1D99B', '#74C476', '#41AB5D', '#238B45', '#006D2C', '#00441B'],
        GnBu: ['#F7FCF0', '#E0F3DB', '#CCEBC5', '#A8DDB5', '#7BCCC4', '#4EB3D3', '#2B8CBE', '#0868AC', '#084081'],
        BuPu: ['#EDF8FB', '#BFD3E6', '#9EBCDA', '#8C96C6', '#8C6BB1', '#88419D', '#810F7C', '#4D004B'],
        BuGn: ['#F0F9E8', '#BAE4BC', '#7BCCC4', '#43A2CA', '#0868AC', '#084081'],
        Spectral: ['#D53E4F', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#E6F598', '#ABDDA4', '#66C2A5', '#3288BD'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9'],
        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        GAP_Rainbow: ["#00008C", "#004DEB", "#007359", "#66A600", "#B3E600", "#CCF200", "#FFFF00", "#FFE600", "#FFB300", "#FF6600", "#FF0000", "#D90000", "#A60000"],
        GAP_Blue_White_Red: ["#00006B", "#00009E", "#0000BF", "#0000E8", "#2121FF", "#4A4AFF", "#7A7AFF", "#ADADFF", "#E0E0FF", "#FAFAFF", "#FFFAFA", "#FFC7C7", "#FF9494", "#FF6161", "#FF3838", "#FF0000", "#CF0000", "#AD0000", "#850000", "#520000"],
        };

        // 顏色映射函數
        function mapValueTocolorSchemes(schemeName, value, min, max) {
            var colors = colorSchemes[schemeName];
            var reverse = document.getElementById('reverseColors').checked; // 檢查 checkbox 是否被勾選
            var normalized = normalize(value, min, max);
            var index = Math.floor(normalized * (colors.length - 1));

            if (reverse) {
                index = colors.length - 1 - index; // 反轉顏色索引
            }

            return new THREE.Color(colors[index]);
        }

        // 根據顏色方案更新 colorbar 的背景，並更新最小值和最大值標籤的內容
        function updateColorbar(colorScheme, min, max) {
            var colorbarContainer = document.getElementById('colorbar-container');
            var colorbar = document.getElementById('colorbar');
            var colorbarMinLabel = document.getElementById('colorbar-min-label');
            var colorbarMaxLabel = document.getElementById('colorbar-max-label');

            // 根據顏色方案更新 colorbar 的背景漸變
            var gradient = getColorGradient(colorScheme);
            colorbar.style.background = gradient;

            // 顯示 colorbar 容器
            colorbarContainer.style.display = 'block';

            // 更新最小值和最大值標籤的內容
            colorbarMinLabel.textContent = min; // 四捨五入?
            colorbarMaxLabel.textContent = max;
        }

        // 根據顏色方案獲取漸變樣式的函數
        function getColorGradient(colorScheme) {
            var reverse = document.getElementById('reverseColors').checked; // 檢查 checkbox 是否被選中
            var direction = reverse ? 'to bottom' : 'to top'; // 根據是否反轉來決定漸變方向

            switch (colorScheme) {
                case 'RdYlGn':
                    return `linear-gradient(${direction}, red, yellow, green)`;
                case 'Blues':
                    return `linear-gradient(${direction}, #f7fbff, #4292c6)`;
                case 'Reds':
                    return `linear-gradient(${direction}, #fff5f0, #cb181d)`;
                case 'Greys':
                    return `linear-gradient(${direction}, #f7f7f7, #cccccc, #969696, #636363, #252525)`;
                case 'YlGnBu':
                    return `linear-gradient(${direction}, #ffffcc, #a1dab4, #41b6c4, #2c7fb8, #253494)`;
                case 'YlOrRd':
                    return `linear-gradient(${direction}, #ffffb2, #fecc5c, #fd8d3c, #f03b20, #bd0026)`;
                case 'RdYlBu':
                    return `linear-gradient(${direction}, #d73027, #fc8d59, #fee090, #e0f3f8, #91bfdb, #4575b4)`;
                case 'RdGy':
                    return `linear-gradient(${direction}, #ef3b2c, #fcbba1, #ffffff, #bababa, #878787, #4d4d4d)`;
                case 'RdBu':
                    return `linear-gradient(${direction}, #67001f, #b2182b, #d6604d, #f4a582, #fddbc7, #d1e5f0, #92c5de, #4393c3, #2166ac, #053061)`;
                case 'PiYG':
                    return `linear-gradient(${direction}, #d01c8b, #f1b6da, #f7f7f7, #b8e186, #4dac26)`;
                case 'PRGn':
                    return `linear-gradient(${direction}, #762a83, #af8dc3, #e7d4e8, #d9f0d3, #7fbf7b, #1b7837)`;
                case 'BrBG':
                    return `linear-gradient(${direction}, #543005, #8c510a, #bf812d, #dfc27d, #f6e8c3, #c7eae5, #80cdc1, #35978f, #01665e, #003c30)`;
                case 'PuOr':
                    return `linear-gradient(${direction}, #7f3b08, #b35806, #e08214, #fdb863, #fee0b6, #d8daeb, #b2abd2, #8073ac, #542788, #2d004b)`;
                case 'YlOrBr':
                    return `linear-gradient(${direction}, #FFFFD4, #FEE391, #FEC44F, #FE9929, #EC7014, #CC4C02, #993404, #662506)`;
                case 'YlGn':
                    return `linear-gradient(${direction}, #FFFFCC, #C7E9C0, #A1D99B, #74C476, #41AB5D, #238B45, #006D2C, #00441B)`;
                case 'RdPu':
                    return `linear-gradient(${direction}, #FEEBE2, #FCC5C0, #FA9FB5, #F768A1, #DD3497, #AE017E, #7A0177)`;
                case 'Purples':
                    return `linear-gradient(${direction}, #FCFBFD, #EFEDF5, #DADAEB, #BCBDDC, #9E9AC8, #807DBA, #6A51A3, #54278F, #3F007D)`;
                case 'PuRd':
                    return `linear-gradient(${direction}, #F7F4F9, #E7E1EF, #D4B9DA, #C994C7, #DF65B0, #E7298A, #CE1256, #980043, #67001F)`;
                case 'PuBuGn':
                    return `linear-gradient(${direction}, #F6EFF7, #D0D1E6, #A6BDDB, #67A9CF, #3690C0, #02818A, #016C59, #014636)`;
                case 'PuBu':
                    return `linear-gradient(${direction}, #F1EEF6, #D0D1E6, #A6BDDB, #74A9CF, #3690C0, #0570B0, #045A8D, #023858)`;
                case 'OrRd':
                    return `linear-gradient(${direction}, #FFF7EC, #FEE8C8, #FDD49E, #FDBB84, #FC8D59, #EF6548, #D7301F, #B30000, #7F0000)`;
                case 'Oranges':
                    return `linear-gradient(${direction}, #FFF5EB, #FEE6CE, #FDD0A2, #FDAE6B, #FD8D3C, #F16913, #D94801, #A63603, #7F2704)`;
                case 'Greens':
                    return `linear-gradient(${direction}, #F7FCF5, #E5F5E0, #C7E9C0, #A1D99B, #74C476, #41AB5D, #238B45, #006D2C, #00441B)`;
                case 'GnBu':
                    return `linear-gradient(${direction}, #F7FCF0, #E0F3DB, #CCEBC5, #A8DDB5, #7BCCC4, #4EB3D3, #2B8CBE, #0868AC, #084081)`;
                case 'BuPu':
                    return `linear-gradient(${direction}, #EDF8FB, #BFD3E6, #9EBCDA, #8C96C6, #8C6BB1, #88419D, #810F7C, #4D004B)`;
                case 'BuGn':
                    return `linear-gradient(${direction}, #F0F9E8, #BAE4BC, #7BCCC4, #43A2CA, #0868AC, #084081)`;
                case 'Spectral':
                    return `linear-gradient(${direction}, #D53E4F, #F46D43, #FDAE61, #FEE08B, #FFFFBF, #E6F598, #ABDDA4, #66C2A5, #3288BD)`;
                case 'Set3':
                    return `linear-gradient(${direction}, #8dd3c7, #ffffb3, #bebada)`;
                case 'Set2':
                    return `linear-gradient(${direction}, #66c2a5, #fc8d62, #8da0cb)`;
                case 'Set1':
                    return `linear-gradient(${direction}, #e41a1c, #377eb8, #4daf4a)`;
                case 'Pastel2':
                    return `linear-gradient(${direction}, #b3e2cd, #fdcdac, #cbd5e8)`;
                case 'Pastel1':
                    return `linear-gradient(${direction}, #fbb4ae, #b3cde3, #ccebc5)`;
                case 'Paired':
                    return `linear-gradient(${direction}, #a6cee3, #1f78b4, #b2df8a)`;
                case 'Dark2':
                    return `linear-gradient(${direction}, #1b9e77, #d95f02, #7570b3)`;
                case 'Accent':
                    return `linear-gradient(${direction}, #7fc97f, #beaed4, #fdc086)`;
                case 'GAP_Rainbow':
                    return `linear-gradient(${direction}, #00008C, #004DEB, #007359, #66A600, #B3E600, #CCF200, #FFFF00, #FFE600, #FFB300, #FF6600, #FF0000, #D90000, #A60000)`;
                case 'GAP_Blue_White_Red':
                    return `linear-gradient(${direction}, #00006B, #00009E, #0000BF, #0000E8, #2121FF, #4A4AFF, #7A7AFF, #ADADFF, #E0E0FF, #FAFAFF, #FFFAFA, #FFC7C7, #FF9494, #FF6161, #FF3838, #FF0000, #CF0000, #AD0000, #850000, #520000)`;
                default:
                    return `linear-gradient(${direction}, white, black)`; // 預設漸變
            }
        }

        // color bar 在資料載入後才出現
        function updateEverycolorthingBasedOnCurrentSettings() {
            var selectedColorScheme = document.getElementById('colorSchemeSelect').value;
            if (isDataLoaded) { // 只有在資料載入後才調用
                updateColorbar(selectedColorScheme, globalMin, globalMax);
                // 也更新其他需要根據這些設定變化的元素，例如場景中的物體顏色
                updateColorScheme();
            }
        }

        // 確保在顏色方案發生變化時 updateColorbar 函數能夠根據當前的反轉狀態更新色條
        document.getElementById('colorSchemeSelect').addEventListener('change', function() {
            updateEverycolorthingBasedOnCurrentSettings();

            // 從 DOM 取得目前選取的 displayCondition
            var displayCondition = document.getElementById('DisplayCondition').value;

            applyChangesBasedOnNewIndices();
        });

        // reverseColors
        document.getElementById('reverseColors').addEventListener('change', function() {
            updateEverycolorthingBasedOnCurrentSettings();

            // 從 DOM 取得目前選取的 displayCondition
            var displayCondition = document.getElementById('DisplayCondition').value;

            applyChangesBasedOnNewIndices();
        });

        // X Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforXproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforXproximity").property("value");
            var newCondition = "RangeMatrix";
            gapX.optionTargetDataMap = "rp";
            gapX.rpPaletteReverse = document.getElementById('reverseColorforX').checked;
            gapX.changePalette(newCondition, newPalette, "#windowProxforX_svg");
        });

        // X Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforX').addEventListener('change', function() {
            var newPalette = d3.select("#colorforXproximity").property("value");
            var newCondition = "RangeMatrix";
            gapX.optionTargetDataMap = "rp";
            gapX.rpPaletteReverse = document.getElementById('reverseColorforX').checked;
            gapX.changePalette(newCondition, newPalette, "#windowProxforX_svg");
        });

        // Y Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforYproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforYproximity").property("value");
            var newCondition = "RangeMatrix";
            gapY.optionTargetDataMap = "rp";
            gapY.rpPaletteReverse = document.getElementById('reverseColorforY').checked;
            gapY.changePalette(newCondition, newPalette, "#windowProxforY_svg");
        });

        // Y Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforY').addEventListener('change', function() {
            var newPalette = d3.select("#colorforYproximity").property("value");
            var newCondition = "RangeMatrix";
            gapY.optionTargetDataMap = "rp";
            gapY.rpPaletteReverse = document.getElementById('reverseColorforY').checked;
            gapY.changePalette(newCondition, newPalette, "#windowProxforY_svg");
        });

        // Z Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforZproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforZproximity").property("value");
            var newCondition = "RangeMatrix";
            gapZ.optionTargetDataMap = "rp";
            gapZ.rpPaletteReverse = document.getElementById('reverseColorforZ').checked;
            gapZ.changePalette(newCondition, newPalette, "#windowProxforZ_svg");
        });

        // Z Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforZ').addEventListener('change', function() {
            var newPalette = d3.select("#colorforZproximity").property("value");
            var newCondition = "RangeMatrix";
            gapZ.optionTargetDataMap = "rp";
            gapZ.rpPaletteReverse = document.getElementById('reverseColorforZ').checked;
            gapZ.changePalette(newCondition, newPalette, "#windowProxforZ_svg");
        });

        // 更改邊長
        function updateCubeSizesAndPositions() {
            if (!allowUpdateSizes) return; // 如果不允許修改邊長，直接返回

            // 先清除現有的軸線
            clearAxesLines();
            
            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value);
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value);
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value);

            // 更新顯示值
            document.getElementById('cubeSizeXValue').textContent = cubeSizeX;
            document.getElementById('cubeSizeYValue').textContent = cubeSizeY;
            document.getElementById('cubeSizeZValue').textContent = cubeSizeZ;

            for (let i = 0; i < cubes.length; i++) {
                for (let j = 0; j < cubes[i].length; j++) {
                    for (let k = 0; k < cubes[i][j].length; k++) {
                        let cube = cubes[i][j][k];
                        if (cube) {
                            // 更新立方體的尺寸
                            cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                            // 計算並更新立方體的新位置
                            var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            cube.position.set(posX, posY, posZ);

                            // if (newSize == 1) {
                            //     // 更新立方體的尺寸
                            //     cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                            //     // 計算並更新立方體的新位置
                            //     var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            //     var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            //     var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            //     cube.position.set(posX, posY, posZ);
                            // } else {
                            //     // 調整縮放比例
                            //     // cube.scale.set(newSize, newSize, newSize);

                            //     // 計算並更新立方體的新位置
                            //     var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            //     var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            //     var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            //     cube.position.set(posX, posY, posZ);
                            // }
                        }
                    }
                }
            }

            // // 在立方體創建後添加軸線，且直接與邊長同步縮放
            updateAxesStartPoint();

            // 呼叫渲染函數來更新場景
            // renderer.render(scene, camera);
        }

        // 為每個滑桿新增事件監聽器
        document.getElementById('cubeSizeX').addEventListener('input', updateCubeSizesAndPositions);
        document.getElementById('cubeSizeY').addEventListener('input', updateCubeSizesAndPositions);
        document.getElementById('cubeSizeZ').addEventListener('input', updateCubeSizesAndPositions);

        // 更新 X, Y, Z 軸邊長之滑桿值顯示
        document.getElementById('cubeSizeX').addEventListener('input', function() {
            // 取得滑動條目前的值
            var value = this.value;
            // 更新顯示目前值的 <span> 元素的內容
            document.getElementById('cubeSizeXValue').textContent = value;
        });

        document.getElementById('cubeSizeY').addEventListener('input', function() {
            var value = this.value;
            document.getElementById('cubeSizeYValue').textContent = value;
        });

        document.getElementById('cubeSizeZ').addEventListener('input', function() {
            var value = this.value;
            document.getElementById('cubeSizeZValue').textContent = value;
        });

        // 更改 X 軸排序
        function updateXOrder() {           
            var XsortOrder = now_sortXOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Xflip_side == "r2e")
                nowFlip = 1;
            else if(now_Xflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Xflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;

            // flip 防呆 (r2e => heatmap_utility.js)
            if (XsortOrder == "r2e" || XsortOrder == "singlelinkage" || XsortOrder == "averagelinkage" || XsortOrder == "completelinkage")
            {
                //$("#Xflip").prop("disabled",false);
                $("#Xflip_side").prop("disabled",false);
            }


            if (XsortOrder === "original_X") {
                // 產生原始排序的 X 軸索引
                var originalXIndices = [...Array(uniqueX.length).keys()]

                // 用原始順序更新 Xindices
                Xindices = originalXIndices;

                if (typeof gapX !== "undefined")
                    if(!gapX.firstRunRowTree)
                        d3.select("#windowProxforX").selectAll("#rowTree").remove();
            } else if (XsortOrder === "random_X") {
                // 產生隨機排序的 X 軸索引
                var randomXIndices = [...Array(uniqueX.length).keys()].sort(() => Math.random() - 0.5);

                // 用隨機順序更新 Xindices
                Xindices = randomXIndices;

                if (typeof gapX !== "undefined")
                    if(!gapX.firstRunRowTree)
                        d3.select("#windowProxforX").selectAll("#rowTree").remove();
            } else if (XsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 X 軸索引                       81 - 89、751 - 752 * 3、dendrogram.js 35, 236
                // runHCTree_3D(sortedTarget, hctType, flipType, nowID, x, y, heatmapId, isSimilarity, axisdatamt, gapTmp)
                var sorted_avg = runHCTree_3D(0, 2, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);

                // 用 averagelinkage 順序更新 Xindices
                Xindices = sorted_avg;
            } else if (XsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 X 軸索引
                var sorted_sin = runHCTree_3D(0, 0, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);
                
                // 用 singlelinkage 順序更新 Xindices
                Xindices = sorted_sin;
            } else if (XsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 X 軸索引
                var sorted_com = runHCTree_3D(0, 1, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);
                
                // 用 completelinkage 順序更新 Xindices
                Xindices = sorted_com;
            }
             else if (XsortOrder === "r2e") {
                if(!gapX.firstRunRowTree)
                    d3.select("#windowProxforX").selectAll("#rowTree").remove();
                if(gapX.row_r2e_order.length>0)
                {
                    Xindices = gapX.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataX, gapX.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapX.row_r2e_order = sorted_r2e;
                    Xindices = sorted_r2e;

                    //$("#Xflip_side option[value='r2e']").prop("disabled",false);   
                    $("#Xflip_side option[value='r2e']").prop("disabled",false);  
                }
                
             }

            if(gapX)
            {
                for(let i=0 ;i< gapX.row_number; i++)
                {
                    gapX.rowCurrentOrder[i] = Xindices[i];
                    gapX.row_output_order_array[i] = gapX.rowCurrentOrder[i];
                }
                gapX.rowOrderId = XsortOrder;
                var windowID = "#windowProxforX";
                gapX.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapX.yd_X>0)
                    gapX.redrawHeatmap("mv11", gapX.yd_X, 0, 11, windowID); 
                gapX.redrawRowLabels(windowID);
            }

            return Xindices;

        }

        // 更改 Y 軸排序
        function updateYOrder() {
            var YsortOrder = now_sortYOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Yflip_side == "r2e")
                nowFlip = 1;
            else if(now_Yflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Yflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;

            // flip 防呆
            if (YsortOrder == "r2e" || YsortOrder == "singlelinkage" || YsortOrder == "averagelinkage" || YsortOrder == "completelinkage")
            {
                //$("#Yflip").prop("disabled",false);
                $("#Yflip_side").prop("disabled",false);
            }

            if (YsortOrder === "original_Y") {
                // 用原始順序更新 Yindices
                var originalYIndices = [...Array(uniqueY.length).keys()];

                // 用原始順序更新 Yindices
                Yindices = originalYIndices;

                if (typeof gapY !== "undefined")
                    if(!gapY.firstRunRowTree)
                        d3.select("#windowProxforY").selectAll("#rowTree").remove();

            } else if (YsortOrder === "random_Y") {
                // 產生隨機排序的 Y 軸索引
                var randomYIndices = [...Array(uniqueY.length).keys()].sort(() => Math.random() - 0.5);

                // 用隨機順序更新 Yindices
                Yindices = randomYIndices;

                if (typeof gapY !== "undefined")
                    if(!gapY.firstRunRowTree)
                        d3.select("#windowProxforY").selectAll("#rowTree").remove();
            } else if (YsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 Y 軸索引
                var sorted_avg = runHCTree_3D(1, 2, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);

                // 用 averagelinkage 順序更新 Yindices
                Yindices = sorted_avg;
            } else if (YsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 Y 軸索引
                var sorted_sin = runHCTree_3D(1, 0, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);
                
                // 用 singlelinkage 順序更新 Yindices
                Yindices = sorted_sin;
            } else if (YsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 Y 軸索引
                //function runHCTree_3D(sortedTarget, hctType, flipType, nowID, x, y, heatmapId, isSimilarity, axisdatamt) 
                var sorted_com = runHCTree_3D(1, 1, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);
                
                // 用 completelinkage 順序更新 Yindices
                Yindices = sorted_com;
            }
            else if (YsortOrder === "r2e") {
                if(!gapY.firstRunRowTree)
                    d3.select("#windowProxforY").selectAll("#rowTree").remove();
                if(gapY.row_r2e_order.length>0)
                {
                    Yindices = gapY.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataY, gapY.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapY.row_r2e_order = sorted_r2e;
                    Yindices = sorted_r2e;

                    $("#Yflip_side option[value='r2e']").prop("disabled",false);  
                }

             }


            if(gapY)
            {
                for(let i=0 ;i< gapY.row_number; i++)
                {
                    gapY.rowCurrentOrder[i] = Yindices[i];
                    gapY.row_output_order_array[i] = gapY.rowCurrentOrder[i];
                }
                gapY.rowOrderId = YsortOrder;
                var windowID = "#windowProxforY";
                gapY.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapY.yd_X>0)
                    gapY.redrawHeatmap("mv11", gapY.yd_Y, 0, 11, windowID); 
                gapY.redrawRowLabels(windowID);
            }

            return Yindices;
        } 

        // 更改 Z 軸排序
        function updateZOrder(ZsortOrder) {
            var ZsortOrder = now_sortZOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Zflip_side == "r2e")
                nowFlip = 1;
            else if(now_Zflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Zflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;
            
            // flip 防呆
            if (ZsortOrder == "r2e" || ZsortOrder == "singlelinkage" || ZsortOrder == "averagelinkage" || ZsortOrder == "completelinkage")
            {
                // $("#Xflip").prop("disabled",false);
                $("#Zflip_side").prop("disabled",false);
            }

            if (ZsortOrder === "original_Z") {
                // 用原始順序更新 Zindices
                var originalZIndices = [...Array(uniqueZ.length).keys()];

                // 用原始順序更新 Zindices
                Zindices = originalZIndices;

                if (typeof gapZ !== "undefined")
                    if(!gapZ.firstRunRowTree)
                        d3.select("#windowProxforZ").selectAll("#rowTree").remove();
            } else if (ZsortOrder === "random_Z") {
                // 產生隨機排序的 Z 軸索引
                var randomZIndices = [...Array(uniqueZ.length).keys()].sort(() => Math.random() - 0.5);

                // 用原始順序更新 Zindices
                Zindices = randomZIndices;

                if (typeof gapZ !== "undefined")
                    if(!gapZ.firstRunRowTree)
                        d3.select("#windowProxforZ").selectAll("#rowTree").remove();
            } else if (ZsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 Z 軸索引
                var sorted_avg = runHCTree_3D(2, 2, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);

                // 用 averagelinkage 順序更新 Zindices
                Zindices = sorted_avg;
            } else if (ZsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 Z 軸索引
                var sorted_sin = runHCTree_3D(2, 0, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);
                
                // 用 singlelinkage 順序更新 Zindices
                Zindices = sorted_sin;
            } else if (ZsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 Z 軸索引
                var sorted_com = runHCTree_3D(2, 1, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);
                
                // 用 completelinkage 順序更新 Zindices
                Zindices = sorted_com;
            }
            else if (ZsortOrder === "r2e") {
                if(!gapZ.firstRunRowTree)
                    d3.select("#windowProxforZ").selectAll("#rowTree").remove();
                if(gapZ.row_r2e_order.length>0)
                {
                    Zindices = gapZ.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataZ, gapZ.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapZ.row_r2e_order = sorted_r2e;
                    Zindices = sorted_r2e;

                    $("#Zflip_side option[value='r2e']").prop("disabled",false);  
                }

             }

            if(gapZ)
            {
                for(let i=0 ;i< gapZ.row_number; i++)
                {
                    gapZ.rowCurrentOrder[i] = Zindices[i];
                    gapZ.row_output_order_array[i] = gapZ.rowCurrentOrder[i];
                }
                gapZ.rowOrderId = ZsortOrder;
                var windowID = "#windowProxforZ";
                gapZ.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapZ.yd_X>0)
                    gapZ.redrawHeatmap("mv11", gapZ.yd_Y, 0, 11, windowID); 
                gapZ.redrawRowLabels(windowID);
            }

            return Zindices;
        }

        // 依據更新後的 indices 重新映射 cube 之顏色
        function applyChangesBasedOnNewIndices(displayCondition) {
            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value);
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value);
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value);

            // 取得目前選擇的欄位 value
            var valueField = document.getElementById('singleSelect').value;

            // 從 DOM 取得目前選取的 displayCondition
            var displayCondition = document.getElementById('DisplayCondition').value;

            if (displayCondition === 'RangeX') {
                for (let i = 0; i < Xindices.length; i++) {
                    let uniqueValue = uniqueX[Xindices[i]]; // 取得目前 uniqueX 類別的值
                    let minMax = minMaxByUniqueX[uniqueValue]; // 取得這個類別的最小值和最大值

                    for (let j = 0; j < Yindices.length; j++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            let cube = cubes[i][j][k]; // 取得現有的立方體
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    // 獲取當前選擇的顏色方案
                                    var currentColorScheme = document.getElementById('colorSchemeSelect').value;

                                    // 使用目前類別的最小值和最大值來對應顏色
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0; // 空值立方体保持完全透明
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;

                                // 更新立方體材料的顏色
                                cube.material.color.set(color);

                                // 儲存顏色資料值和顏色方案，即使是透明的立方體也這樣做，以便保持資訊的完整性
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;
                            }
                        }
                    }
                }
            } else if (displayCondition === 'RangeY') {
                for (let j = 0; j < Yindices.length; j++) {
                    let uniqueValue = uniqueY[Yindices[j]];
                    let minMax = minMaxByUniqueY[uniqueValue];

                    for (let i = 0; i < Xindices.length; i++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            let cube = cubes[i][j][k];
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    var currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0;
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;
                                cube.material.color.set(color);
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;
                            }
                        }
                    }
                }
            } else if (displayCondition === 'RangeZ') {
                for (let k = 0; k < Zindices.length; k++) {
                    let uniqueValue = uniqueZ[Zindices[k]];
                    let minMax = minMaxByUniqueZ[uniqueValue];

                    for (let i = 0; i < Xindices.length; i++) {
                        for (let j = 0; j < Yindices.length; j++) {
                            let cube = cubes[i][j][k];
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    var currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0;
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;
                                cube.material.color.set(color);
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;
                            }
                        }
                    }
                }
            } else {
                // 遍歷現有的 cubes 並更新顏色
                for (let i = 0; i < Xindices.length; i++) {
                    for (let j = 0; j < Yindices.length; j++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            // 在立方體已經創建的基礎上進行
                            let cube = cubes[i][j][k]; // 取得現有的立方體

                            if (cube) {
                                // 使用排序後的索引從 data_array 取得值
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                let color;

                                if (value !== null) {
                                    // 獲取當前選擇的顏色方案
                                    var currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    // 使用 mapValueToColor 函數和正規化後的值來設置立方體的顏色
                                    color = mapValueToColor(value, currentColorScheme, globalMin, globalMax);

                                    // 使用全域透明度變數
                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0; // 空值立方體保持完全透明
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;

                                // 更新立方體材料的顏色
                                cube.material.color.set(color);

                                // 儲存顏色資料值和顏色方案，即使是透明的立方體也這樣做，以便保持資訊的完整性
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;

                                cube.userData.tooltipText = fieldX + "：" + uniqueX[Xindices[i]] + "<br>" +
                                    fieldY + "：" + uniqueY[Yindices[j]] + "<br>" +
                                    fieldZ + "：" + uniqueZ[Zindices[k]] + "<br>" +
                                    valueField + "：" + value; // 存儲懸浮提示文本

                                cube.material.transparent = true;
                                cube.material.needsUpdate = true; // 確保 Three.js 知道需要更新材料
                            }
                        }
                    }
                }
                // 排序後，根據滑動條當前值重新設定顏色
                updateCubeColorsBasedOnSlider(globalSliderMin, globalSliderMax);
            }

            // 在立方體創建後更新 colorbar
            updateColorbar(currentColorScheme, globalMin, globalMax);
        }

        // 為 display Condition 下拉式選單新增事件監聽器
        document.getElementById('DisplayCondition').addEventListener('change', function() {
            // // 清除 bar chart 設定
            // clearbar();

            // 重置滑動條到初始位置
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示
            var handles = $("#double-slider .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            applyChangesBasedOnNewIndices();
        });

        // 為 X 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortXOrderSelect').addEventListener('change', function() {
            var previousOrderIsR2E = false;
            if(now_sortXOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortXOrderSelect = this.value;

            if (now_sortXOrderSelect == "singlelinkage" || now_sortXOrderSelect == "averagelinkage" || now_sortXOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Xflip_side").prop('selectedIndex', 1);
                    now_Xflip_side = "r2e";
                }
            }
            else if(now_sortXOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Xflip_side").prop('selectedIndex', 0); 
                now_Xflip_side = "null";
            }
            else if(now_sortXOrderSelect == "original_X")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Xflip_side").prop('selectedIndex', 0); 
                now_Xflip_side = "null";
            }
        
            updateXOrder();
            applyChangesBasedOnNewIndices();

            
            let chartDataX= calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            //console.log(chartDataX);
            updateBarChart('chartX', chartDataX, 'X');
            
            // reset cube and bar chart
            clearbar();
        });

        // 為 Y 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortYOrderSelect').addEventListener('change', function() {

            var previousOrderIsR2E = false;
            if(now_sortYOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortYOrderSelect = this.value;

            if (now_sortYOrderSelect == "singlelinkage" || now_sortYOrderSelect == "averagelinkage" || now_sortYOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Yflip_side").prop('selectedIndex', 1);
                    now_Yflip_side = "r2e";
                }
            }
            else if(now_sortYOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Yflip_side").prop('selectedIndex', 0); 
                now_Yflip_side = "null";
            }
            else if(now_sortYOrderSelect == "original_Y")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Yflip_side").prop('selectedIndex', 0); 
                now_Yflip_side = "null";
            }

            updateYOrder();
            applyChangesBasedOnNewIndices();

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            // console.log(Yindices);
            // console.log(chartDataY);
            updateBarChart('chartY', chartDataY, 'Y');

            // reset cube and bar chart
            clearbar();
        });

        // 為 Z 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortZOrderSelect').addEventListener('change', function() {
            var previousOrderIsR2E = false;
            if(now_sortZOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortZOrderSelect = this.value;

            if (now_sortZOrderSelect == "singlelinkage" || now_sortZOrderSelect == "averagelinkage" || now_sortZOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Zflip_side").prop('selectedIndex', 1);
                    now_Zflip_side = "r2e";
                }
            }
            else if(now_sortZOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Zflip_side").prop('selectedIndex', 0); 
                now_Zflip_side = "null";
            }
            else if(now_sortZOrderSelect == "original_Z")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Zflip_side").prop('selectedIndex', 0); 
                now_Zflip_side = "null";
            }
            updateZOrder();
            applyChangesBasedOnNewIndices();

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            // console.log(Zindices);
            // console.log(chartDataZ.results_name);
            // console.log(chartDataZ.results_value);
            updateBarChart('chartZ', chartDataZ, 'Z');

            // reset cube and bar chart
            clearbar();
        });

        // 為 X 軸flip下拉式選單新增事件監聽器
        document.getElementById('Xflip_side').addEventListener('change', function() {
            now_Xflip_side = this.value;
            updateXOrder();
            applyChangesBasedOnNewIndices();

            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            updateBarChart('chartX', chartDataX, 'X');
        });

        // 為 Y 軸flip下拉式選單新增事件監聽器
        document.getElementById('Yflip_side').addEventListener('change', function() {
            now_Yflip_side = this.value;
            updateYOrder();
            applyChangesBasedOnNewIndices();

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            updateBarChart('chartY', chartDataY, 'Y');
        });

        // 為 Z 軸flip下拉式選單新增事件監聽器
        document.getElementById('Zflip_side').addEventListener('change', function() {
            now_Zflip_side = this.value;
            updateZOrder();
            applyChangesBasedOnNewIndices();

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            updateBarChart('chartZ', chartDataZ, 'Z');
        });

        // 創建一個 Raycaster 物件 (在 Three.js 中 Raycaster 用於計算和偵測射線與場景中物體的相交情況)
        var raycaster = new THREE.Raycaster();

        // 創建一個二維向量 mouse 用來儲存滑鼠在螢幕上的位置
        var mouse = new THREE.Vector2();

        // 監聽滑鼠移動事件 當滑鼠在頁面上移動時，呼叫名為 onMouseMove 的函數
        document.addEventListener('mousemove', onMouseMove, false);

        // 接收一個 event 參數 其中包含了事件的詳細訊息，如：滑鼠的螢幕座標
        function onMouseMove(event) {
            // 將滑鼠位置轉換為歸一化裝置座標 (NDC)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // 更新射線的起點與方向
            raycaster.setFromCamera(mouse, camera);

            // 射線與物件的交點
            var intersects = raycaster.intersectObjects(cubes.flat().flat(), true);

            // 顯示懸浮提示
            showTooltip(event, intersects);

            // 更新軸線的起點
            updateAxesStartPoint();
        }

        // 依不同軸線之中心點判斷其 Direction
        function updateAxesDirectionBasedOnVertex(closestVertex) {
            // 計算原始軸線之中心點
            var halfSizeX = numX * cubeSizeX / 2;
            var halfSizeY = numY * cubeSizeY / 2;
            var halfSizeZ = numZ * cubeSizeZ / 2;
            var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);

            // 基於最接近的頂點調整軸線的方向
            var directionX = new THREE.Vector3(1, 0, 0); // X 軸方向
            var directionY = new THREE.Vector3(0, 1, 0); // Y 軸方向
            var directionZ = new THREE.Vector3(0, 0, 1); // Z 軸方向

            // 如果頂點的 X Y Z 座標不等於中心的 X Y Z 座標 翻轉該軸方向
            if (closestVertex.x !== center.x) {
                directionX.negate(); // 翻轉 X 軸方向
            }
            if (closestVertex.y !== center.y) {
                directionY.negate(); // 翻轉 Y 軸方向
            }
            if (closestVertex.z !== center.z) {
                directionZ.negate(); // 翻轉 Z 軸方向
            }

            return [directionX, directionY, directionZ];
        }

        // 清除現有的軸線
        function clearAxesLines() {
            var axes = ['axisX', 'axisY', 'axisZ'];
            axes.forEach(function(axisName) {
                var existingAxis = scene.getObjectByName(axisName);
                if (existingAxis) {
                    scene.remove(existingAxis);
                }
            });
        }

        // 依照鼠標更新軸線之中心點
        function updateAxesStartPoint() {
            if (!updateAxes) return; // 如果 updateAxes 為 false 則不執行更新

            // 獲取 Checkbox 的狀態
            var tooltipEnabled = document.getElementById('tooltipCheckbox').checked;

            // 如果 Checkbox 未被勾選 則清除現有軸線並退出函數
            if (!tooltipEnabled) {
                clearAxesLines();
                return;
            }

            // 更新 raycaster
            raycaster.setFromCamera(mouse, camera);

            // 欲偵測之物件存放在一陣列中，例如：所有立方體
            var intersects = raycaster.intersectObjects(cubes.flat().flat(), true);

            if (intersects.length > 0) {
                var intersect = intersects[0]; // 取第一個交點對象
                var intersectObject = intersect.object; // 取得實際相交的對象

                intersectObject.geometry.computeBoundingBox();

                // 計算大立方體的所有頂點
                var bbox = intersectObject.geometry.boundingBox;

                var vertices = [
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z),
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.max.z),
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.min.z),
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.max.z),
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.min.z),
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.max.z),
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.min.z),
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.max.z)
                ].map(vertex => vertex.applyMatrix4(intersectObject.matrixWorld)); // 轉換到世界座標

                // 找出最接近交點的頂點
                closestVertex = vertices.reduce((closest, vertex) => {
                    return vertex.distanceTo(intersect.point) < closest.distanceTo(intersect.point) ? vertex : closest;
                }, vertices[0]);

                // 計算原始軸線之中心點
                var halfSizeX = numX * cubeSizeX / 2;
                var halfSizeY = numY * cubeSizeY / 2;
                var halfSizeZ = numZ * cubeSizeZ / 2;
                var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);

                // 計算新的中心點與原始中心點之間的差
                var difference = new THREE.Vector3().subVectors(closestVertex, center);

                var axisLengthX = Math.abs(difference.x);
                var axisLengthY = Math.abs(difference.y);
                var axisLengthZ = Math.abs(difference.z);
                
                // 使用更新後之 Direction
                var [directionX, directionY, directionZ] = updateAxesDirectionBasedOnVertex(closestVertex);

                var axesInfo = [
                    { color: "#0f0f0f", direction: directionX, length: axisLengthX, name: 'axisX' },
                    { color: "#0f0f0f", direction: directionY, length: axisLengthY, name: 'axisY' },
                    { color: "#0f0f0f", direction: directionZ, length: axisLengthZ, name: 'axisZ' }
                ];

                axesInfo.forEach(function(info) {
                    var points = [closestVertex.clone()];
                    var end = closestVertex.clone().addScaledVector(info.direction, info.length);
                    points.push(end);

                    var geometry = new THREE.BufferGeometry().setFromPoints(points);
                    var material = new THREE.LineBasicMaterial({ color: info.color });
                    var axis = new THREE.Line(geometry, material);
                    axis.name = info.name;

                    var existingAxis = scene.getObjectByName(info.name);
                    if (existingAxis) {
                        scene.remove(existingAxis);
                    }

                    scene.add(axis);
                });
            }
        }

        // 添加軸線 (所有邊)
        function createOrUpdateAxes(numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ) {
            // 取得目前選取的軸
            var selectedAxis = document.querySelector('input[name="axis"]:checked').value;

            // 根據選取的軸 (slices 的 ratio) 設定 邊界中心點到立方體中心的距離
            var halfSizeX = selectedAxis === 'X' ? numX * (cubeSizeX * sliceGap) / 2 : numX * cubeSizeX / 2;
            var halfSizeY = selectedAxis === 'Y' ? numY * (cubeSizeY * sliceGap) / 2 : numY * cubeSizeY / 2;
            var halfSizeZ = selectedAxis === 'Z' ? numZ * (cubeSizeZ * sliceGap) / 2 : numZ * cubeSizeZ / 2;

            // 根據選取的軸 (slices 的 ratio) 計算每個方向上軸線的長度 (根據 cube 之各邊長度)
            var axisLengthX = selectedAxis === 'X' ? numX * (cubeSizeX * sliceGap) + .05 : numX * cubeSizeX + .05;
            var axisLengthY = selectedAxis === 'Y' ? numY * (cubeSizeY * sliceGap) + .05 : numY * cubeSizeY + .05;
            var axisLengthZ = selectedAxis === 'Z' ? numZ * (cubeSizeZ * sliceGap) + .05 : numZ * cubeSizeZ + .05;
            
            // 定義所有 12 個邊的起點與方向
            var edgesInfo = [
                // 四條 X 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX1' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX2' },
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX3' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX4' },

                // 四條 Y 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY1' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY2' },
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY3' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY4' },

                // 四條 Z 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ1' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ2' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ3' },
                { start: new THREE.Vector3(halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ4' },
            ];

            edgesInfo.forEach(function(edge) {
                var material = new THREE.LineBasicMaterial({ color: "#5C5C5C" });
                var points = [edge.start, new THREE.Vector3().addVectors(edge.start, edge.direction.multiplyScalar(edge.length))];
                var geometry = new THREE.BufferGeometry().setFromPoints(points);
                var axisLine = new THREE.Line(geometry, material);

                // 移除舊的軸線
                var existingEdge = scene.getObjectByName(edge.name);
                if (existingEdge) {
                    scene.remove(existingEdge);
                }

                axisLine.name = edge.name; // 使用唯一的名稱
                scene.add(axisLine);
            });
        }

        // 更新懸浮提示
        function showTooltip(event, intersects) {
            var tooltip = document.getElementById('tooltip');

            // 獲取 Checkbox 的狀態
            var tooltipEnabled = document.getElementById('tooltipCheckbox').checked;

            if (!tooltipEnabled) {
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
                return; // 如果 Checkbox 未被勾選 則不顯示懸浮提示並退出函數
            }

            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.setAttribute('id', 'tooltip');
                document.body.appendChild(tooltip);
                // 設置基本樣式
                tooltip.style.position = 'absolute';
                tooltip.style.display = 'none';
                tooltip.style.background = '#fff';
                tooltip.style.border = '1px solid #ddd';
                tooltip.style.padding = '5px';
                tooltip.style.fontSize = '12px';
                tooltip.style.pointerEvents = 'none'; // 確保懸浮提示不會干擾射線檢測
                tooltip.style.background.size = 'cover';
            }

            if (intersects.length > 0) {
                var intersect = intersects[0]; // 取得最近的交點對象
                if (intersect.object.userData.tooltipText) {
                    tooltip.innerHTML = intersect.object.userData.tooltipText;
                    tooltip.style.left = (event.clientX + 15) + 'px'; // 滑鼠右側 15 像素處顯示懸浮提示
                    tooltip.style.top = (event.clientY + 15) + 'px'; // 滑鼠下方 15 像素處顯示懸浮提示
                    tooltip.style.display = 'block';
                } else {
                    tooltip.style.display = 'none';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        // 添加軸標籤
        function createAxisLabel(text, position, size, axisLabelName) {
            var canvas = document.createElement('canvas'); // 創建一個新的 HTML <canvas> 元素，它可以用來繪製圖形和文本
            
            var context = canvas.getContext('2d'); // 獲取該 <canvas> 元素的 2D 繪圖上下文，這是一個用於在 <canvas> 上繪製的對象
            var fontSize = 48; // 根據需要調整字體大小
            context.font = `${fontSize}px Arial`; // 設定字體大小為 fontSize 像素，並且選擇字體樣式為 Arial
            context.fillStyle = 'rgba(92, 92, 92, 1.0)'; // 文字顏色：深灰色 (完全不透明) #5C5C5C

            // 計算文本寬度並根據此來設定 canvas 寬度
            var textWidth = context.measureText(text).width;
            canvas.width = 1000; // 設定固定的 canvas 寬度
            canvas.height = fontSize * 2; // 高度足夠容納文本
            context.textAlign = 'center'; // 將文本對齊方式：'center' 'right'
            context.fillText(text, canvas.width / 2, canvas.height / 2 + fontSize / 2); // 在 <canvas> 上繪製實心的文本

            // 從剛才繪製的 <canvas> 創建一個新的 Three.js 材質的貼圖 (texture)，這將允許將文本貼在 3D 對象上
            var texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.needsUpdate = true;

            // 創建一個 SpriteMaterial 它是一種用於創建具有純色或貼圖的矩形平面的材質
            var material = new THREE.SpriteMaterial({
                map: texture,
                depthTest: false // 添加這個屬性禁用深度測試
            });

            var sprite = new THREE.Sprite(material); // 使用該材質來創建一個 THREE.Sprite 它是一種始終面向攝像機的對象 常用於顯示貼圖
            sprite.position.copy(position); // 將 sprite 的位置設定為傳入的 position 這個位置是該標籤在 3D 場景中的位置
            sprite.scale.set(size * canvas.width / canvas.height, size, 1); // 調整標籤尺寸 (使用 size 參數和 <canvas> 的寬高比例來確保文本保持正確的比例和大小)
            sprite.name = axisLabelName; // 為軸標籤設定一個唯一的名稱

            scene.add(sprite);
        }

        // 移除軸標籤 (可只移除一個軸)
        function removeAxisLabels(axis) {
            var removableObjects = [];
            scene.traverse((object) => {
                // 如果沒有指定軸，就檢查名稱是否以 "axisLabel" 開頭
                // 如果指定了軸，就檢查名稱是否以 "axisLabel" + 軸 的形式開頭
                if (object.name && (axis ? object.name.startsWith('axisLabel' + axis) : object.name.startsWith('axisLabel'))) {
                    removableObjects.push(object);
                }
            });
            removableObjects.forEach((object) => {
                scene.remove(object);
            });
        }

        // 根據視角更新軸標籤位置
        function updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ) {
            removeAxisLabels(); // 移除所有現有的軸標籤

            var selectedAxis = document.querySelector('input[name="axis"]:checked').value;

            // 更新 X 軸標籤
            Xindices.forEach((index, i) => {
                let category = uniqueX[index];
                var positionX = selectedAxis === 'X' ? -numX * (cubeSizeX * sliceGap) / 2 + (i * (cubeSizeX * sliceGap)) + ((cubeSizeX * sliceGap) / 2)
                                            : -numX * cubeSizeX / 2 + (i * cubeSizeX) + (cubeSizeX / 2);
                var position = new THREE.Vector3(positionX, -numY * cubeSizeY  / 2 + gapbwaxisandlabel, -numZ * cubeSizeZ / 2 - gapbwaxisandlabel);
                if (closestVertex_camera) { // 如果 closestVertex_camera 已定義 則根據相機位置調整
                    position.y = selectedAxis === 'Y' ? (closestVertex_camera.y > 0 ? 1 : -1) * (numY * (cubeSizeY * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.y > 0 ? 1 : -1) * (numY * cubeSizeY / 2 + gapbwaxisandlabel);
                    position.z = selectedAxis === 'Z' ? (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * (cubeSizeZ  * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * cubeSizeZ / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeX, 'axisLabelX' + index);
            });

            // 更新 Y 軸標籤
            Yindices.forEach((index, i) => {
                let category = uniqueY[index];
                var positionY = selectedAxis === 'Y' ? -numY * (cubeSizeY * sliceGap) / 2 + (i * (cubeSizeY * sliceGap)) + ((cubeSizeY * sliceGap) / 2 + .2)
                                            : -numY * cubeSizeY / 2 + (i * cubeSizeY) + (cubeSizeY / 2 + .2);
                var position = new THREE.Vector3(-numX * cubeSizeX / 2 - gapbwaxisandlabel, positionY, -numZ * cubeSizeZ / 2);
                if (closestVertex_camera) {
                    position.x = selectedAxis === 'X' ? (closestVertex_camera.x > 0 ? 1 : -1) * (numX * (cubeSizeX * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.x > 0 ? 1 : -1) * (numX * cubeSizeX / 2 + gapbwaxisandlabel);
                    position.z = selectedAxis === 'Z' ? (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * (cubeSizeZ * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * cubeSizeZ / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeY, 'axisLabelY' + index);
            });

            // 更新 Z 軸標籤
            Zindices.forEach((index, i) => {
                let category = uniqueZ[index];
                var positionZ = selectedAxis === 'Z' ? -numZ * (cubeSizeZ * sliceGap) / 2 + (i * (cubeSizeZ * sliceGap)) + ((cubeSizeZ * sliceGap) / 2)
                                            : -numZ * cubeSizeZ / 2 + (i * cubeSizeZ) + (cubeSizeZ / 2);
                var position = new THREE.Vector3(-numX * cubeSizeX / 2 - gapbwaxisandlabel, -numY * cubeSizeY / 2 + gapbwaxisandlabel, positionZ);
                if (closestVertex_camera) {
                    position.x = selectedAxis === 'X' ? (closestVertex_camera.x > 0 ? 1 : -1) * (numX * (cubeSizeX * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.x > 0 ? 1 : -1) * (numX * cubeSizeX / 2 + gapbwaxisandlabel);
                    position.y = selectedAxis === 'Y' ? (closestVertex_camera.y > 0 ? 1 : -1) * (numY * (cubeSizeY * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.y > 0 ? 1 : -1) * (numY * cubeSizeY / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeZ, 'axisLabelZ' + index);
            });
        }

        // 清除現有的軸線 (for camera)
        function clearAxesLines_forcamera() {
            var axes = ['axisX_forcamera', 'axisY_forcamera', 'axisZ_forcamera'];
            axes.forEach(function(axisName) {
                var existingAxis = scene.getObjectByName(axisName);
                if (existingAxis) {
                    scene.remove(existingAxis);
                }
            });
        }

        // 根據視角更新軸線與軸標籤
        function updateAxesAndLabelByCamera() {
            // 計算立方體中心點
            var halfSizeX = numX * cubeSizeX / 2;
            var halfSizeY = numY * cubeSizeY / 2;
            var halfSizeZ = numZ * cubeSizeZ / 2;
            var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);
            
            // 計算立方體的 8 個頂點
            var vertices = [
                new THREE.Vector3(center.x, center.y, center.z),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y, center.z),
                new THREE.Vector3(center.x, center.y + numY * cubeSizeY, center.z),
                new THREE.Vector3(center.x, center.y, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y + numY * cubeSizeY, center.z),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x, center.y + numY * cubeSizeY, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y + numY * cubeSizeY, center.z + numZ * cubeSizeZ),
            ];

            // 找出最接近相機的頂點
            var closestVertex_camera;
            var minDistance = Infinity;
            var cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition); // 取得相機的世界位置

            vertices.forEach((vertex) => {
                var distance = vertex.distanceTo(cameraPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestVertex_camera = vertex;
                }
            });

            // if (updateAxes) {
            //     var axisLengthX = numX * cubeSizeX;
            //     var axisLengthY = numY * cubeSizeY;
            //     var axisLengthZ = numZ * cubeSizeZ;

            //     // 使用更新後之 Direction
            //     var [directionX, directionY, directionZ] = updateAxesDirectionBasedOnVertex(closestVertex_camera);

            //     var axesInfo = [
            //         { color: "#5C5C5C", direction: directionX, length: axisLengthX, name: 'axisX_forcamera' },
            //         { color: "#5C5C5C", direction: directionY, length: axisLengthY, name: 'axisY_forcamera' },
            //         { color: "#5C5C5C", direction: directionZ, length: axisLengthZ, name: 'axisZ_forcamera' }
            //     ];

            //     axesInfo.forEach(function(info) {
            //         var points = [closestVertex_camera.clone()];
            //         var end = closestVertex_camera.clone().addScaledVector(info.direction, info.length);
            //         points.push(end);

            //         var geometry = new THREE.BufferGeometry().setFromPoints(points);
            //         var material = new THREE.LineBasicMaterial({ color: info.color });
            //         var axis = new THREE.Line(geometry, material);
            //         axis.name = info.name;

            //         var existingAxis = scene.getObjectByName(info.name);
            //         if (existingAxis) {
            //             scene.remove(existingAxis);
            //         }

            //         scene.add(axis);
            //     });
            // }
            updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ);
        }

        // 生成二維 array (X * (Y * Z)、Y * (X * Z)、Z * (X * Y))
        function convert3DArrayTo2D(axis) {
            let result = []; // 最終的二維 array

            if (axis === 'X') {
                // 遍歷 X 軸
                for (let i = 0; i < data_array.length; i++) {
                    let row = []; // 用於儲存目前i下之所有 Y * Z 合併後的資料

                    // 遍歷 Y 軸
                    for (let j = 0; j < data_array[i].length; j++) {
                        
                        // 遍歷 Z 軸
                        for (let k = 0; k < data_array[i][j].length; k++) {
                            row.push(data_array[i][j][k]); // 將 Y 軸和 Z 軸的資料加入 array 中
                        }
                    }
                    result.push(row); // 將目前 array 新增至結果 array 中
                }
            } else if (axis === 'Y') {
                // 遍歷 Y 軸
                for (let j = 0; j < data_array[0].length; j++) {
                    let row = [];

                    // 遍歷 X 軸
                    for (let i = 0; i < data_array.length; i++) {
                        
                        // 遍歷 Z 軸
                        for (let k = 0; k < data_array[i][j].length; k++) {
                            row.push(data_array[i][j][k]);
                        }
                    }

                    result.push(row);
                }
            } else if (axis === 'Z') {
                // 遍歷 Z 軸
                for (let k = 0; k < data_array[0][0].length; k++) {
                    let row = [];

                    // 遍歷 X 軸
                    for (let i = 0; i < data_array.length; i++) {
                        
                        // 遍歷 Y 軸
                        for (let j = 0; j < data_array[i].length; j++) {
                            row.push(data_array[i][j][k]);
                        }
                    }

                    result.push(row);
                }
            }
            return result;
        }

        // 為 proxi MT X 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxX').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 0);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                // 設置浮動視窗標題
                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforXproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforXproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `${this.value} of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }

            for(let i = 0; i < numX; i++) {
                for(let j = 0; j < numX; j++) {
                    rowProxDataX[i][j] = rowProxData1D[i*numX+j];
                }
            }

            if (d3.select("#"+windowID).empty()) {

                gapX = new GAP();
                // 取得 RowProx 二維陣列資料
                gapX.rowProxData = rowProxDataX;

                // 設定 row_number
                gapX.row_number = numX;

                gapX.row_Scale_id = row_Scale_id;

                gapX.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapX.row_number; i++) {
                    gapX.rowCurrentOrder[i] = Xindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerX = document.createElement('div');
                //svgContainerX.innerHTML = '<div id="${windowID}" class="row" style="width: 500px; height: 500px;></div>';

                // 呼叫 createFloatingWindow 來創建浮動視窗
                createFloatingWindow(windowID, title, svgContainerX, 396, 110, 350, 350);

                // 呼叫 funtion 在 windowID 下建立 svg
                gapX.setupProximityData(`#${windowID}_svg`);

                // 畫出 Row Proximity 矩陣圖
                gapX.setupHeatmap2(gapX.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapX.row_name = uniqueX;
                gapX.setupProxLabel(`#${windowID}`);
                gapX.isRowProxfirst = false;
                gapX.rowIsSimilarity = rowIsSimilarity;

                // let ArrayYZ = convert3DArrayTo2D('X');
                // console.log(ArrayYZ);
                // 輸出成 txt
                // exportArrayToTxt(ArrayYZ, 'ArrayYZ.txt');
            }
            else
            {
                //for(let i=0 ;i< gapX.row_number; i++)
                    //gapX.rowCurrentOrder[i] = i;
                //gapX.rowOrderId == "sortinit_row";
                //if(gapX)
                //gapX.redrawHeatmap("mv2", 0, 0, 1, `#${windowID}`);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                //gapX.redrawHeatmap("mv11", gap2.yd_X, 0, 11, "#heatmap2");
            }

            // order 防呆
            // $("#sortXOrderSelect").prop("disabled",false);
            $("#sortXOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // 為 proxi MT Y 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxY').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 1);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                // 設置浮動視窗標題
                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforYproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;v

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforYproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `${this.value} of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }

            for(let i = 0; i < numY; i++) {
                for(let j = 0; j < numY; j++) {
                    rowProxDataY[i][j] = rowProxData1D[i*numY+j];
                }
            }

            if (d3.select("#"+windowID).empty()) {
                gapY = new GAP();
                // 取得 RowProx 二維陣列資料
                gapY.rowProxData = rowProxDataY;

                // 設定 row_number
                gapY.row_number = numY;

                gapY.row_Scale_id = row_Scale_id;

                gapY.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapY.row_number; i++) {
                    gapY.rowCurrentOrder[i] = Yindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerY = document.createElement('div');
                //svgContainerY.innerHTML = '<div id="${windowID}" class="row" style="width: 500px; height: 500px;></div>';

                // 呼叫 createFloatingWindow 來創建浮動視窗
                createFloatingWindow(windowID, title, svgContainerY, 396, 340, 350, 350);

                // 呼叫 funtion 在 windowID 下建立 svg
                gapY.setupProximityData(`#${windowID}_svg`);

                // 設定色階
                //var colorID = d3.interpolateSpectral;

                // 畫出 Row Proximity 矩陣圖
                gapY.setupHeatmap2(gapY.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapY.row_name = uniqueY;
                gapY.setupProxLabel(`#${windowID}`);
                gapY.isRowProxfirst = false;
                gapY.rowIsSimilarity = rowIsSimilarity;

                // let ArrayXZ = convert3DArrayTo2D('Y');
                // console.log(ArrayXZ);
                // exportArrayToTxt(ArrayXZ, 'ArrayXZ.txt');
            }
            else
            {

            }

            // order 防呆
            // $("#sortYOrderSelect").prop("disabled",false);
            $("#sortYOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // 為 proxi MT Z 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxZ').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 2);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                // 設置浮動視窗標題
                var title = `${this.value} of Z-axis`;

                var colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforZproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                $("#colorforZproximity option[value='GAP_Rainbow']").attr('selected','selected');
                var rowIsSimilarity = false;
                var row_Scale_id = 3;
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 0);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `${this.value} of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                var rowIsSimilarity = true;
                var row_Scale_id = 1;
            }

            for(let i = 0; i < numZ; i++) {
                for(let j = 0; j < numZ; j++) {
                    rowProxDataZ[i][j] = rowProxData1D[i*numZ+j];
                }
            }

            if (d3.select("#"+windowID).empty()) {
                gapZ = new GAP();
                // 取得 RowProx 二維陣列資料
                gapZ.rowProxData = rowProxDataZ;

                // 設定 row_number
                gapZ.row_number = numZ;

                gapZ.row_Scale_id = row_Scale_id;

                gapZ.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapZ.row_number; i++) {
                    gapZ.rowCurrentOrder[i] = Zindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerZ = document.createElement('div');
                //svgContainerZ.innerHTML = '<div id="${windowID}_svg" class="row" style="width: 100%; height: 100%;></div>';

                // 呼叫 createFloatingWindow 來創建浮動視窗
                createFloatingWindow(windowID, title, svgContainerZ, 396, 570, 350, 350);

                // 呼叫 funtion 在 windowID 下建立 svg
                gapZ.setupProximityData(`#${windowID}_svg`);

                // 設定色階
                //var colorID = d3.interpolateSpectral;

                // 畫出 Row Proximity 矩陣圖
                gapZ.setupHeatmap2(gapZ.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapZ.row_name = uniqueZ;
                gapZ.setupProxLabel(`#${windowID}`);
                gapZ.isRowProxfirst = false;
                gapZ.rowIsSimilarity = rowIsSimilarity;

                // let ArrayXY = convert3DArrayTo2D('Z');
                // console.log(ArrayXY);
                // exportArrayToTxt(ArrayXY, 'ArrayXY.txt');
            }
            else
            {

            }
            // order 防呆
            // $("#sortZOrderSelect").prop("disabled",false);
            $("#sortZOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // 建立浮動視窗
        // function createFloatingWindow(windowId, title, contentElement, left, top, width, height) {
        //     // 建立浮動視窗元素
        //     const floatWindow = document.createElement('div');
        //     floatWindow.classList.add('floating-window');
        //     floatWindow.id = windowId;

        //     // 設定樣式
        //     floatWindow.style.position = 'absolute';
        //     floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
        //     floatWindow.style.top = top + 'px'; // 使用傳入的 top
        //     floatWindow.style.width = width + 'px'; // 設置初始寬度
        //     floatWindow.style.height = height + 'px'; // 設置初始高度

        //     // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
        //     const header = document.createElement('div');
        //     header.classList.add('window-header');
        //     header.style.display = 'flex';
        //     header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
        //     header.style.alignItems = 'center'; // 垂直居中對齊

        //     // 建立標題元素
        //     const titleElement = document.createElement('span');
        //     titleElement.textContent = title;
        //     header.appendChild(titleElement);

        //     const content = document.createElement('div');
        //     content.style.width = '100%';
        //     content.style.height = '100%';
        //     content.id = windowId+"_svg";

        //     // 建立關閉按鈕
        //     const closeButton = document.createElement('span');
        //     closeButton.textContent = '×';
        //     closeButton.classList.add('close');
        //     closeButton.onclick = function() {
        //         floatWindow.remove();
        //     };
        //     header.appendChild(closeButton);
        //     header.onmousedown = function(event) {
        //         startDrag(event, windowId);
        //     };

        //     // 將頭部添加到浮動窗口
        //     floatWindow.appendChild(header);

        //     // 將提供的內容新增到浮動視窗中
        //     //floatWindow.appendChild(contentElement);
        //     floatWindow.appendChild(content);

        //     // 組裝視窗並顯示
        //     document.getElementById('floatingWindowContainer').appendChild(floatWindow);
        //     floatWindow.style.display = 'block';

        //     // 設定視窗的初始 z-index
        //     floatWindow.style.zIndex = highestZIndex++;

        //     // 新增點擊事件監聽器來調整 z-index
        //     floatWindow.addEventListener('click', function() {
        //         this.style.zIndex = ++highestZIndex;
        //     });
        // }

        // 建立浮動視窗
        function createFloatingWindow(windowId, title, contentElement, left, top, width, height) {
            // 建立浮動視窗元素
            const floatWindow = document.createElement('div');
            floatWindow.classList.add('floating-window');
            floatWindow.id = windowId;

            // 設定樣式
            floatWindow.style.position = 'absolute';
            floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
            floatWindow.style.top = top + 'px'; // 使用傳入的 top
            floatWindow.style.width = width + 'px'; // 設置初始寬度
            floatWindow.style.height = height + 'px'; // 設置初始高度

            // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
            const header = document.createElement('div');
            header.classList.add('window-header');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
            header.style.alignItems = 'center'; // 垂直居中對齊

            // 建立標題元素
            const titleElement = document.createElement('span');
            titleElement.textContent = title;
            header.appendChild(titleElement);

            const content = document.createElement('div');
            content.style.width = '100%';
            content.style.height = '100%';
            content.id = windowId+"_svg";

            // 建立最小化/還原按鈕
            const toggleButton = document.createElement('span');
            toggleButton.textContent = '–'; // 使用減號表示最小化
            toggleButton.classList.add('toggle');
            toggleButton.style.fontSize = '24px'; // 增大字體大小
            toggleButton.style.cursor = 'pointer'; // 滑鼠懸停時顯示手形圖標
            toggleButton.style.marginLeft = 'auto'; // 將按鈕推到右邊
            toggleButton.style.marginRight = '8px'; // 調整按鈕之間的間距
            toggleButton.onclick = function() {
                if (floatWindow.classList.contains('minimized')) {
                    // 如果已經是最小化狀態，還原視窗
                    floatWindow.style.height = floatWindow.dataset.originalHeight;
                    contentElement.style.display = 'block'; // 再次顯示內容
                    floatWindow.classList.remove('minimized');
                    toggleButton.textContent = '–'; // 切換回最小化按鈕
                } else {
                    // 最小化視窗
                    floatWindow.dataset.originalHeight = floatWindow.style.height; // 儲存原始高度
                    floatWindow.style.height = header.offsetHeight + 'px'; // 設定高度為頭部高度
                    contentElement.style.display = 'none'; // 隱藏內容
                    floatWindow.classList.add('minimized');
                    toggleButton.textContent = ' + '; // 切換為還原按鈕
                }
            };
            header.appendChild(toggleButton);

            // 建立關閉按鈕
            const closeButton = document.createElement('span');
            closeButton.textContent = '×';
            closeButton.classList.add('close');
            // closeButton.style.marginLeft = '10px'; // 給關閉按鈕一點左邊距
            closeButton.onclick = function() {
                floatWindow.remove();
            };
            header.appendChild(closeButton);

            // 設置拖移事件
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 將頭部添加到浮動窗口
            floatWindow.appendChild(header);

            // 將提供的內容新增到浮動視窗中
            floatWindow.appendChild(content);

            // 組裝視窗並顯示
            document.getElementById('floatingWindowContainer').appendChild(floatWindow);
            floatWindow.style.display = 'block';

            // 設定視窗的初始 z-index
            floatWindow.style.zIndex = highestZIndex++;

            // 新增點擊事件監聽器來調整 z-index
            floatWindow.addEventListener('click', function() {
                this.style.zIndex = ++highestZIndex;
            });
        }


        function createFloatingWindow_forchart(windowId, title, contentElement, left, top, width, height) {
            // 建立浮動視窗元素
            const floatWindow = document.createElement('div');
            floatWindow.classList.add('floating-window');
            floatWindow.id = windowId;

            // 設定樣式
            floatWindow.style.position = 'absolute';
            floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
            floatWindow.style.top = top + 'px'; // 使用傳入的 top
            floatWindow.style.width = width + 'px'; // 設置初始寬度
            floatWindow.style.height = height + 'px'; // 設置初始高度

            // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
            const header = document.createElement('div');
            header.classList.add('window-header');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
            header.style.alignItems = 'center'; // 垂直居中對齊

            // 建立標題元素
            const titleElement = document.createElement('span');
            titleElement.textContent = title;
            header.appendChild(titleElement);

            // 最小化/還原按鈕
            const toggleButton = document.createElement('span');
            toggleButton.textContent = '–'; // 使用減號表示最小化
            toggleButton.classList.add('toggle');
            toggleButton.style.fontSize = '24px'; // 增大字體大小
            toggleButton.style.marginLeft = 'auto'; // 將按鈕推到右邊
            toggleButton.style.cursor = 'pointer'; // 滑鼠懸停時顯示手形圖標
            toggleButton.onclick = function() {
                if (floatWindow.classList.contains('minimized')) {
                    // 如果已經是最小化狀態，還原視窗
                    floatWindow.style.height = floatWindow.dataset.originalHeight;
                    contentElement.style.display = 'block'; // 再次顯示內容
                    floatWindow.classList.remove('minimized');
                    toggleButton.textContent = '–'; // 切換回最小化按鈕
                } else {
                    // 最小化視窗
                    floatWindow.dataset.originalHeight = floatWindow.style.height; // 儲存原始高度
                    floatWindow.style.height = header.offsetHeight + 'px'; // 設定高度為頭部高度
                    contentElement.style.display = 'none'; // 隱藏內容
                    floatWindow.classList.add('minimized');
                    toggleButton.textContent = ' + '; // 切換為還原按鈕
                }
            };
            header.appendChild(toggleButton);
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 將頭部添加到浮動窗口
            floatWindow.appendChild(header);

            // 將提供的內容新增到浮動視窗中
            floatWindow.appendChild(contentElement);

            // 組裝視窗並顯示
            document.getElementById('floatingWindowContainer').appendChild(floatWindow);
            floatWindow.style.display = 'block';

            // 設定視窗的初始 z-index
            floatWindow.style.zIndex = highestZIndex++;

            // 新增點擊事件監聽器來調整 z-index
            floatWindow.addEventListener('click', function() {
                this.style.zIndex = ++highestZIndex;
            });
        }

        function startDrag(e, id) {
            const elem = document.getElementById(id);
            let offsetX = e.clientX - elem.getBoundingClientRect().left;
            let offsetY = e.clientY - elem.getBoundingClientRect().top;

            function onMouseMove(e) {
                elem.style.left = (e.clientX - offsetX) + 'px';
                elem.style.top = (e.clientY - offsetY) + 'px';
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // 切片
        function sliceCubeByAxis(axis) {
            updateAxes = false; // 切片操作時不更新軸線與軸標籤

            clearAxesLines();
            clearAxesLines_forcamera();

            var SliceRange = document.getElementById('SliceRange');
            sliceGap = parseFloat(SliceRange.value);
            document.getElementById('SliceValue').textContent = sliceGap;

            switch (axis) {
                case 'X':
                    allowUpdateSizes = false; // 在切片操作時停用修改邊長

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(.01, 1, 1);

                                     // 計算並更新立方體的新位置
                                    let posX = (i - (cubes.length - 1) / 2) * (cubeSizeX * sliceGap);
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'Y':
                    allowUpdateSizes = false;

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(1, .01, 1);
                                    
                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    let posY = (j - (cubes[i].length - 1) / 2) * (cubeSizeY * sliceGap);
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'Z':
                    allowUpdateSizes = false; 
                    
                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(1, 1, .01);
                                    
                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    let posZ = (k - (cubes[i][j].length - 1) / 2) * (cubeSizeZ * sliceGap);
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'O':
                    allowUpdateSizes = true; // 當選擇回原始 cube 時，回復修改邊長功能

                    updateAxes = true; // 當選擇回原始 cube 時，回復軸線功能

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
            }
            // 呼叫渲染函數來更新場景
            // renderer.render(scene, camera);
        }


        // 偵測 radio 按鈕的變化
        document.getElementById("axisSelection").addEventListener("change", function(event) {
            // 取得選取的軸
            selectedAxis = event.target.value;

            // 呼叫 sliceCubeByAxis 函數，傳入選中的軸
            sliceCubeByAxis(selectedAxis);
        });

        // 滑動條值改變時呼叫 sliceCubeByAxis 函數
        document.getElementById('SliceRange').addEventListener('input', function() {
            // 呼叫 sliceCubeByAxis 函數，傳入選中的軸
            sliceCubeByAxis(selectedAxis);
        });

        // 調整 cube 分開時之大小
        document.getElementById('hollowSize').addEventListener('input', function() {
            var newSize = this.value;
            hollowCube(newSize);
            document.getElementById('hollowSizeValue').textContent = newSize;
        });

        // 將 cube 分開
        function hollowCube(newSize) {
            // newSize 為更新之新尺寸
            for (let i = 0; i < cubes.length; i++) {
                for (let j = 0; j < cubes[i].length; j++) {
                    for (let k = 0; k < cubes[i][j].length; k++) {
                        let cube = cubes[i][j][k];
                        if (cube) {
                            cube.scale.set(newSize, newSize, newSize);

                            // // 計算並更新立方體的新位置
                            // var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            // var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            // var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;

                            // cube.position.set(posX, posY, posZ);
                        }
                    }
                }
            }
        }

        // 根據類別計算資料 (for bar chart)
        function calculateDataPoints(dataArray, uniqueX, uniqueY, uniqueZ, axis, calculationType) {
            //let results = {};
            let results_name = [];
            let results_value = [];

            if (axis === 'X') {
                for (let idx = 0; idx < Xindices.length; idx++) { // 使用全域變數 Xindices
                    let i = Xindices[idx];
                    let total = 0, count = 0;
                    for (let j = 0; j < uniqueY.length; j++) {
                        for (let k = 0; k < uniqueZ.length; k++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }
                    //results[uniqueX[i]] = calculationType === 'mean' ? total / count : total;
                    results_name[idx] = uniqueX[i];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }
            } else if (axis === 'Y') {
                for (let idx = 0; idx < Yindices.length; idx++) { // 使用全域變數 Yindices
                    let j = Yindices[idx];
                    let total = 0, count = 0;
                    for (let i = 0; i < uniqueX.length; i++) {
                        for (let k = 0; k < uniqueZ.length; k++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }
                    //results[uniqueY[j]] = calculationType === 'mean' ? total / count : total;
                    //console.log(j+","+uniqueY[j] +","+ results[uniqueY[j]]);
                    results_name[idx] = uniqueY[j];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }
            } else if (axis === 'Z') {
                for (let idx = 0; idx < Zindices.length; idx++) { // 使用全域變數 Zindices
                    let k = Zindices[idx];
                    //console.log(idx+","+Zindices[idx]);
                    let total = 0, count = 0;
                    for (let i = 0; i < uniqueX.length; i++) {
                        for (let j = 0; j < uniqueY.length; j++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }

                    //results[uniqueZ[k]] = calculationType === 'mean' ? total / count : total;
                    //console.log(k+","+uniqueZ[k] +","+ results[uniqueZ[k]]);
                    results_name[idx] = uniqueZ[k];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }

            }
            //return results;
            return {results_name, results_value};
        }

        // 根據不同軸輸出一二維陣列
        function extractDataForAxis(axis, index) {
            let result = [];
            
            if (axis === 'X') {
                // 選取 X 軸時 只有 X 軸的排序維持不變 並提取一個 Y * Z 的二維數組
                let xIndex = index; // X 軸索引不變
                for (let i = 0; i < Yindices.length; i++) {
                    let yIndex = Yindices[i]; // 使用 Yindices 重新排序 Y 軸索引
                    let row = [];
                    for (let j = 0; j < Zindices.length; j++) {
                        let zIndex = Zindices[j]; // 使用 Zindices 重新排序Z軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            } else if (axis === 'Y') {
                // 選取 Y 軸時 只有 Y 軸的排序保持不變 並提取一個 X * Z 的二維數組
                let yIndex = index; // Y 軸索引不變
                for (let i = 0; i < Xindices.length; i++) {
                    let xIndex = Xindices[i]; // 使用 Xindices 重新排序X軸索引
                    let row = [];
                    for (let j = 0; j < Zindices.length; j++) {
                        let zIndex = Zindices[j]; // 使用 Zindices 重新排序Z軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            } else if (axis === 'Z') {
                // 選取 Z 軸時 只有 Z 軸的排序維持不變 並提取一個 X * Y 的二維數組
                let zIndex = index; // Z 軸索引不變
                for (let i = 0; i < Xindices.length; i++) {
                    let xIndex = Xindices[i]; // 使用 Xindices 重新排序X軸索引
                    let row = [];
                    for (let j = 0; j < Yindices.length; j++) {
                        let yIndex = Yindices[j]; // 使用 Yindices 重新排序 Y 軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            }
            return result;
        }

        // // 創建 bar chart
        // function updateBarChart(containerId, dataPoints, axis) {
        //     const ctx = document.getElementById(containerId).getContext('2d');
            
        //     // 如果圖表已經存在，先銷毀它
        //     if (window[containerId + 'ChartInstance']) {
        //         window[containerId + 'ChartInstance'].destroy();
        //     }
            
        //     // 確保每個軸的選取 bar 記錄被初始化
        //     if (!selectedBars[axis]) {
        //         selectedBars[axis] = new Set();
        //     }

        //     // 預設和選取狀態下的顏色
        //     const defaultColor = 'rgba(133, 163, 245, 0.2)';
        //     const selectedColor = 'rgba(57, 108, 247, 0.5)';

        //     // 根據是否選取設定每個 bar 的顏色
        //     const backgroundColors = Object.keys(dataPoints).map(label => 
        //         selectedBars[axis].has(label) ? selectedColor : defaultColor
        //     );

        //     // 建立新的長條圖
        //     window[containerId + 'ChartInstance'] = new Chart(ctx, {
        //         type: 'bar',
        //         data: {
        //             labels: Object.keys(dataPoints),
        //             datasets: [{
        //                 label: 'Value',
        //                 data: Object.values(dataPoints), // 對應的資料點
        //                 backgroundColor: backgroundColors,
        //                 borderColor: 'rgba(133, 163, 245, 0.7)',
        //                 borderWidth: 1
        //             }]
        //         },
        //         options: {
        //             scales: {
        //                 y: { beginAtZero: true },
        //                 x: {
        //                     ticks: {
        //                         padding: 1, // 設定標籤與 Y 軸之間的距離
        //                         maxRotation: 90, // 最大旋轉角度
        //                         // minRotation: 90, // 最小旋轉角度 (設定為相同值使所有標籤保持相同角度)
        //                     }
        //                 }
        //             },
        //             responsive: true, // 確保響應式開啟
        //             maintainAspectRatio: false, // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
        //             onClick: function(evt, element) {
        //                 if (element.length > 0) {
        //                     const index = element[0].index; // 取得點擊的 bar 的索引
        //                     const label = this.data.labels[index]; // 取得標籤

        //                     if (selectedBars[axis].has(label)) {
        //                         selectedBars[axis].delete(label);
        //                         this.data.datasets[0].backgroundColor[index] = defaultColor;
        //                     } else {
        //                         selectedBars[axis].add(label);
        //                         this.data.datasets[0].backgroundColor[index] = selectedColor;
        //                     }
        //                     this.update();

        //                     // 根據點擊的 bar 將條件添加至 categoryConditions
        //                     filterCubesbyCategoriesaddinselectedCategories(label, axis);

        //                     // 根據條件 filter Cubes
        //                     filterCubes();

        //                     // // 根據不同軸輸出一二維陣列
        //                     // const extractedData = extractDataForAxis(axis, index);
        //                     // console.log(extractedData);
        //                 }
        //             }
        //         }
        //     });
        // }

        // 創建 bar chart
        function updateBarChart(containerId, dataPoints, axis) {
            // 如果圖表已經存在，先銷毀它
            if (window[containerId + 'ChartInstance']) {
                // console.log('銷毀圖表實例:', containerId);
                window[containerId + 'ChartInstance'].destroy();
                window[containerId + 'ChartInstance'] = null; // 清空實例
            }

            const ctx = document.getElementById(containerId).getContext('2d');
            
            // 確保每個軸的選取 bar 記錄被初始化
            if (!selectedBars[axis]) {
                selectedBars[axis] = new Set();
            }

            // 預設和選取狀態下的顏色
            const defaultColor = 'rgba(133, 163, 245, 0.2)';
            const selectedColor = 'rgba(57, 108, 247, 0.5)';

            // // 排序資料點
            // const sortedDataPoints = Object.keys(dataPoints)
            //     .sort((a, b) => parseFloat(a) - parseFloat(b)) // 這裡確保數字類別能夠正確排序
            //     .reduce((acc, key) => {
            //         acc[key] = dataPoints[key];
            //         return acc;
            //     }, {});

            // 根據是否選取設定每個 bar 的顏色
            const backgroundColors = dataPoints.results_name.map(label => 
                selectedBars[axis].has(label) ? selectedColor : defaultColor
            );

            // 建立新的長條圖
            window[containerId + 'ChartInstance'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    //labels: Object.keys(dataPoints),
                    labels: dataPoints.results_name,
                    datasets: [{
                        label: 'Value',
                        //data: Object.values(dataPoints), // 對應的資料點
                        data: dataPoints.results_value, // 對應的資料點
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(133, 163, 245, 0.7)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: { beginAtZero: true },
                        x: {
                            ticks: {
                                padding: 1, // 設定標籤與 Y 軸之間的距離
                                maxRotation: 90, // 最大旋轉角度
                                // minRotation: 90, // 最小旋轉角度 (設定為相同值使所有標籤保持相同角度)
                            }
                        }
                    },
                    responsive: true, // 確保響應式開啟
                    maintainAspectRatio: false // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
                }
            });

            // 綁定 mouse 事件處理拖曳
            ctx.canvas.addEventListener('mousedown', function(evt) {
                const element = window[containerId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                if (element.length > 0) {
                    isDragging = true;
                    dragStartIndex = element[0].index;
                    lastValidIndex = element[0].index;  // 初始化最後有效索引
                }
            });

            ctx.canvas.addEventListener('mousemove', function(evt) {
                if (isDragging) {
                    const element = window[containerId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                    if (element.length > 0) {
                        lastValidIndex = element[0].index;  // 更新最後有效索引
                    }
                }
            });

            ctx.canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    const end = Math.max(dragStartIndex, lastValidIndex);
                    const start = Math.min(dragStartIndex, lastValidIndex);
                    
                    // 對範圍內的每個 bar 進行選擇或取消選擇
                    for (let i = start; i <= end; i++) {
                        const label = window[containerId + 'ChartInstance'].data.labels[i];

                        // console.log(label);

                        if (selectedBars.has(label)) {
                            selectedBars.delete(label);
                            window[containerId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = defaultColor;  // 將顏色變回未選取的顏色

                            // 根據點擊的 bar 將條件添加至 categoryConditions
                            filterCubesbyCategoriesaddinselectedCategories(label, axis);
                        } else {
                            selectedBars.add(label);
                            window[containerId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = selectedColor;  // 將顏色變為選取的顏色

                            // 根據點擊的 bar 將條件添加至 categoryConditions
                            filterCubesbyCategoriesaddinselectedCategories(label, axis);
                        }
                    }
                    window[containerId + 'ChartInstance'].update();

                    filterCubes();  // 根據所選條件進行篩選
                    isDragging = false;
                }
            });

            window[containerId + 'ChartInstance'];
        }

        // 根據點擊的 bar 將條件添加至 categoryConditions
        function filterCubesbyCategoriesaddinselectedCategories(clickedLabel, axis) {
            let categoryKey = `${axis}:${clickedLabel}`; // 建立一個唯一標識該類別的鍵

            if (categoryConditions.has(categoryKey)) {
                // 如果再次點擊了相同的類別，從集合中移除該類別
                categoryConditions.delete(categoryKey);
            } else {
                // 否則，新增該類別到集合中
                categoryConditions.add(categoryKey);
            }
        }

        // 計算 Histogram 用之 bins, counts
        function calculateBinsAndCounts(dataArray, globalMin, globalMax) {
            // 無限階扁平化數組
            const flattenData = dataArray.flat(Infinity);

            // 計算所有有效資料點的總數
            const n = flattenData.length;

            // 使用 Sturges' formula 計算區間數
            const numBins = Math.ceil(Math.log2(n) + 1);

            const minValue = globalMin;
            const maxValue = globalMax;
            const binSize = (maxValue - minValue) / numBins;

            let bins = Array.from({ length: numBins }, (_, i) => minValue + binSize * i);
            let counts = new Array(numBins).fill(0);

            // 遍歷扁平化後的資料數組
            flattenData.forEach(value => {
                let binIndex = Math.min(
                    Math.floor((value - minValue) / binSize),
                    numBins - 1 // 防止最大值超出最後一個區間
                );
                counts[binIndex]++;
            });

            // 更新 bins 為更友善的字串表示形式
            bins = bins.map((start, index) => {
                const end = start + binSize;
                return `${start.toFixed(2)}-${end.toFixed(2)}`;
            });

            return { bins, counts };
        }

        // 創建 Histogram
        // function drawHistogram(chartId, bins, counts) {
        //     const ctx = document.getElementById(chartId).getContext('2d');
            
        //     // 如果圖表已經存在，先銷毀它
        //     if (window[chartId + 'ChartInstance']) {
        //         window[chartId + 'ChartInstance'].destroy();
        //     }

        //     // 預設和選取狀態下的顏色
        //     const defaultColor = 'rgb(75, 192, 192, .2)';
        //     const selectedColor = 'rgb(23, 191, 191, .5)';

        //     // 根據是否選取設定每個 bar 的顏色
        //     const backgroundColors = bins.map(bin =>
        //         selectedHistogramBars.has(bin) ? selectedColor : defaultColor
        //     );
            
        //     window[chartId + 'ChartInstance'] = new Chart(ctx, {
        //         type: 'bar',
        //         data: {
        //             labels: bins, // 區間作為標籤
        //             datasets: [{
        //                 label: 'Distribution',
        //                 data: counts, // 區間內資料點數量
        //                 backgroundColor: backgroundColors,
        //                 borderColor: 'rgb(75, 192, 192, .7)',
        //                 borderWidth: .5 // 邊框的寬度
        //             }]
        //         },
        //         options: {
        //             scales: {
        //                 y: { // y 軸配置
        //                     beginAtZero: true, // y軸從 0 開始
        //                     title: {
        //                         display: true, // 顯示 y 軸標題
        //                         text: 'counts' // y 軸標題文本
        //                     }
        //                 }
        //             },
        //             barPercentage: 1.0, // 直方圖寬度佔分類寬度的比例 設定為 1 使柱子緊密排列
        //             categoryPercentage: 1.0, // 類別之間的寬度佔總類別寬度的比例 設定為 1 減少類別之間的間隔
        //             responsive: true, // 確保響應式開啟
        //             maintainAspectRatio: false, // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
        //             onClick: function(evt, element) {
        //                 if (element.length > 0) {
        //                     const index = element[0].index; // 取得點擊的 bar 的索引
        //                     const label = this.data.labels[index]; // 取得標籤

        //                     // 更新選取狀態和顏色
        //                     if (selectedHistogramBars.has(label)) {
        //                         selectedHistogramBars.delete(label);
        //                         this.data.datasets[0].backgroundColor[index] = defaultColor;
        //                     } else {
        //                         selectedHistogramBars.add(label);
        //                         this.data.datasets[0].backgroundColor[index] = selectedColor;
        //                     }
        //                     this.update();

        //                     // 根據所選 value range 將條件添加至 rangeConditions
        //                     filterCubesbyvalueaddinselectedCategories(label)

        //                     // 根據條件 filter Cubes
        //                     filterCubes();
        //                 }
        //             }
        //         }
        //     });
        // }

        // 創建 Histogram
        function drawHistogram(chartId, bins, counts) {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            // 如果圖表已經存在，先銷毀它
            if (window[chartId + 'ChartInstance']) {
                window[chartId + 'ChartInstance'].destroy();
            }

            // 預設和選取狀態下的顏色
            const defaultColor = 'rgb(75, 192, 192, .2)';
            const selectedColor = 'rgb(23, 191, 191, .5)';

            // 根據是否選取設定每個 bar 的顏色
            const backgroundColors = bins.map(bin => selectedHistogramBars.has(bin) ? selectedColor : defaultColor);

            window[chartId + 'ChartInstance'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: bins, // 區間作為標籤
                    datasets: [{
                        label: 'Distribution',
                        data: counts, // 區間內資料點數量
                        backgroundColor: backgroundColors,
                        borderColor: 'rgb(75, 192, 192, .7)',
                        borderWidth: .5 // 邊框的寬度
                    }]
                },
                options: {
                    scales: {
                        y: { // y 軸配置
                            beginAtZero: true, // y 軸從 0 開始
                            title: {
                                display: true, // 顯示 y 軸標題
                                text: 'counts' // y 軸標題文本
                            }
                        }
                    },
                    barPercentage: 1.0, // 直方圖寬度佔分類寬度的比例 設定為 1 使柱子緊密排列
                    categoryPercentage: 1.0, // 類別之間的寬度佔總類別寬度的比例 設定為 1 減少類別之間的間隔
                    responsive: true, // 確保響應式開啟
                    maintainAspectRatio: false, // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
                }
            });

            // 綁定 mouse 事件處理拖曳
            ctx.canvas.addEventListener('mousedown', function(evt) {
                const element = window[chartId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                if (element.length > 0) {
                    isDragging = true;
                    dragStartIndex = element[0].index;
                    lastValidIndex = element[0].index;  // 初始化最後有效索引
                }
            });

            ctx.canvas.addEventListener('mousemove', function(evt) {
                if (isDragging) {
                    const element = window[chartId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                    if (element.length > 0) {
                        lastValidIndex = element[0].index;  // 更新最後有效索引
                    }
                }
            });

            ctx.canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    const end = Math.max(dragStartIndex, lastValidIndex);
                    const start = Math.min(dragStartIndex, lastValidIndex);
                    
                    // 對範圍內的每個 bar 進行選擇或取消選擇
                    for (let i = start; i <= end; i++) {
                        const label = window[chartId + 'ChartInstance'].data.labels[i];
                        if (selectedHistogramBars.has(label)) {
                            selectedHistogramBars.delete(label);
                            window[chartId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = defaultColor;  // 將顏色變回未選取的顏色

                            // 根據所選 value range 將條件添加至 rangeConditions
                            filterCubesbyvalueaddinselectedCategories(label)
                        } else {
                            selectedHistogramBars.add(label);
                            window[chartId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = selectedColor;  // 將顏色變為選取的顏色

                            // 根據所選 value range 將條件添加至 rangeConditions
                            filterCubesbyvalueaddinselectedCategories(label)
                        }
                    }
                    window[chartId + 'ChartInstance'].update();

                    filterCubes();  // 根據所選條件進行篩選
                    isDragging = false;
                }
            });

            window[chartId + 'ChartInstance'];
        }

        // 根據所選 value range 將條件添加至 rangeConditions
        function filterCubesbyvalueaddinselectedCategories(clickedLabel) {
            const rangeParts = clickedLabel.split("-");
            const minValue = parseFloat(rangeParts[0]);
            const maxValue = parseFloat(rangeParts[rangeParts.length - 1]);

            const rangeKey = `${minValue}-${maxValue}`;

            if (rangeConditions.has(rangeKey)) {
                rangeConditions.delete(rangeKey);
            } else {
                rangeConditions.add(rangeKey);
            }
        }

        // 新增事件監聽器以便於當使用者改變選擇時執行操作
        document.getElementById('UnionorIntersection').addEventListener('change', function() {
            // 取得目前選取的值
            selectionType = this.value;
            filterCubes();
        });

        // 根據條件更新立方體的顯示狀態
        function filterCubes() {
            // console.log('-------');
            // console.log(categoryConditions);
            // console.log(rangeConditions);

            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // 更新 filter 掉之 cubes 透明度
            var filteropacityRange = document.getElementById('filteropacityRange');
            var filternewOpacity = parseFloat(filteropacityRange.value);
            document.getElementById('filteropacityValue').textContent = filternewOpacity;

            cubes.forEach((cubeRow, i) => cubeRow.forEach((cubeColumn, j) => cubeColumn.forEach((cube, k) => {
                if (cube) {
                    const cubeValue = cube.userData.value;
                    matchesCategoryConditions = categoryConditions.size === 0; // 如果沒有類別條件，則預設匹配
                    matchesRangeConditions = rangeConditions.size === 0; // 如果沒有範圍條件，則預設匹配

                    // 檢查類別條件
                    if (categoryConditions.size > 0 && rangeConditions.size == 0) {
                        if (selectionType === "Union") {
                            matchesCategoryConditions = [...categoryConditions].some(condition => {
                                const [axis, label] = condition.split(":");

                                const selectedIndex = {
                                    'X': uniqueX.indexOf(label),
                                    'Y': uniqueY.indexOf(label),
                                    'Z': uniqueZ.indexOf(label)
                                }[axis];
                                return {
                                    'X': Xindices[i] === selectedIndex,
                                    'Y': Yindices[j] === selectedIndex,
                                    'Z': Zindices[k] === selectedIndex
                                }[axis];
                            });
                        } else if (selectionType === "Intersection") {
                            matchesCategoryConditions = [...categoryConditions].every(condition => {
                                const [axis, label] = condition.split(":");
                                const selectedIndex = {
                                    'X': uniqueX.indexOf(label),
                                    'Y': uniqueY.indexOf(label),
                                    'Z': uniqueZ.indexOf(label)
                                }[axis];
                                return {
                                    'X': Xindices[i] === selectedIndex,
                                    'Y': Yindices[j] === selectedIndex,
                                    'Z': Zindices[k] === selectedIndex
                                }[axis];
                            });
                        }
                    } else if (rangeConditions.size > 0 && categoryConditions.size == 0) { // 檢查數值範圍條件
                        matchesRangeConditions = [...rangeConditions].some(condition => {
                            const [minValue, maxValue] = condition.split("-").map(Number);
                            return cubeValue >= minValue && cubeValue <= maxValue;
                        });
                    } else if (categoryConditions.size > 0 && rangeConditions.size > 0) { // 若同時有類別條件和數值範圍條件，必須同時滿足
                        matchesCategoryConditions = [...categoryConditions].some(condition => {
                            const [axis, label] = condition.split(":");
                            const selectedIndex = {
                                'X': uniqueX.indexOf(label),
                                'Y': uniqueY.indexOf(label),
                                'Z': uniqueZ.indexOf(label)
                            }[axis];
                            return {
                                'X': Xindices[i] === selectedIndex,
                                'Y': Yindices[j] === selectedIndex,
                                'Z': Zindices[k] === selectedIndex
                            }[axis];
                        });
                        matchesRangeConditions = [...rangeConditions].some(condition => {
                            const [minValue, maxValue] = condition.split("-").map(Number);
                            return cubeValue >= minValue && cubeValue <= maxValue;
                        });
                    }
                    // 更新透明度
                    /*if (cube.userData.value !== null) {
                        cube.material.opacity = (matchesCategoryConditions && matchesRangeConditions) ? newOpacity : filternewOpacity;
                        cubesOpacity[i][j][k] = cube.material.opacity;
                    }*/
                    var value = cube.userData.value; // 立方體的值
                    if (value == null) { // 如果為遺失值，透明度為 0
                        cube.material.opacity = 0;
                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                    } 
                    else{
                        if (categoryConditions.size == 0 && rangeConditions.size == 0) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                            // 非遺失值值立方體根據滑動條更新透明度
                            if (value < globalSliderMin || value > globalSliderMax) {
                                // 值不在滑動條選擇的範圍內
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                // console.log(cubesOpacity);
                                        
                            } else if (globalSliderMin <= value <= globalSliderMax) {
                                // 值在滑動條選擇的範圍內
                                cube.material.opacity = newOpacity;

                                // 追蹤透明度值
                                cubesOpacity[i][j][k] = cube.material.opacity; 
                                //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);
                            }
                        }
                        else
                        {   
                            // 非遺失值值立方體根據滑動條更新透明度
                            if (value < globalSliderMin || value > globalSliderMax) {
                                // 值不在滑動條選擇的範圍內
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                // console.log(cubesOpacity);
                                        
                            } else if (globalSliderMin <= value <= globalSliderMax) {
                                // 值在滑動條選擇的範圍內
                                if(matchesCategoryConditions && matchesRangeConditions)
                                    cube.material.opacity = newOpacity;
                                else
                                    cube.material.opacity = filternewOpacity; 
                                cubesOpacity[i][j][k] = cube.material.opacity;
                                //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);
                            }
                        }
                    }

                }
            })));
        }

        // 按下 resetToOriginalCube 按鈕時，將 cube 回復原狀
        document.getElementById('resetToOriginalCube').addEventListener('click', function() {
            for (let i = 0; i < Xindices.length; i++) {
                for (let j = 0; j < Yindices.length; j++) {
                    for (let k = 0; k < Zindices.length; k++) {
                        // 在立方體已經創建的基礎上進行
                        let cube = cubes[i][j][k]; // 取得現有的立方體

                        if (cube) {
                            // 使用排序後的索引從 data_array 取得值
                            let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                            if (value !== null) {

                                cube.material.opacity = currentOpacity;
                                // 追蹤透明度值
                                cubesOpacity[i][j][k] = cube.material.opacity; 

                            } else {
                                cube.material.opacity = 0; // 空值立方體保持完全透明
                            }
                        }
                    }
                }
            }
            clearbar();
            applyChangesBasedOnNewIndices();
        });

        function clearbar() {
            // 清空集合
            categoryConditions.clear();
            rangeConditions.clear(); // 用於追蹤選中的範圍 (for histogram)

            // 正確清空 selectedBars 的每個 Set
            Object.keys(selectedBars).forEach(axis => {
                selectedBars[axis].clear();
            });

            selectedHistogramBars.clear();

            const chartInstances = ['chartXChartInstance', 'chartYChartInstance', 'chartZChartInstance'];

            // 檢查 bar chart 圖表實例是否存在 if so 重設顏色
            chartInstances.forEach(updateChartColors);

            // 檢查 Histogram 圖表實例是否存在 if so 重設顏色
            if (window.HistogramChartInstance) {
                const datasetforHistogram = window.HistogramChartInstance.data.datasets[0];
                const defaultColorforHistogram = 'rgb(75, 192, 192, .2)';

                // 變更所有條形的顏色為預設顏色
                datasetforHistogram.backgroundColor = datasetforHistogram.backgroundColor.map(() => defaultColorforHistogram);

                // 更新圖表以應用顏色更改
                window.HistogramChartInstance.update();
            }
        }

        // 更新圖表顏色 (for resetToOriginalCube)
        function updateChartColors(chartInstanceName) {
            const defaultColor = 'rgba(133, 163, 245, 0.2)'; // 設定預設顏色
            const chartInstance = window[chartInstanceName]; // window[chartId + 'ChartInstance']
            if (chartInstance) {
                const dataset = chartInstance.data.datasets[0];
                dataset.backgroundColor = dataset.backgroundColor.map(() => defaultColor);
                chartInstance.update();
            }
        }

        // 清除場景中的所有子對象
        function clearAllSceneObjects() {
            // 遍歷並移除場景中的所有子對象
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
        }

        // 清除所有浮動視窗
        function clearAllFloatingWindows() {
            const container = document.getElementById('floatingWindowContainer');
            // 檢查容器是否存在
            if (container) {
                // 遍歷並移除容器中的所有子元素
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }
        }

        // 觸發文件輸入的點擊事件
        document.getElementById('fileButton').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        // 顯示資料處理面板
        document.getElementById('fileInput').addEventListener('change', function() {
            if (this.files && this.files.length > 0) {
                document.getElementById('dataProcessingPanel').style.display = 'block';
            }
        });

        // 按 ok button 之後隱藏面板
        document.getElementById('okButton').addEventListener('click', function() {
            document.getElementById('dataProcessingPanel').style.display = 'none';
        });

        // 按 cancel button 之後隱藏面板並重置 file input
        document.getElementById('cancelButton').addEventListener('click', function() {
            document.getElementById('dataProcessingPanel').style.display = 'none';
            // 重置 file input，這樣再次選擇同一個文件也會觸發 change 事件
            document.getElementById('fileInput').value = null;
        });

        // 追蹤欄位之反白狀態
        var highlightedColumns = {
            'multiSelectX': null,
            'multiSelectY': null,
            'multiSelectZ': null,
            'singleSelect': null
        };

        // 將下拉式選單所選之欄位反白
        function highlightColumn(selectElementId, selectedColumnName, highlightClass) {
            var headers = document.querySelectorAll('#dataPreviewHead th');
            var columnIndex = -1;

            // 找出對應的 column 索引
            headers.forEach((th, index) => {
                if (th.textContent === selectedColumnName) {
                    columnIndex = index;
                }
            });

            // 清除之前這個下拉式選單反白的欄位
            if (highlightedColumns[selectElementId] !== null) {
                document.querySelectorAll(`#dataPreviewBody tr`).forEach(row => {
                    var cell = row.cells[highlightedColumns[selectElementId]];
                    if (cell) {
                        // 移除舊的反白類別
                        cell.classList.remove(highlightClass);
                    }
                });
            }

            // 更新物件以追蹤新的反白欄位
            highlightedColumns[selectElementId] = columnIndex;

            // 反白新的欄位
            if (columnIndex > -1) {
                document.querySelectorAll(`#dataPreviewBody tr`).forEach(row => {
                    var cell = row.cells[columnIndex];
                    if (cell) {
                        // 添加新的反白類別
                        cell.classList.add(highlightClass);
                    }
                });
            }
        }

        // 監聽 discr、conti 之 6 個下拉式選單
        document.addEventListener('DOMContentLoaded', function() {
            // 為每個下拉式選單設定事件監聽器
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`select${i}`).addEventListener('change', function() {
                    // 重新計算並應用 highlight
                    applyHighlights();
                });
            }
        });

        // 根據下拉式選單的選擇應用 highlight
        function applyHighlights() {
            // 首先清除所有 highlight
            document.querySelectorAll('#dataPreviewBody tr td').forEach(cell => {
                for (let i = 1; i <= 6; i++) {
                    cell.classList.remove(`highlight-${i}`);
                }
            });

            let highlightIndex = 0; // 記錄從哪一列開始 highlight

            for (let i = 1; i <= 6; i++) {
                const selectValue = parseInt(document.getElementById(`select${i}`).value, 10);
                
                // highlight 從 highlightIndex 開始的 selectValue 個列
                if (selectValue > 0) {
                    document.querySelectorAll('#dataPreviewBody tr').forEach(row => {
                        for (let j = highlightIndex; j < highlightIndex + selectValue && j < row.cells.length; j++) {
                            const cell = row.cells[j];
                            if (cell) {
                                cell.classList.add(`highlight-${i}`); // 使用對應的顏色進行 highlight
                            }
                        }
                    });

                    // 蒐集選取的 column 名
                    logSelectedColumnNames(highlightIndex, selectValue, i);
                }
                highlightIndex += selectValue; // 更新下一個 highlight column 的起始索引
            }
        }

        // 蒐集選取的 column 名
        function logSelectedColumnNames(startIndex, count, selectNumber) {
            let columnNames = [];
            // 從第 startIndex 欄位開始，收集 count 個 column 名
            for (let i = startIndex; i < startIndex + count; i++) {
                let columnName = document.querySelector(`#dataPreviewHead th:nth-child(${i + 1})`).textContent;
                columnNames.push(columnName);
            }
            // 列印選取的 column 名
            console.log(`Select${selectNumber} selected columns:`, columnNames.join(", "));
        }

        // 當文件被選擇後處理 CSV 檔案
        document.getElementById('fileInput').addEventListener('change', function(event) {
            if (!this.files || this.files.length === 0) return;
            var file = event.target.files[0];
            var reader = new FileReader();

            reader.onload = function(e) {
                var csvData = e.target.result;

                // 使用 PapaParse 解析 CSV 資料
                Papa.parse(csvData, {
                    header: true,
                    complete: function(results) {
                        parsedData = results.data;
                        if (parsedData.length === 0) return; // 沒有資料時直接返回

                        // 設置行數
                        var rowCount = parsedData.length;
                        document.getElementById('rowCount').textContent = rowCount;

                        // 如果有表頭，用表頭的數量作為列數
                        colCount = results.meta.fields ? results.meta.fields.length : parsedData[0] ? Object.keys(parsedData[0]).length : 0;
                        document.getElementById('colCount').textContent = colCount;

                        var columnNames = Object.keys(parsedData[0]);
                        
                        // 準備表格的表頭
                        var thead = document.getElementById('dataPreviewHead');
                        thead.innerHTML = ''; // 清空之前的表頭
                        var headerRow = thead.insertRow();
                        columnNames.forEach(function(columnName) {
                            var th = document.createElement('th');
                            th.textContent = columnName;
                            headerRow.appendChild(th);
                        });

                        // 顯示前 6 筆資料到表格中
                        var tbody = document.getElementById('dataPreviewBody');
                        tbody.innerHTML = ''; // 清空之前的資料
                        for (let i = 0; i < Math.min(6, parsedData.length); i++) {
                            let row = tbody.insertRow();
                            Object.values(parsedData[i]).forEach(function(value, index) {
                                var cell = row.insertCell();
                                cell.textContent = value;
                            });
                        }

                        // 顯示資料處理面板
                        document.getElementById('dataProcessingPanel').style.display = 'block';

                        fillSelectOptions('multiSelectX', columnNames);
                        fillSelectOptions('multiSelectY', columnNames);
                        fillSelectOptions('multiSelectZ', columnNames);
                        fillSelectOptions('singleSelect', columnNames);

                        // 監聽 XYZ 軸之單選下拉式選單的變化 更新單選下拉式選單的選項 移除已被 複選下拉式選單(3 單選下拉式選單) 選中的選項，並更新反白顏色
                        document.getElementById('multiSelectX').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectX', this.value, 'highlight-color-1');
                            fieldX = this.value;
                            uniqueX = getUniqueColumnValues(parsedData, fieldX);
                            document.getElementById('Xnum').textContent = uniqueX.length; // 在資料小面板中顯示 uniqueX, uniqueY, uniqueZ

                            var minMaxX = findMinMax(parsedData, this.value);
                        });
                        document.getElementById('multiSelectY').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectY', this.value, 'highlight-color-2');
                            fieldY = this.value;
                            uniqueY = getUniqueColumnValues(parsedData, fieldY);
                            document.getElementById('Ynum').textContent = uniqueY.length;
                        });
                        document.getElementById('multiSelectZ').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectZ', this.value, 'highlight-color-3');
                            fieldZ = this.value;
                            uniqueZ = getUniqueColumnValues(parsedData, fieldZ);
                            document.getElementById('Znum').textContent = uniqueZ.length;
                        });
                        document.getElementById('singleSelect').addEventListener('change', function() {
                            highlightColumn('singleSelect', this.value, 'highlight-color-4');
                            var minMax = findMinMax(parsedData, this.value);
                            document.getElementById('valuemin').textContent = minMax.min.toFixed(2);;
                            document.getElementById('valuemax').textContent = minMax.max.toFixed(2);;
                        });
                    }
                });
            };
            reader.readAsText(file);
        });

        // 小面板之 ok button = plot button 
        document.getElementById('okButton').addEventListener('click', function() {
            // 獲取三個單選下拉式選單中選中的選項
            var selectedFields = [
                getSelectedOptions('multiSelectX'),
                getSelectedOptions('multiSelectY'),
                getSelectedOptions('multiSelectZ'),
            ];
            var selectedValueField = document.getElementById('singleSelect').value;

            // 初始化 cubeSizeX, cubeSizeY, cubeSizeZ 為 1 或使用者指定的值
            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value) || 1;
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value) || 1;
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value) || 1;

            document.getElementById('cubeSizeX').value = cubeSizeX;
            document.getElementById('cubeSizeY').value = cubeSizeY;
            document.getElementById('cubeSizeZ').value = cubeSizeZ;

            clearAllSceneObjects(); // 清除場景中的所有對象 (for 選擇不同映射 column)
            clearAllFloatingWindows(); // 清除所有浮動視窗
            processDataAndPlot(parsedData, selectedFields, selectedValueField, cubeSizeX, cubeSizeY, cubeSizeZ);

            let calculationType = 'sum'; // 預設值

            // 先利用預設值計算並創建圖表
            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

            // 建立圖表的容器元素
            const chartContainerX = document.createElement('div');
            const canvasX = document.createElement('canvas');
            canvasX.id = 'chartX';
            chartContainerX.appendChild(canvasX);

            const chartContainerY = document.createElement('div');
            const canvasY = document.createElement('canvas');
            canvasY.id = 'chartY';
            chartContainerY.appendChild(canvasY);

            const chartContainerZ = document.createElement('div');
            const canvasZ = document.createElement('canvas');
            canvasZ.id = 'chartZ';
            chartContainerZ.appendChild(canvasZ);

            chartContainerX.style.width = '100%';
            chartContainerX.style.height = '80%';

            chartContainerY.style.width = '100%';
            chartContainerY.style.height = '80%';

            chartContainerZ.style.width = '100%';
            chartContainerZ.style.height = '80%';

            // 創建浮動視窗
            createFloatingWindow_forchart('floatingChartX', 'Bar Chart of  X-axis', chartContainerX, 320, 110, 300, 210);
            createFloatingWindow_forchart('floatingChartY', 'Bar Chart of  Y-axis', chartContainerY, 320, 340, 300, 210);
            createFloatingWindow_forchart('floatingChartZ', 'Bar Chart of  Z-axis', chartContainerZ, 320, 570, 300, 210);

            // 更新或繪製長條圖
            updateBarChart('chartX', chartDataX, 'X');
            updateBarChart('chartY', chartDataY, 'Y');
            updateBarChart('chartZ', chartDataZ, 'Z');

            // 取得計算類型 (sum 或 mean)
            document.getElementById('calculationType').addEventListener('change', function() {
                const calculationType = this.value;

                let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
                let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
                let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

                // 更新或繪製長條圖
                updateBarChart('chartX', chartDataX, 'X');
                updateBarChart('chartY', chartDataY, 'Y');
                updateBarChart('chartZ', chartDataZ, 'Z');
            });

            const Histogram = document.createElement('div');
            const canvas_Histogram = document.createElement('canvas');
            canvas_Histogram.id = 'Histogram';
            Histogram.appendChild(canvas_Histogram);

            Histogram.style.width = '100%';
            Histogram.style.height = '80%';

            // 計算 Histogram 用之 bins, counts
            let { bins, counts } = calculateBinsAndCounts(data_array, globalMin, globalMax);

            // 創建浮動視窗
            createFloatingWindow_forchart('floatingChartHistogram', 'Histogram', Histogram, 1115, 110, 300, 210);

            // 繪製直方圖
            drawHistogram('Histogram', bins, counts);
        });

        // 繪製 cube
        function processDataAndPlot(data, fields, valueField, cubeSizeX, cubeSizeY, cubeSizeZ) {
            var i, j, k;

            fieldX = fields[0];
            fieldY = fields[1];
            fieldZ = fields[2];

            // 處理資料
            uniqueX = getUniqueColumnValues(data, fieldX);
            uniqueY = getUniqueColumnValues(data, fieldY);
            uniqueZ = getUniqueColumnValues(data, fieldZ);

            // 初始化資料結構
            data_array = createDataArray(uniqueX, uniqueY, uniqueZ);

            // 填充資料結構和 combined_text
            fillDataArray(data, data_array, uniqueX, uniqueY, uniqueZ, fieldX, fieldY, fieldZ);

            // 填充 2d heatmap 之下拉式菜单
            // fillSelectfor2dheatmap('xAxisCate', uniqueX);
            // fillSelectfor2dheatmap('yAxisCate', uniqueY);
            // fillSelectfor2dheatmap('zAxisCate', uniqueZ);

            // console.log(data_array);

            // 計算最小值和最大值 (for colour)
            var minMax = findMinMax(data, valueField);
            var min = minMax.min;
            var max = minMax.max;

            // console.log(minMax);

            // 在此函數內計算並存儲全域最小值和最大值
            globalMin = minMax.min;
            globalMax = minMax.max;

            // 更新滑動條的最小值和最大值
            $("#double-slider").slider("option", "min", globalMin);
            $("#double-slider").slider("option", "max", globalMax);

            // 重置滑動條的目前值到新的最小值和最大值
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示
            var handles = $("#double-slider .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            // 更新滑動條的最小值和最大值
            $("#double-slider-cubesvalue").slider("option", "min", globalMin);
            $("#double-slider-cubesvalue").slider("option", "max", globalMax);

            // 重置滑動條的目前值到新的最小值和最大值
            $("#double-slider-cubesvalue").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示
            var handles = $("#double-slider-cubesvalue .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            globalSliderMin = globalMin;
            globalSliderMax = globalMax;

            // console.log(globalSliderMin);
            // console.log(globalSliderMax);

            // 取得每一個 X 軸類別的 min、max
            uniqueX.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldX 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldX] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueX 對象
                minMaxByUniqueX[uniqueValue] = minMax;
                // console.log(minMaxByUniqueX);
            });

            // 取得每一個 Y 軸類別的 min、max
            uniqueY.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldY 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldY] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueY 對象
                minMaxByUniqueY[uniqueValue] = minMax;
                // console.log(minMaxByUniqueY);
            });

            // 取得每一個 Z 軸類別的 min、max
            uniqueZ.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldZ 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldZ] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueX 對象
                minMaxByUniqueZ[uniqueValue] = minMax;
                // console.log(minMaxByUniqueZ);
            });

            // 計算 uniqueX、uniqueY、uniqueZ 之長度
            numX = data_array.length;
            numY = data_array[0].length;
            numZ = data_array[0][0].length;

            // 初始化 cubes array 並添加立方體到場景
            for (i = 0; i < numX; i++) {
                cubes[i] = []; // 初始化二維 array
                cubesOpacity[i] = [];
                for (j = 0; j < numY; j++) {
                    cubes[i][j] = []; // 初始化三維 array
                    cubesOpacity[i][j] = [];
                    for (k = 0; k < numZ; k++) {
                        cubesOpacity[i][j][k] = .2; // 設初始透明度為 0.2

                        // 創建一個具有基本材料的立方體
                        let cubeMaterial = new THREE.MeshBasicMaterial({ 
                            transparent: true,
                            opacity: 0 // 初始設為完全透明
                        });

                        let cubeGeometry = new THREE.BoxGeometry(cubeSizeX, cubeSizeY, cubeSizeZ);
                        let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

                        // 計算立方體的位置
                        var posX = i * cubeSizeX - ((numX - 1) * cubeSizeX / 2);
                        var posY = j * cubeSizeY - ((numY - 1) * cubeSizeY / 2);
                        var posZ = k * cubeSizeZ - ((numZ - 1) * cubeSizeZ / 2);
                        cube.position.set(posX, posY, posZ);

                        // 將立方體加入場景中
                        scene.add(cube);

                        // 在 array 中保存立方體的引用
                        cubes[i][j][k] = cube;
                    }
                }
            }

            rowProxDataX = new Array(numX);
            for(i = 0; i < numX; i++) {
                rowProxDataX[i] = new Array(numX);
                for(j = 0; j < numX; j++) {
                    rowProxDataX[i][j] = 0;
                }
            }

            rowProxDataY = new Array(numY);
            for(i = 0; i < numY; i++) {
                rowProxDataY[i] = new Array(numY);
                for(j = 0; j < numY; j++) {
                    rowProxDataY[i][j] = 0;
                }
            }

            rowProxDataZ = new Array(numZ);
            for(i = 0; i < numZ; i++) {
                rowProxDataZ[i] = new Array(numZ);
                for(j = 0; j < numZ; j++) {
                    rowProxDataZ[i][j] = 0;
                }
            }

            // 取得更新後之 indices  
            //var currentXSortOrder = document.getElementById('sortXOrderSelect').value;
            //var currentYSortOrder = document.getElementById('sortYOrderSelect').value;
            //var currentZSortOrder = document.getElementById('sortZOrderSelect').value;

            //updateXOrder(currentXSortOrder);
            //updateYOrder(currentYSortOrder);
            //updateZOrder(currentZSortOrder);
            now_sortXOrderSelect = document.getElementById('sortXOrderSelect').value;
            now_sortYOrderSelect = document.getElementById('sortYOrderSelect').value;
            now_sortZOrderSelect = document.getElementById('sortZOrderSelect').value;
            updateXOrder();
            updateYOrder();
            updateZOrder();

            // 調用該函數，並根據目前 indices 映射顏色
            applyChangesBasedOnNewIndices();

            // 調用此函數以設定初始預設相機位置
            setDefaultCameraPosition();

            isDataLoaded = true; // 資料處理完成，允許更新軸線
        }

        var isDataLoaded = false; // 初始時 資料未載入 (for updateAxesAndLabelByCamera)

        // 創建 OrbitControls 讓使用者能夠操作 3D 圖形
        var controls = new OrbitControls(camera, renderer.domElement);

        // 設定相機的預設位置和焦點
        function setDefaultCameraPosition() {
            maxDimension = Math.max(numX, numY, numZ); // 找到最大的維度
            distance = Math.round(maxDimension * 1 / 3 + 1.5); // 設定相機距離

            camera.position.set(distance, distance, distance); // 設置相機位置
            camera.lookAt(new THREE.Vector3(numX * cubeSizeX / 2, numY * cubeSizeY / 2, numZ * cubeSizeZ / 2)); // 設定焦點點

            // 更新 OrbitControls 以符合新的相機位置
            controls.update();

            // 重新渲染場景
            renderer.render(scene, camera);
        }

        // Reset camera to default
        document.getElementById('resetCameraIcon').addEventListener('click', function() {
            setDefaultCameraPosition();
        });

        // Pan
        document.getElementById('panCheckBox').addEventListener('change', function(event) {
            if (event.target.checked) {
                // 當勾選時 禁用旋轉
                controls.enableRotate = false;
            } else {
                // 當勾選時 允許旋轉
                controls.enableRotate = true;
            }
        });

        // 設定控制相機的參數
        controls.rotateSpeed = .5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 1.8;
        controls.noZoom = false;
        controls.noPan = false;

        // 渲染循環
        function animate() {
            requestAnimationFrame(animate);

            if (isDataLoaded) {
                updateAxesAndLabelByCamera(); // 只有在資料載入後才調用
                // 在立方體創建後添加軸線，且直接與邊長同步縮放
                createOrUpdateAxes(numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ);
                // updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ);
            }
            
            controls.update();
            renderer.render(scene, camera);
            // 設定背景顏色
            renderer.setClearColor(0xFFFFFF, 0); // 參數 1 表示顏色值，參數 2 表示透明度值
        }

        animate();

    </script>

    <style>
        .node circle {
          fill: #fff;
          stroke-width: 1.5px;
        }
        .node {
          font-size: 13px;
        }
        #rowTree .link {
          fill: none;
          stroke-width: 1px;
        }
        .file-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            margin-right: 10px;
            position: relative; /* 為懸停文本定位 */
            margin-left: 22px; /* Space on the left */
        }

        #fileInputLabel {
            /* margin-right: 50px; */
            margin-left: 2px;
            color: black; /* 文字顏色 */
        }

        .navbar-brand {
            display: flex; /* 啟用Flexbox布局 */
            align-items: center; /* 垂直居中對齊所有項目 */
            justify-content: start; /* 從左側開始排列項目 */
        }

        .navbar-brand img,
        .navbar-brand div {
            display: inline-block; /* 確保元素以內聯塊的形式顯示 */
            vertical-align: middle; /* 垂直居中 */
        }

        .side-nav-hide-on-closed {
            display: none; /* 預設隱藏 */
        }

        /* 如果需要，根據側邊導航的狀態調整顯示 */
        .sidebar-closed .side-nav-hide-on-closed {
            display: inline-block; /* 或其他顯示方式 */
        }

        /* 根據需求調整圖片和文字之間的間距 */
        .navbar-brand img + img, /* 第二個圖片和後續元素之間的間距 */
        .navbar-brand img + div { /* 圖片和文字之間的間距 */
            margin-left: 10px; /* 根據需求調整 */
        }

        .navbar-brand {
            display: flex;
            align-items: center;
            justify-content: start;
        }

        .side-nav-show-on-closed {
            width: 20px; /* 使用百分比，如100% */
            height: auto;
        }

        #xAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #yAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #zAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #rowproxX {
            width: 190px; /* Adjust the width as needed */
            height: 1.8em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
        }

        #rowproxY {
            width: 190px; /* Adjust the width as needed */
            height: 1.8em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
        }

        #rowproxZ {
            width: 190px; /* Adjust the width as needed */
            height: 1.8em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
        }

        /* Modify the width of the range input */
        #SliceRange {
            width: 180px; /* or 100% if you want it to be responsive */
        }

        /* Modify the width of the range input */
        #opacityRange {
            width: 160px; /* or 100% if you want it to be responsive */
            /* other styles you want to apply */
        }

        /* Modify the width of the range input */
        #filteropacityRange {
            width: 180px; /* or 100% if you want it to be responsive */
            /* other styles you want to apply */
        }

        /* Adjust the distance between the range input and its value display */
        #opacityValue {
            margin-left: 6px; /* Adjust as needed */
            /* other styles you want to apply */
        }

        #colorSchemeSelect {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #DisplayCondition {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #cubeSizeX {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeY {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeZ {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #hollowSize {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeXValue {
            margin-left: 6px;
        }

        #cubeSizeYValue {
            margin-left: 6px;
        }

        #cubeSizeZValue {
            margin-left: 6px;
        }

        #hollowSizeValue {
            margin-left: 6px;
        }

        #colorbar-container {
            position: fixed; /* 固定位置 */
            right: 50px; /* 距離右邊邊緣的距離 */
            top: 50%; /* 置於畫面垂直中央 */
            transform: translateY(-50%); /* 垂直居中 */
            display: none; /* 初始時不顯示 */
        }

        #colorbar {
            width: 20px; /* colorbar 的寬度 */
            height: 256px; /* colorbar 的高度 */
            border: 1px solid #FFF; /* colorbar 的邊框 */
        }

        #colorbar-min-label,
        #colorbar-max-label {
            position: absolute;
            left: 90%; /* Adjust this value as needed to position labels to the left of the colorbar */
            font-size: 12px; /* font size */
            font-family: Arial, sans-serif; /* font family */
            margin-left: 8px; /* Add some space between the colorbar and the labels */
        }

        #colorbar-max-label {
            bottom: 95%; /* Align with the top of the colorbar */
        }

        #colorbar-min-label {
            top: 95%; /* Align with the bottom of the colorbar */
        }

        /* proximity matrix 之浮動視窗*/
        .floating-window {
            display: none; /* 預設情況下，浮動視窗是不可見的 */
            position: absolute;
            z-index: 1000;
            border: 1px solid rgba(169, 169, 169, 0.5); /* rgba(133, 163, 245, 0.7); /* 為視窗添加 1 像素寬、顏色為淡灰色 (#ddd) 的實線邊框 */
            border-radius: 5px; /* 為邊框添加 5 像素的圓角 使視窗邊緣呈現圓潤的效果 */
            overflow: auto; /* 允許內容超出時新增捲軸 */
            resize: both; /* 允許調整大小 (透過拖曳視窗的右下角來調整其大小) both:寬度和高度都可以調整 */
            background-color: #ffffff; /* 設定實心背景顏色為白色 */
        }

        .window-header {
            padding: 10px; /* 在視窗頭部內部的所有四個方向添加 10 像素的內邊距 以便於內容與邊框之間有一定的間隙 */
            cursor: move; /* 當滑鼠懸停在視窗頭部時，遊標會變成移動圖示 (一個帶有箭頭的十字)，提示使用者此區域可以拖曳 */
            background-color: #F5F5F5; /* 設定視窗頭部的背景顏色為淺灰色 */
            border-bottom: 1px solid #F0F8FF; /* 在視窗頭部的底部添加 1 像素寬、顏色為淡灰色的實線邊框， 視覺上區分頭部與內容區域 */
            height: 40px;
            /* color: #8E8E8E; /* 文字顏色 */
            /* font-weight: bold; /* 加粗文字 */
        }

        .close {
            float: right; /* 使關閉按鈕浮動到其父容器的右側 通常用於視窗頭部的右上角位置 */
            cursor: pointer; /* 當滑鼠懸停在關閉按鈕上時，遊標變為指針，提示使用者此區域是可點擊的 */
        }

        .reset-camera-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;
        }

        #calculationType {
            width: 172px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            margin-bottom: 11px;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #UnionorIntersection {
            width: 172px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            margin-bottom: 14px;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        .reset-Cube-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;

        }

        #sortXOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
        }

        #sortYOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
        }

        #sortZOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
        }

        .label-sortXOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            font-size: 17px;
        }

        .label-sortYOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            font-size: 17px;
        }

        .label-sortZOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            font-size: 17px;
        }

        #Xflip_side {
            width: 125px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            border-radius: 5px;
            margin-right: 2.5px;
        }

        #Yflip_side {
            width: 125px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            border-radius: 5px;
            margin-right: 2.5px;
        }

        #Zflip_side {
            width: 125px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            border-radius: 5px;
        }

        .dropdown-separator {
            border-left: 1px solid #ced4da; /* 分隔線樣式 */
            height: 20px; /* 根據需要調整高度 */
            display: inline-block; /* 使 span 以行內塊級元素顯示 */
            margin: 0 10px; /* 在分隔線兩側新增空間 */
        }

        .chart-container {
            width: 100%; /* 佔滿浮動視窗的寬度 */
            height: 100%; /* 佔滿浮動視窗的高度 */
        }


        #dataProcessingPanel {
            width: 600px; /* 或根据需求调整 */
            height: 650px; /* 根據需要調整高度 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            overflow: auto; /* 允許內容超出時新增捲軸 */
        }

        #dataPreviewTable {
            border-collapse: collapse; /* 折疊邊框，使表格之間的邊框只顯示為一條線 */
            width: 100%; /* 表格寬度 */
            margin-top: 20px; /* 與上方內容的間距 */
            font-size: 13px;
        }

        #dataPreviewTable, #dataPreviewTable th, #dataPreviewTable td {
            border: 1px solid #ddd; /* 設定邊框樣式 */
        }

        #dataPreviewTable th, #dataPreviewTable td {
            text-align: left; /* 單元格內容左對齊 */
            padding: 8px; /* 單元格內邊距 */
        }

        #dataPreviewTable th {
            background-color: #f2f2f2; /* 表頭背景色 */
        }

        .data-information-panel .card {
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .data-information-panel .card-header {
            display: flex;
            align-items: center;
            /* justify-content: space-between; This will put space between the elements */
            padding: 0.75rem 1.25rem;
            background-color: #f7f7f7;
            border-bottom: 1px solid #ccc;
            height: 50px;
            position: relative; /* 使 .arrow 可以相對於這個元素進行定位 */
        }

        .data-information-panel .card-header .panel-title {
            display: flex;
            text-decoration: none;
            color: #4169e1;
            font-weight: bold;
            font-size: 1.25rem; /* Adjust the font size as needed */
            position: absolute;
            padding: 0.5rem 0;
            align-items: center;
            /* justify-content: space-between; This will align "Data Information" to the left and the arrow to the right */
            text-decoration: none;
            width: 100%; /* Ensure the link takes the full width */
            top: 7%;
        }

        .card-header .arrow {
            position: absolute;
            /* margin-left: auto; Pushes the arrow to the right */
            right: 20px; /* Remove this if you are not absolutely positioning the arrow */
            top: 35%;
        }

        .arrow {
            border: solid #A9A9A9;
            border-width: 0 2px 2px 0;
            display: inline-block;
            padding: 3px;
            /* margin-right: 40px; */
        }

        .down {
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
        }

        .up {
            transform: rotate(-135deg);
            -webkit-transform: rotate(-135deg);
        }

        .panel-collapse {
            transition: all 0.4s ease;
        }

        .panel-collapse.collapse {
            display: none;
        }

        .panel-collapse.collapse.show {
            display: block;
        }

        .highlight-color-1 {
            background-color: #b3cde3; /* 藍色 */
        }

        .highlight-color-2 {
            background-color: #ccebc5; /* 綠色 */
        }

        .highlight-color-3 {
            background-color: #ffecb3; /* 黃色 */
        }

        .highlight-color-4 {
            background-color: #bebada; /* 紫色 */
        }

        .highlight-1 { background-color: #ddffff; } /* 藍色 */
        .highlight-2 { background-color: #ddeeff; } /* 藍色 */
        .highlight-3 { background-color: #ddffee; } /* 綠色 */
        .highlight-4 { background-color: #D1EADE; } /* 綠色 */
        .highlight-5 { background-color: #ffffdd; } /* 黃色 */
        .highlight-6 { background-color: #ffffb3; } /* 黃色 */


        /* Specific styles for the OK button */
        #okButton {
            background-color: #4169e1; /* Royal blue background for the OK button */
            color: white;
            font-size: 1.25rem;
            border: none;
            margin-top: 11px;
            /* margin-bottom: 5px; */
            border-radius: 5px;
            width: 50px; /* Width of the button */
            height: 40px; /* Height of the button */
            position: absolute;
            right: 95px;;
        }

        /* Specific styles for the OK button */
        #cancelButton {
            background-color: #b3adad; /* Royal blue background for the OK button */
            color: white;
            font-size: 1.25rem;
            border: none;
            margin-top: 11px;
            border-radius: 5px;
            width: 70px; /* Width of the button */
            height: 40px; /* Height of the button */
            position: absolute;
            right: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 建立 4 個等寬的行 */
            gap: 10px; /* 方框之间的间隙 */
            grid-template-rows: repeat(2, 1fr); /* 建立 2 個等高的列 */
            height: 100%; /* 使容器填滿其父元素 */
            width: 100%;
        }

        .grid-item {
            border: 1px solid #ccc; /* 方框的邊框 */
            border-radius: 5px;
            /* justify-content: space-around; 平均分配空間 */
        }

        .grid-item.large {
            grid-row: span 2 / auto; /* 讓大方框跨越 2 個小方框的位置 (row 方向) */
        }

        .grid-item:nth-child(1) { 
            padding: 10px;
            display: flex;
            flex-direction: column; /* 將子元素排列在垂直方向 */
            justify-content: center; /* 在垂直方向上居中對齊子元素 */
            align-items: flex-start; /* 在水平方向上靠右對齊子元素 */
            height: 100%; /* 確保 .grid-item 的高度充分，來垂直居中 .info-row */
            font-size: 13px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .info-col {
            display: flex;
            justify-content: space-between; /* This will align the first span to the left and the second span to the right */
            align-items: center; /* Vertically center the content */
            width: 100%; /* Use the full width of the parent .grid-item */
        }

        .info-row span, .info-col span {
            white-space: nowrap; /* Prevents the text from wrapping */
        }

        .info-row > span:last-child {
            margin-left: auto; 
        }

        /* If you want to target only the spans inside .info-col */
        .info-col > span:last-child {
            margin-left: auto; /* Push the last span in .info-col to the right */
        }

        .grid-item:nth-child(2) {
            grid-column: span 2 / auto; /* 讓大方框跨越 2 個小方框的位置 (column 方向) */
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
        }

        .dropdown-row-1 {
            display: flex;
            justify-content: center; /* Center the dropdowns horizontally */
            width: 100%; /* Ensure the row takes full width */
            /* margin-bottom: 3px;  Adds space between each row */
        }

        .dropdown-row-2 {
            display: flex;
            justify-content: center; /* Center the dropdowns horizontally */
            width: 100%; /* Ensure the row takes full width */
            /* margin-bottom: 10px; Adds space between each row */
        }

        .dropdown-container {
            display: flex;
            align-items: center; /* Center the label and select horizontally */
            justify-content: center; /* Center children vertically */
        }

        .dropdown-container label {
            margin-right: 5px; /* Space between the label and the dropdown */
            margin-top: 8px;
        }

        #multiSelectX {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #b3cde3;
            margin-right: 15px; /* Adds space between each dropdown container */
        }

        #multiSelectY {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #ccebc5;
        }

        #multiSelectZ {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #ffecb3;
            margin-right: 15px; /* Adds space between each dropdown container */
        }

        #singleSelect {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #bebada;
        }

        .grid-item:nth-child(3) {
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
            padding: 15px;
        }

        .X-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .Y-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .Z-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .value-min {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .value-max {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            /* margin-bottom: 15px; Adds space below the .info-row */
        }

        .X-num span, .Y-num span, .Z-num span, .value-min span, .value-min span {
            white-space: nowrap; /* Prevents the text from wrapping */
        }

        .X-num > span:last-child {
            margin-left: auto; 
        }

        .Y-num > span:last-child {
            margin-left: auto;
        }

        .Z-num > span:last-child {
            margin-left: auto;
        }

        .value-min > span:last-child {
            margin-left: auto;
        }

        .value-max > span:last-child {
            margin-left: auto;
        }

        .grid-item:nth-child(4) {
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
            /* padding: 15px; */
            /* white-space: nowrap; */
        }

        #select1 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddffff;
        }

        #select2 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddeeff;
        }

        .dropdown4-row-1 label, .dropdown4-row-2 label {
            margin-right: 5px;
        }

        .grid-item:nth-child(5) {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 13px;
        }

        #select3 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddffee;
        }

        #select4 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #D1EADE;
        }

        .dropdown5-row-1 label, .dropdown5-row-2 label {
            margin-right: 5px;
        }

        .grid-item:nth-child(6) {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 13px;
        }

        #select5 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ffffdd;
        }

        #select6 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ffffb3;
        }

        .dropdown6-row-1 label, .dropdown6-row-2 label {
            margin-right: 5px;
        }

        .radiowhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 180px;
            margin-top: 10px;
            margin-bottom: 10px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 74px;
            padding: 8px;
        }

        .colorradiowhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* margin-top: 10px; */
            /* margin-bottom: 10px; */
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 275px;
            padding: 8px;
        }

        .colorwhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 169px;
            padding: 8px;
            margin-bottom: 15px;
        }

        .Slicewhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            height: 139px;
            padding: 8px;
            margin-bottom: 15px;
        }

        .filterwhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 182px;
            padding: 8px;
            margin-bottom: 15px;
        }

        #double-slider {
            width: 190px;
            margin-bottom: 35px;
        }

        #double-slider-cubesvalue {
            width: 190px;
            margin-bottom: 35px;
        }

        .ui-slider-handle .ui-slider-value {
            color: #000;
        }

        .ui-slider-value {
            position: absolute;
            top: 25px; /* 根据需要调整位置 */
            font-size: 13px;
            transform: translateX(-50%); /* 置中對齊 */
        }

        .ui-slider-handle {
            width: 20px; /* 手柄的寬度 */
            height: 20px; /* 手柄的高度 */
            border-radius: 10px; /* 圓角的大小 */
        }

        /* 已選取範圍的背景色 */
        .ui-slider .ui-slider-range {
            background: #007bff; /* 藍色背景 */
        }

        .ui-slider {
            border-radius: 10px; /* 圓角的大小 */
        }

        #colorforXproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #colorforYproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #colorforZproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }
        </style>

</head>

<body class="has-sidebar has-fixed-sidebar-and-header">
<!-- Header -->
<header class="header bg-body">
    <nav class="navbar flex-nowrap p-0">
        <div class="navbar-brand-wrapper d-flex align-items-center col-auto">
            <!-- Logo For Mobile View -->
            <!-- <a class="navbar-brand navbar-brand-mobile" href="index.html">
                <img class="img-fluid w-100" src="img/gap.gif">
            </a> -->
            <!-- End Logo For Mobile View -->

            <!-- Logo For Desktop View -->
            <a class="navbar-brand navbar-brand-desktop" href="index.html">
                <img class="side-nav-show-on-closed" src="img/gap.ico">
                <div class="side-nav-hide-on-closed">3D GAP Online <sup>BETA</sup></div>
            </a>
            <!-- End Logo For Desktop View -->
        </div>

        <div class="header-content col px-md-3">
            <div class="d-flex align-items-center">
                <!-- Side Nav Toggle -->
                <a  class="js-side-nav header-invoker d-flex mr-md-2" href="#"
                    data-close-invoker="#sidebarClose"
                    data-target="#sidebar"
                    data-target-wrapper="body">
                    <i class="gd-align-left"></i>
                </a>
                <!-- End Side Nav Toggle -->

                <!-- Order -->
                <label for="sortXOrderSelect" class="label-sortXOrderSelect">Order X</label>
                <select id="sortXOrderSelect">
                    <option value="original_X">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option>
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_X">Random</option> 
                </select>
                <select id="Xflip_side" class="form-control-none form-control-sm" disabled="disabled">
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>

                <span class="dropdown-separator"></span> <!-- 分隔線 -->

                <label for="sortYOrderSelect" class="label-sortYOrderSelect">Order Y</label>
                <select id="sortYOrderSelect">
                    <option value="original_Y">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option>
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_Y">Random</option>
                </select>
                <select id="Yflip_side" class="form-control-none form-control-sm" disabled="disabled">
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>

                <span class="dropdown-separator"></span> <!-- 分隔線 -->

                <label for="sortZOrderSelect" class="label-sortZOrderSelect">Order Z</label>
                <select id="sortZOrderSelect">
                    <option value="original_Z">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option> <!-- <option value="completelinkage" disabled>Complete-Linkage</option> -->
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_Z">Random</option>
                </select>
                <select id="Zflip_side" class="form-control-none form-control-sm" disabled="disabled">
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>
                <!-- End Order -->

                <!-- User Avatar -->
                <!-- <div class="dropdown mx-3 dropdown ml-2">
                    <a id="profileMenuInvoker" class="header-complex-invoker" href="#" aria-controls="profileMenu" aria-haspopup="true" aria-expanded="false" data-unfold-event="click" data-unfold-target="#profileMenu" data-unfold-type="css-animation" data-unfold-duration="300" data-unfold-animation-in="fadeIn" data-unfold-animation-out="fadeOut">
                        img class="avatar rounded-circle mr-md-2" src="#" alt="John Doe"-->
                        <!-- <span class="mr-md-2 avatar-placeholder">J</span>
                        <span class="d-none d-md-block">John Doe</span>
                        <i class="gd-angle-down d-none d-md-block ml-2"></i>
                    </a>

                    <ul id="profileMenu" class="unfold unfold-user unfold-light unfold-top unfold-centered position-absolute pt-2 pb-1 mt-4 unfold-css-animation unfold-hidden fadeOut" aria-labelledby="profileMenuInvoker" style="animation-duration: 300ms;">
                        <li class="unfold-item">
                            <a class="unfold-link d-flex align-items-center text-nowrap" href="#">
                    <span class="unfold-item-icon mr-3">
                      <i class="gd-user"></i>
                    </span>
                                My Profile
                            </a>
                        </li>
                        <li class="unfold-item unfold-item-has-divider">
                            <a class="unfold-link d-flex align-items-center text-nowrap" href="#">
                    <span class="unfold-item-icon mr-3">
                      <i class="gd-power-off"></i>
                    </span>
                                Sign Out
                            </a>
                        </li>
                    </ul>
                </div> -->
                <!-- End User Avatar -->
            </div>
        </div>
    </nav>
</header>
<!-- End Header -->

<main class="main">
    <!-- Sidebar Nav -->
    <aside id="sidebar" class="js-custom-scroll side-nav">
        <ul id="sideNav" class="side-nav-menu side-nav-menu-top-level mb-0">
            <!-- Title -->
            <li class="sidebar-heading h6">DATA</li>
            <!-- End Title -->

            <!-- upload data -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <!-- 資料處理面板 -->
                <div id="dataProcessingPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #ccc; padding: 20px; z-index: 1000;">
                    <div class="data-information-panel">
                        <div class="card">
                            <div class="card-header">
                                <h2 class="panel-title">
                                    Data Information
                                </h2>
                                <a data-toggle="collapse" href="#collapseDataOptions" aria-expanded="true">
                                    <i class="arrow down"></i>
                                </a>
                            </div>
                            <div id="collapseDataOptions" class="panel-collapse collapse show">
                                <div class="card-body">
                                    <div class="grid-container">
                                        <!-- 第一個小方框 -->
                                        <div class="grid-item">
                                            <div class="info-row">
                                                <span>No. Row:</span>
                                                <span id="rowCount"></span>
                                            </div>
                                            <div class="info-col">
                                                <span>No. Col.:</span>
                                                <span id="colCount"></span>
                                            </div>
                                        </div>

                                        <!-- 第二個小方框 -->
                                        <div class="grid-item">
                                            <!-- Dropdowns -->
                                            <div class="dropdown-row-1">
                                                <div class="dropdown-container">
                                                    <label for="multiSelectX">X Col.</label>
                                                    <select id="multiSelectX"></select>
                                                </div>
                                                <div class="dropdown-container">
                                                    <label for="multiSelectY">Y Col.</label>
                                                    <select id="multiSelectY"></select>
                                                </div>
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown-row-2">
                                                <div class="dropdown-container">
                                                    <label for="multiSelectZ">Z Col.</label>
                                                    <select id="multiSelectZ"></select>
                                                </div>
                                                <div class="dropdown-container">
                                                    <label for="singleSelect">Value</label>
                                                    <select id="singleSelect"></select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 一個大方框 (第三個小方框) -->
                                        <div class="grid-item large">
                                            <div class="X-num">
                                                <span>No. X Cat.:</span>
                                                <span id="Xnum"></span>
                                            </div>
                                            <div class="Y-num">
                                                <span>No. Y Cat.:</span>
                                                <span id="Ynum"></span>
                                            </div>
                                            <div class="Z-num">
                                                <span>No. Z Cat.:</span>
                                                <span id="Znum"></span>
                                            </div>
                                            <div class="value-min">
                                                <span>Min.:</span>
                                                <span id="valuemin"></span>
                                            </div>
                                            <div class="value-max">
                                                <span>Max.:</span>
                                                <span id="valuemax"></span>
                                            </div>
                                        </div>

                                        <!-- 第四個小方框 (下排第一個) -->
                                        <div class="grid-item">
                                            <div class="dropdown4-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select1">Xdiscr.</label>
                                                    <select name="select1" id="select1">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown4-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select2">Xconti.</label>
                                                    <select name="select2" id="select2">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 第五個小方框 -->
                                        <div class="grid-item">
                                            <div class="dropdown5-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select3">Ydiscr.</label>
                                                    <select name="select3" id="select3">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown5-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select4">Yconti.</label>
                                                    <select name="select4" id="select4">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 第六個小方框 -->
                                        <div class="grid-item">
                                            <div class="dropdown6-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select5">Zdiscr.</label>
                                                    <select name="select5" id="select5">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown6-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select6">Zconti.</label>
                                                    <select name="select6" id="select6">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                                
                    <!-- 資料預覽的表格 -->
                    <table id="dataPreviewTable">
                        <thead id="dataPreviewHead"></thead>
                        <tbody id="dataPreviewBody"></tbody>
                    </table>

                    <button id="okButton">OK</button>
                    <button id="cancelButton">Cancel</button>

                </div>
                <button id="fileButton" class="file-button">
                    <i class="fa-solid fa-upload"></i>
                </button>

                <!-- 隱藏原始的檔案輸入 -->
                <input type="file" id="fileInput" style="display: none;" />
                <!-- 顯示一個自訂的標籤或按鈕 -->
                <label for="fileInput" id="fileInputLabel" style="cursor: pointer;" class="side-nav-fadeout-on-closed media-body">Import Data</label>
            </li>
            <!-- End upload data -->

            <!-- Filter -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subFilter">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-filter"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Filter</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subFilter -->
                <ul id="subFilter" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="filterwhite-background">
                            <!-- for bar chart -->
                            <label for="calculationType">Aggregation Type</label>
                            <select id="calculationType">
                                <option value="sum">sum</option>
                                <option value="mean">mean</option>
                            </select>
                            <label for="UnionorIntersection">Filter Type</label>
                            <select id="UnionorIntersection">
                                <option value="Union">Union</option>
                                <option value="Intersection">Intersection</option>
                            </select>
                            <br>
                            <button id="resetToOriginalCube" class="reset-Cube-button">
                                <i class="fa-solid fa-arrow-rotate-left"></i>
                            </button>
                            <span>Reset to Original Cube</span>
                        </div>
                        <label for="double-slider">Restricted Display</label>
                        <div>
                            <!-- 新增雙按鈕滑動條的容器 -->
                            <div id="double-slider"></div>
                            <span id="range-info"></span>
                        </div>
                        <label for="double-slider-cubesvalue">Filter Cubes Value</label>
                        <div>
                            <!-- 新增雙按鈕滑動條的容器 -->
                            <div id="double-slider-cubesvalue"></div>
                            <span id="range-cubesvalue"></span>
                        </div> 
                        <label for="filteropacityRange">Filter Cubes Opacity</label>
                        <input type="range" id="filteropacityRange" min="0" max="1" step="0.01" value="0">
                        <span id="filteropacityValue">0</span>
                    </li>
                </ul>
                <!-- End subFilter -->
            </li>
            <!-- End Filter -->

            <!-- Title -->
            <li class="sidebar-heading h6">SETTINGS</li>
            <!-- End Title -->

            <!-- raw MT -->
            <!-- <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subrawMT">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-table"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Raw Data Matrix</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a> -->

                <!-- subraw MT -->
                <!-- <ul id="subrawMT" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="xAxisCate">X-axis</label>
                        <select id="xAxisCate" name="xAxisCate"></select>

                        <label for="yAxisCate">Y-axis</label>
                        <select id="yAxisCate" name="yAxisCate"></select>

                        <label for="zAxisCate">Z-axis</label>
                        <select id="zAxisCate" name="zAxisCate"></select>
                    </li>
                </ul> -->
                <!-- End subraw MT -->
            <!-- </li> -->
            <!-- End raw MT -->

             <!-- Proximity -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subProx">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-gears"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Proximity</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <ul id="subProx" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <!-- <a class="side-nav-menu-link" href="users.html">Open File</a> -->
                        <label for="rowproxX">X Processing</label>
                        <select id="rowproxX" class="form-control form-control-sm">
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                        
                        <label for="rowproxY">Y Processing</label>
                        <select id="rowproxY" class="form-control form-control-sm">
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                    
                        <label for="rowproxZ">Z Processing</label>
                        <select id="rowproxZ" class="form-control form-control-sm">
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                    </li>
                </ul>
                <!-- End Proximity -->
            </li>

            <!-- slice -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subslice">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-clone"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Slices</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subslice -->
                <ul id="subslice" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="Slicewhite-background">
                            <form id="axisSelection">
                                <input type="radio" id="xAxis" name="axis" value="X">
                                <label for="xAxis">X-Slices</label><br>
                                <input type="radio" id="yAxis" name="axis" value="Y">
                                <label for="yAxis">Y-Slices</label><br>
                                <input type="radio" id="zAxis" name="axis" value="Z">
                                <label for="zAxis">Z-Slices</label><br>
                                <input type="radio" id="oAxis" name="axis" value="O" checked>
                                <label for="oAxis">Original Cube</label><br>
                            </form>
                        </div>
                        <label for="SliceRange">Slices Gap</label><br>
                        <input type="range" id="SliceRange" min="1" max="4" step=".1" value="1">
                        <span id="SliceValue">1</span>
                    </li>
                </ul>
                <!-- End subslice -->
            </li>
            <!-- End slice -->

            <!-- Title -->
            <li class="sidebar-heading h6">OPTIONS</li>
            <!-- End Title -->

            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subOpacity">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-paint-roller"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Opacity</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subOpacity -->
                <ul id="subOpacity" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <!-- <a class="side-nav-menu-link" href="users.html">Open File</a> -->
                        <!-- <label for="opacityRange">Opacity：</label> -->
                        <input type="range" id="opacityRange" min="0.01" max="1" step="0.01" value="0.5">
                        <span id="opacityValue">0.5</span>
                    </li>
                    <!-- <li class="side-nav-menu-item">
                        <a class="side-nav-menu-link" href="user-edit.html">Add new</a>
                    </li> -->
                </ul>
                <!-- End subOpacity -->
            </li>

            <!-- colour -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subcolour">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-palette"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Color</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subcolour -->
                <ul id="subcolour" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="colorwhite-background">
                            <label for="colorSchemeSelect">Color Spectrum</label>
                            <select id="colorSchemeSelect">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColors" name="reverseColors">
                            <label for="reverseColors">Reverse</label>
                            <br>
                            <label for="DisplayCondition">Display Condition</label>
                            <select id="DisplayCondition">
                                <option value="RangeMatrix" selected>Range: Cube</option>
                                <option value="RangeX">Range: Col. X</option>
                                <option value="RangeY">Range: Col. Y</option>
                                <option value="RangeZ">Range: Col. Z</option>
                            </select>
                        </div>
                        
                        <!-- <br> -->
                        <div class="colorradiowhite-background">
                            <label for="colorforXproximity">X Proximity Matrix</label>
                            <select id="colorforXproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforX" name="reverseColorforX">
                            <label for="reverseColorforX">Reverse</label>

                            <label for="colorforYproximity">Y Proximity Matrix</label>
                            <select id="colorforYproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforY" name="reverseColorforY">
                            <label for="reverseColorforY">Reverse</label>

                            <label for="colorforZproximity">Z Proximity Matrix</label>
                            <select id="colorforZproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforZ" name="reverseColorforZ">
                            <label for="reverseColorforZ">Reverse</label>
                        </div>
                    </li>
                </ul>
                <!-- End subcolour -->
            </li>
            <!-- End colour -->

            <!-- size -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subsize">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-cubes"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Cube Size</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subsize -->
                <ul id="subsize" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="cubeSizeX">X-axis</label>
                        <br>
                        <input type="range" id="cubeSizeX" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeXValue">1</span>
                        <br>
                        <label for="cubeSizeY">Y-axis</label>
                        <br>
                        <input type="range" id="cubeSizeY" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeYValue">1</span>
                        <br>
                        <label for="cubeSizeZ">Z-axis</label>
                        <br>
                        <input type="range" id="cubeSizeZ" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeZValue">1</span>
                        <br>
                        <label for="hollowSize">Separate Cube</label>
                        <br>
                        <input type="range" id="hollowSize" min="0.1" max="1" value="1" step="0.1">
                        <span id="hollowSizeValue">1</span>
                    </li>
                </ul>
                <!-- End subsize -->
            </li>
            <!-- End size -->

            <!-- Interactive -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subInteractive">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-hand"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Interactive</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subInteractive -->
                <ul id="subInteractive" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <input type="checkbox" id="panCheckBox" name="panControl">
                        <label for="panControl">Pan</label>
                        <br>
                        <input type="checkbox" id="tooltipCheckbox" name="tooltipCheckbox">
                        <label for="tooltipCheckbox">Show Closest Data on Hover</label>
                        <br>
                        <button id="resetCameraIcon" class="reset-camera-button">
                            <i class="fa-solid fa-camera-rotate"></i>
                        </button>
                        <span>Reset Camera to Default</span>
                        <br>
                        <div class="radiowhite-background">
                            <form id="PeorOrCamera">
                                <input type="radio" id="PerspectiveCamera" name="Camera" value="Pe" checked>
                                <label for="PerspectiveCamera">Perspective Camera</label><br>
                                <input type="radio" id="OrthographicCamera" name="Camera" value="Or">
                                <label for="OrthographicCamera">Orthographic Camera</label><br>
                            </form>
                        </div>
                    </li>
                </ul>
                <!-- End subInteractive -->
            </li>
            <!-- End Interactive -->
        </ul>
    </aside>
    <!-- End Sidebar Nav -->

    <div id="threejs-container"></div>
    <div id="tooltip" style="display: none;
                            position: absolute;
                            background-color: white;
                            border: 1px solid #000;
                            padding: 10px;
                            font-size: 12px;
                            font-family: Arial,
                            sans-serif;
                            pointer-events: none;">
    </div>

    <div id="colorbar-container">
        <div id="colorbar-max-label" class="colorbar-label">Max</div>
        <div id="colorbar"></div>
        <div id="colorbar-min-label" class="colorbar-label">Min</div>
    </div>

    <div id="floatingWindowContainer"></div>  <!-- 浮動窗口的容器 -->

    <!-- Footer -->
    <!-- <footer class="small p-3 px-md-4 mt-auto">
        <div class="row justify-content-between">
            <div class="col-lg text-center text-lg-left mb-3 mb-lg-0">
                <ul class="list-dot list-inline mb-0">
                    <li class="list-dot-item list-dot-item-not list-inline-item mr-lg-2"><a class="link-dark" href="#">FAQ</a></li>
                    <li class="list-dot-item list-inline-item mr-lg-2"><a class="link-dark" href="#">Support</a></li>
                    <li class="list-dot-item list-inline-item mr-lg-2"><a class="link-dark" href="#">Contact us</a></li>
                </ul>
            </div>

            <div class="col-lg text-center mb-3 mb-lg-0">
                <ul class="list-inline mb-0">
                    <li class="list-inline-item mx-2"><a class="link-muted" href="#"><i class="gd-twitter-alt"></i></a></li>
                    <li class="list-inline-item mx-2"><a class="link-muted" href="#"><i class="gd-facebook"></i></a></li>
                    <li class="list-inline-item mx-2"><a class="link-muted" href="#"><i class="gd-github"></i></a></li>
                </ul>
            </div>

            <div class="col-lg text-center text-lg-right">
                &copy; 2019 Graindashboard. All Rights Reserved.
            </div>
        </div>
    </footer> -->
    <!-- End Footer -->
</main>
</body>
</html>