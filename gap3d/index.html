<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Title -->
    <title>3D GAP Online Demo</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <!-- Family Font -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Bodoni+Moda:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Encode+Sans:wght@100;300;400;500;550;600;700;800;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Favicon -->
    <!-- <link rel="Shortcut Icon" type="image/x-icon" href="img/gap.ico"/> -->
    <link rel="Shortcut Icon" type="image/x-icon" href="img/cube.png"/> <!-- cube3.ico cube4.png -->

    <!-- awesome icon -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">

    <!-- Template -->
    <link rel="stylesheet" href="public/graindashboard/css/graindashboard.css">

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/colorbrewer.v1.min.js"></script>

    <!-- <script type="module" src="js/color.js"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@4.4.2"></script>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <script type="text/javascript" src="js/dendrogram.js"></script>
    <script type="text/javascript" src="js/seriation.js"></script>
    <!--<script type="text/javascript" src="r2e.js"></script>-->
    <script type="text/javascript" src="js/r2e_wasm.js"></script>
    <!--<script type="text/javascript" src="hctree.js"></script>-->
    <script type="text/javascript" src="js/hctree_wasm.js"></script>
    <script type="text/javascript" src="js/proximity_wasm.js"></script>
    <script src="js/color.js"></script>
    <script src="js/heatmap_class_utility.js"></script>
    <script src="js/heatmap_class.js"></script>
    <link rel="stylesheet" href="css/heatmap.css" />  
    <link rel="stylesheet" href="css/lightbox.css" />
    <script src="js/import_utility.js"></script>
    <script src="js/papaparse.min.js"></script>

    <script src="public/graindashboard/js/graindashboard.js"></script>
    <script src="public/graindashboard/js/graindashboard.vendor.js"></script>
    
    <!--for 雙按鈕滑動條-->
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="//code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

    <script>
        var isDataLoaded = false; // 初始時 資料未載入

        // 全域解析 (上傳) 之資料
        var parsedData;

        // 上傳資料之 columns 數
        var colCount;

        // 全域變數來儲存目前的透明度值
        var currentOpacity = .5; // 初始值為 .5

        // 全域變數 for color scheme
        var currentColorScheme;

        // 全域變數 for reverse color
        var reverse;
        
        var globalMin = 0; // 全域最小值
        var globalMax = 100; // 全域最大值

        // for 變數列表 (table)
        let tbody;

        // 數值滑動調之值
        var doubleslidercubesvalue;

        // 確保這些參數在函數外部被正確定義和更新
        var data_array = [];

        var fieldX, fieldY, fieldZ;

        var selectedValueField;

        var globalvaluedfields; // for tooltip

        var numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ;

        var fontSize;

        var finalFontSize;

        var uniqueX, uniqueY, uniqueZ;

        // 用於儲存所有立方體的 array (初始化為三維 array 的 cubes)
        var cubes = [];

        // for slices
        var selectedAxis;

        // for gap between each slice
        var sliceGap = 1;

        // for X 軸排序
        var Xindices = []; // 用於儲存軸標籤當前 X 軸 index 的 array

        // for Y 軸排序
        var Yindices = []; // 用於儲存軸標籤當前 Y 軸 index 的 array

        // for Z 軸排序
        var Zindices = []; // 用於儲存軸標籤當前 Z 軸 index 的 array

        var displayCondition;

        var cellWidth = 24;

        var cellHeight = 6;

        var rowIsSimilarity = false;

        var firstRunRowTree = true;

        var firstRunColTree = true;

        var gapbwaxisandlabel = 0.08; // 軸與軸標籤之間的距離

        // 定義一個全域變數來追蹤目前最高的 z-index 值 (for 浮動視窗之順序)
        var highestZIndex = 1000;

        var rowProxData1D = [];

        var rowProxDataX = [];
        
        var rowProxDataY = [];

        var rowProxDataZ = [];

        // 定義一個變量，用於儲存目前選取的 proximity 資料 (rowProxDataX Y Z)
        let currentRowProxDataX = null;
        let currentRowProxDataY = null;
        let currentRowProxDataZ = null;

        let allowUpdateSizes = true; // 預設允許修改邊長

        let allowUpdatehollowSizes = true; // 預設允許分開小立方體

        // let updateAxes = true; // 預設為 true 表示允許更新軸線與軸標籤

        // 儲存立方體的透明度狀態 (與 cubes 結構相同)
        let cubesOpacity = [];

        // 用於追蹤已選取的類別 (for bar chart)
        let categoryConditions = new Set();

        // 用於追蹤選中的範圍 (for histogram)
        let rangeConditions = new Set(); // 用於追蹤選中的範圍 (for histogram)

        // 追蹤選取的 bar (for change bar's color of histogram)
        let selectedHistogramBars = new Set();

        let lastClickedRange = null; // 用來追蹤最後一次點擊的範圍，用於切換顯示狀態 (for histogram)

        // for bar chart and histogram
        let isDragging = false;  // 是否正在拖曳
        let dragStartIndex = null;  // 拖曳起始 bar 索引
        let lastValidIndex = null;  // 最後一個有效的 bar 索引

        let matchesCategoryConditions;
        let matchesRangeConditions;

        // 初始化 filteredPositions 為一個空 array (for 取得 cube 的位置)
        let filteredPositions = [];

        // 定義一個 array 來儲存目前的顏色
        const currentCubeColors = [];

        // 結合 filteredPositions 和 currentCubeColors
        let filteredColors = [];

        var gapX;

        var gapY;

        var gapZ;

        // 設置初始值為聯集
        var selectionType = 'Union';

        var calculationType = 'sum';

        var maxDimension; // 找到最大的維度
        
        var distance;

        var newSize = 1;

        var minMaxByUniqueX = {};
        var minMaxByUniqueY = {};
        var minMaxByUniqueZ = {};

        var globalSliderMinforcolor;
        var globalSliderMaxforcolor;

        // 全域變數來保存滑動條的目前值
        var globalSliderMin;
        var globalSliderMax;

        // 全域變數來保存X、Y、Z軸的排序與flipping的方法
        var now_sortXOrderSelect = "";
        var now_sortYOrderSelect = "";
        var now_sortZOrderSelect = "";
        var now_Xflip_side = "";
        var now_Yflip_side = "";
        var now_Zflip_side = "";

        var SliceRange;

        var pancheck;

        var tooltipEnabled;

        var selectedcamera;

        var xd = [];
        var xc = [];
        var yd = [];
        var yc = [];
        var zd = [];
        var zc = [];
        var xd_cate_col = [];
        var yd_cate_col = [];
        var zd_cate_col = [];
        var xd_name = [];
        var xc_name = [];
        var yd_name = [];
        var yc_name = [];
        var zd_name = [];
        var zc_name = [];
        var xd_num = 0;
        var yd_num = 0;
        var zd_num = 0;
        var xc_num = 0;
        var yc_num = 0;
        var zc_num = 0;
    </script>

    <script type="module">
        import Papa from 'https://cdn.skypack.dev/papaparse@5.3.0';
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        // import { TrackballControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/TrackballControls.js';

        $( function() {
            // 初始化雙按鈕滑動條
            $( "#double-slider" ).slider({
                range: true, // 啟用範圍選擇功能
                min: globalMin, // 設定最小值
                max: globalMax, // 設定最大值
                values: [ globalMin, globalMax ], // 設定初始的兩個按鈕位置
                create: function() {
                    // 建立顯示數值的標籤並附加到滑動條
                    var handles = $("#double-slider .ui-slider-handle");
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(0)).text(globalMin.toFixed(1));
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(1)).text(globalMax.toFixed(1));
                },
                slide: function(event, ui) {
                    // 根據滑動值更新步長
                    if (ui.value >= 0 && ui.value <= 1) {
                        $("#double-slider").slider("option", "step", 0.1);
                    } else {
                        $("#double-slider").slider("option", "step", 1);
                    }

                    // 更新按鈕位置顯示的值
                    $(ui.handle).find(".ui-slider-value").text(ui.value.toFixed(1));

                    // 更新全域變數
                    globalSliderMinforcolor = ui.values[0];
                    globalSliderMaxforcolor = ui.values[1];
                    
                    // 每次滑動時更新顏色
                    updateCubeColorsBasedOnSlider(globalSliderMinforcolor, globalSliderMaxforcolor);

                    transferPositionsToDatatable();

                    // 每次滑動時更新表格單元格背景色
                    updateCellColorsBasedOnSlider(globalSliderMinforcolor, globalSliderMaxforcolor);
                }
            });
        });

        // 根據滑動條的值更新立方體顏色
        function updateCubeColorsBasedOnSlider(sliderMin, sliderMax) {
            // 重置 DisplayCondition 下拉式選單回到預設選項 (Range: Cube)
            displayCondition = document.getElementById('DisplayCondition').selectedIndex = 0;

            // for 禁止使用 and 禁止標誌
            var displayConditionforban = document.getElementById('DisplayCondition');

            if (sliderMin != globalMin || sliderMax != globalMax) {
                // 禁止使用 displayCondition 並顯示禁止標誌
                displayConditionforban.disabled = true;
                displayConditionforban.style.cursor = 'not-allowed';
            } else {
                // 恢復使用 displayCondition 並顯示正常標誌
                displayConditionforban.disabled = false;
                displayConditionforban.style.cursor = 'auto';
            }
            
            reverse = document.getElementById('reverseColors').checked; // 取得 reverseColors 的狀態

            // 遍歷現有的 cubes 並更新顏色
            for (let i = 0; i < Xindices.length; i++) {
                for (let j = 0; j < Yindices.length; j++) {
                    for (let k = 0; k < Zindices.length; k++) {
                        // 在立方體已經創建的基礎上進行
                        let cube = cubes[i][j][k]; // 取得現有的立方體

                        if (cube) {
                            // 使用排序後的索引從 data_array 取得值
                            let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                            if (value !== null) {
                                // 獲取當前選擇的顏色方案
                                currentColorScheme = cube.userData.colorScheme || document.getElementById('colorSchemeSelect').value;
                                var colors = colorSchemes[currentColorScheme]; // 根據色彩方案取得顏色數組
                                var minColor = reverse ? colors[colors.length - 1] : colors[0]; // 考慮反轉的最小顏色
                                var maxColor = reverse ? colors[0] : colors[colors.length - 1]; // 考慮反轉的最大顏色
                                let color;

                                // 根據滑動條更新顏色
                                if (value < sliderMin) {
                                    color = minColor;
                                } else if (value > sliderMax) {
                                    color = maxColor;
                                } else {
                                    // 使用 mapValueToColor 函數更新顏色
                                    color = mapValueToColor(value, currentColorScheme, sliderMin, sliderMax);
                                }

                                // 更新立方體的顏色
                                cube.material.color.set(color);
                                cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度

                            } else {
                                cube.material.opacity = 0; // 空值立方體保持完全透明
                            }

                            cube.material.transparent = true;
                            cube.material.needsUpdate = true; // 確保 Three.js 知道需要更新材料

                            // 儲存顏色及位置信息
                            currentCubeColors.push({
                                position: { i, j, k },
                                color: cube.material.color.getStyle(), // 轉換為 CSS 顏色字串
                            });
                        }
                    }
                }
            }
        }

        // 根據滑動條的值更新表格單元格背景色
        function updateCellColorsBasedOnSlider(sliderMin, sliderMax) {
            reverse = document.getElementById('reverseColors').checked; // 取得 reverseColors 的狀態

            if (!tbody) {
                return; // 停止執行
            }

            // 遍歷表格中的每一 row
            const rows = tbody.getElementsByTagName('tr');
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cellValue = row.getElementsByTagName('td')[3]; // 第四個單元格是數值資料

                // 取出數值
                const dataValue = parseFloat(cellValue.textContent);

                // 取得目前選擇的顏色方案
                var colorScheme = document.getElementById('colorSchemeSelect').value;
                var colors = colorSchemes[colorScheme]; // 根據色彩方案取得顏色數組
                var minColor = reverse ? colors[colors.length - 1] : colors[0]; // 考慮反轉的最小顏色
                var maxColor = reverse ? colors[0] : colors[colors.length - 1]; // 考慮反轉的最大顏色

                if (dataValue < sliderMin) {
                    // 值小於滑動條最小值
                    cellValue.style.backgroundColor = `rgba(${minColor.r}, ${minColor.g}, ${minColor.b}, .3)`;
                } else if (dataValue > sliderMax) {
                    // 值大於滑動條最大值
                    cellValue.style.backgroundColor = `rgba(${maxColor.r}, ${maxColor.g}, ${maxColor.b}, .3)`;
                } else {
                    // 取得 THREE.Color 對象
                    var newColorforcell = mapValueToColor(dataValue, colorScheme, sliderMin, sliderMax);

                    // 將 THREE.Color 物件轉換為 CSS rgb 顏色格式
                    var newrgbaColor = `rgba(${Math.floor(newColorforcell.r * 255)}, ${Math.floor(newColorforcell.g * 255)}, ${Math.floor(newColorforcell.b * 255)}, .3)`;

                    // 值在滑動條選擇的範圍內，設定 cell 背景色
                    cellValue.style.backgroundColor = newrgbaColor;
                }
            }
        }

        $( function() {
            // 初始化雙按鈕滑動條
            $( "#double-slider-cubesvalue" ).slider({
                range: true, // 啟用範圍選擇功能
                min: globalMin, // 設定最小值
                max: globalMax, // 設定最大值
                values: [ globalMin, globalMax ], // 設定初始的兩個按鈕位置
                create: function() {
                    // 建立顯示數值的標籤並附加到滑動條
                    var handles = $("#double-slider-cubesvalue .ui-slider-handle");
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(0)).text(globalMin.toFixed(1));
                    $("<span class='ui-slider-value'></span>").appendTo(handles.eq(1)).text(globalMax.toFixed(1));
                },
                slide: function(event, ui) {
                    // 根據滑動值更新步長
                    if (ui.value >= 0 && ui.value <= 1) {
                        $("#double-slider-cubesvalue").slider("option", "step", 0.1);
                    } else {
                        $("#double-slider-cubesvalue").slider("option", "step", 1);
                    }

                    // 更新按鈕位置顯示的值
                    $(ui.handle).find(".ui-slider-value").text(ui.value.toFixed(1));

                    // 更新全域變數
                    globalSliderMin = ui.values[0];
                    globalSliderMax = ui.values[1];

                    // // 更新全域變數
                    // doubleslidercubesvalue = ui.values;
                    // console.log(doubleslidercubesvalue[0], doubleslidercubesvalue[1]);

                    // 每次滑動時更新透明度
                    filterCubes();
                    //updateCubeOpacityBasedOnSlider(globalSliderMin, globalSliderMax);
                }
            });
        });

        // 根據滑動條的值更新立方體的透明度
        /*function updateCubeOpacityBasedOnSlider(sliderMin, sliderMax) {
            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // 更新 filter 掉之 cubes 透明度
            var filteropacityRange = document.getElementById('filteropacityRange');
            var filternewOpacity = parseFloat(filteropacityRange.value);
            //document.getElementById('filteropacityValue').textContent = filternewOpacity;

            cubes.forEach((cubeRow, i) => {
                cubeRow.forEach((cubeColumn, j) => {
                    cubeColumn.forEach((cube, k) => {
                        if (cube) {
                            var value = cube.userData.value; // 立方體的值

                            if (value == null) { // 如果為遺失值，透明度為 0
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                            } 
                            else{
                                if (categoryConditions.size == 0 && rangeConditions.size == 0) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                                    // 非遺失值值立方體根據滑動條更新透明度
                                    if (value < SliderMin || value > SliderMax) {
                                        // 值不在滑動條選擇的範圍內
                                        cube.material.opacity = 0;
                                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                                
                                    } else if (SliderMin <= value <= SliderMax) {
                                        // 值在滑動條選擇的範圍內
                                        cube.material.opacity = newOpacity;
                                        // 追蹤透明度值
                                        cubesOpacity[i][j][k] = cube.material.opacity; 
                                    }
                                }
                                else
                                {   
                                    // 非遺失值值立方體根據滑動條更新透明度
                                    if (value < SliderMin || value > SliderMax) {
                                        // 值不在滑動條選擇的範圍內
                                        cube.material.opacity = 0;
                                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                                
                                    } else if (SliderMin <= value <= SliderMax) {
                                        // 值在滑動條選擇的範圍內
                                        if(matchesCategoryConditions && matchesRangeConditions)
                                            cube.material.opacity = newOpacity;
                                        else
                                            cube.material.opacity = filternewOpacity; 
                                        cubesOpacity[i][j][k] = cube.material.opacity;

                                    }
                                }
                            }
                            cube.material.needsUpdate = true;
                        }
                    });
                });
            });
        }
        */

        // 創建場景
        var scene = new THREE.Scene();

        // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // const frustumSize = 80; // 根據需要調整這個值 (大小差很多)

        // var camera = new THREE.OrthographicCamera(
        //     frustumSize * window.innerWidth / window.innerHeight / -2,
        //     frustumSize * window.innerWidth / window.innerHeight / 2,
        //     frustumSize / 2,
        //     frustumSize / -2,
        //     1,
        //     1000
        // );

        // Function to set up the camera based on the selected option
        function setupInitialCamera() {
            var selectedCamera = document.querySelector('input[name="Camera"]:checked').value;

            // console.log(selectedCamera);

            return PeorOrcamera(selectedCamera);
        }

        // Global variable for the camera
        var camera = setupInitialCamera();

        // 設定相機投影方式 (透視 or 正交)
        function PeorOrcamera(selectedCamera) {
            switch (selectedCamera) {
                case 'Pe':
                    // 創建透視相機
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    break;
                case 'Or':
                    // 設置正交相機
                    const frustumSize = 80; // 根據需要調整這個值 (大小差很多)

                    camera = new THREE.OrthographicCamera(
                        frustumSize * window.innerWidth / window.innerHeight / -2,
                        frustumSize * window.innerWidth / window.innerHeight / 2,
                        frustumSize / 2,
                        frustumSize / -2,
                        1,
                        1000
                    );
                    break;
            }

            return camera; // Return the camera object so it can be used outside this function
        }

        // 偵測 radio 按鈕的變化
        document.getElementById("PeorOrCamera").addEventListener("change", function(event) {
            // 取得選取的軸
            selectedcamera = event.target.value;

            // console.log(selectedcamera);

            // 呼叫 PeorOrcamera 函數，傳入選中的軸
            camera = PeorOrcamera(selectedcamera);

            controls = new OrbitControls(camera, renderer.domElement);

            setDefaultCameraPosition();

            // renderer.render(scene, camera);

            // 設定控制相機的參數
            controls.rotateSpeed = .5;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 1.8;
            controls.noZoom = false;
            controls.noPan = false;

            animate();
        });

        // 創建渲染器
        var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true }); // 消除鋸齒、允許設置透明度

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('threejs-container').appendChild(renderer.domElement);

        // 初始化鼠標頂點
        var closestVertex = new THREE.Vector3();

        // 初始化視角頂點
        var closestVertex_camera = new THREE.Vector3();

        // 設定相機位置，以便我們可以看到對象
        camera.position.z = 5;

        // 提取 data 中所有 column 之唯一值，以創建 data_array
        function getUniqueColumnValues(dataArray, columnName) {
            // 從 dataArray 中提取 columnName 欄位的值
            var columnValues = dataArray.map(function(item) {
                return item[columnName];
            }).filter(function(value) {
                return value !== undefined && value !== null && value !== ""; // 過濾掉 undefined、null 和空字符串
            });
            return Array.from(new Set(columnValues));
        }

        // 創建資料結構
        function createDataArray(X, Y, Z) {
            var array = new Array(X.length);
            for (var i = 0; i < X.length; i++) {
                array[i] = new Array(Y.length);
                for (var j = 0; j < Y.length; j++) {
                    array[i][j] = new Array(Z.length).fill(null);
                }
            }
            return array;
        }

        // 根據所選欄位來填充資料結構
        function fillDataArray(data, dataArray, X, Y, Z, fieldX, fieldY, fieldZ, fieldvalue) {
            data.forEach(function(row) {
                var i = X.indexOf(row[fieldX]);
                var j = Y.indexOf(row[fieldY]);
                var k = Z.indexOf(row[fieldZ]);

                // console.log(i);

                if (i > -1 && j > -1 && k > -1) {
                    var value = parseFloat(row[fieldvalue]); // 使用所選欄位的值
                    dataArray[i][j][k] = isNaN(value) ? null : value;
                }
            });
        }

        // 更新透明度
        function updateOpacity() {
            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // // 更新 filter 掉之 cubes 透明度
            // var filteropacityRange = document.getElementById('filteropacityRange');
            // var filternewOpacity = parseFloat(filteropacityRange.value);
            // document.getElementById('filteropacityValue').textContent = filternewOpacity;

            cubes.forEach((cubeRow, i) => {
                cubeRow.forEach((cubeColumn, j) => {
                    cubeColumn.forEach((cube, k) => {
                        if (cube) {
                            var value = cube.userData.value; // 立方體的值
                            if (value == null) { // 如果為遺失值，透明度為 0
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                            } else if (cubesOpacity[i][j][k] > 0 && categoryConditions.size == 0 && rangeConditions.size == 0 && value != null) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                                // 非遺失值值立方體根據滑動條更新透明度
                                //cube.material.opacity = newOpacity;
                                //cubesOpacity[i][j][k] = newOpacity; // 追蹤透明度值
                                if (value < globalSliderMin || value > globalSliderMax) {
                                    // 值不在滑動條選擇的範圍內
                                    cube.material.opacity = 0;
                                    cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                } else if (globalSliderMin <= value <= globalSliderMax) {
                                    // 值在滑動條選擇的範圍內
                                    cube.material.opacity = newOpacity;
                                    cubesOpacity[i][j][k] = newOpacity; // 追蹤透明度值
                                    //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);
                                }
                            }
                            cube.material.needsUpdate = true;
                        }
                    });
                });
            });
            // 重新渲染場景以應用透明度更改
            // renderer.render(scene, camera);
        }

        // 滑動條值改變時呼叫 filterCubes 函數
        document.getElementById('opacityRange').addEventListener('input', function() {
            currentOpacity = parseFloat(this.value);
            //updateOpacity();
            filterCubes();
        });

        // 滑動條值改變時呼叫 filterCubes 函數
        document.getElementById('filteropacityRange').addEventListener('input', function() {
            filterCubes();
        });

        // 填充下拉式選單選項
        function fillSelectOptions(selectId, options) {
            var select = document.getElementById(selectId);
            select.innerHTML = ''; // 清空現有選項

            // 添加預設選項
            var defaultOption = document.createElement('option');
            defaultOption.value = "null";
            defaultOption.textContent = "-----";
            defaultOption.disabled = true; // 如果你想要這個選項是不可選的
            defaultOption.selected = true; // 讓它成為預設選中的選項
            select.appendChild(defaultOption);

            options.forEach(function(option) {
                var opt = document.createElement('option');
                opt.value = option;
                opt.innerHTML = option;
                select.appendChild(opt);
            });
        }

        // 訪問下拉式選單的選項並獲取其值
        function getSelectedOptions(selectId) {
            var select = document.getElementById(selectId);
            var selectedOptions = Array.from(select.selectedOptions);
            var selectedValues = selectedOptions.map(option => option.value);
            return selectedValues;
        }

        // 更新單選下拉式選單的選項，移除已被複選下拉式選單選中的選項
        function updateSelectOptions(singleSelectId, selectedXId, selectedYId, selectedZId, allOptions) {
            var singleSelect = document.getElementById(singleSelectId);
            var XSelect = document.getElementById(selectedXId);
            var YSelect = document.getElementById(selectedYId);
            var ZSelect = document.getElementById(selectedZId);

            // 取得三個單選下拉式選單中選取的選項值
            var selectedXValue = XSelect.value;
            var selectedYValue = YSelect.value;
            var selectedZValue = ZSelect.value;

            // 篩選出已被選中的選項值
            var selectedValues = [selectedXValue, selectedYValue, selectedZValue].filter(value => value !== "null");

            // 清空單選下拉式選單的選項
            singleSelect.innerHTML = '';

            // 添加預設 "-----" 選項
            var defaultOption = document.createElement('option');
            defaultOption.value = "null";
            defaultOption.textContent = "-----";
            defaultOption.selected = true; // 讓它成為預設選中的選項
            singleSelect.appendChild(defaultOption);

            // 創建並添加其它選項
            allOptions.forEach(function(option) {
                if (!selectedValues.includes(option)) {
                    var opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    singleSelect.appendChild(opt);
                }
            });

            // 預設選項保持選中狀態
            singleSelect.value = "null";
        }

        // // 填充 2d heatmap 之下拉式菜单
        // function fillSelectfor2dheatmap(selectorId, items) {
        //     const select = document.getElementById(selectorId);
        //     items.forEach(item => {
        //         const option = document.createElement('option');
        //         option.value = option.textContent = item;
        //         select.appendChild(option);
        //     });
        // }

        // 找出資料之最小值和最大值
        function findMinMax(data, valueField) {
            var min = Infinity;
            var max = -Infinity;
            data.forEach(function (row) {
                var value = parseFloat(row[valueField]);
                if (!isNaN(value)) {
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            });
            return { min: min, max: max };
        }

        // 正規化資料值
        function normalize(value, min, max) {
            // 防止除以零
            if (max === min) {
                return 0.5; // 或者根據需要返回其他合理的值
            }
            return (value - min) / (max - min);
        }

        // 顏色映射函數
        function mapValueToColor(value, colorScheme, min, max) {
            switch (colorScheme) {
                case 'RdYlGn':
                    return mapValueTocolorSchemes("RdYlGn", value, min, max);
                case 'Blues':
                    return mapValueTocolorSchemes("Blues", value, min, max);
                case 'Reds':
                    return mapValueTocolorSchemes("Reds", value, min, max);
                case 'Greys':
                    return mapValueTocolorSchemes("Greys", value, min, max);
                case 'YlGnBu':
                    return mapValueTocolorSchemes("YlGnBu", value, min, max);
                case 'YlOrRd':
                    return mapValueTocolorSchemes("YlOrRd", value, min, max);
                case 'RdYlBu':
                    return mapValueTocolorSchemes("RdYlBu", value, min, max);
                case 'RdGy':
                    return mapValueTocolorSchemes("RdGy", value, min, max);
                case 'RdBu':
                    return mapValueTocolorSchemes("RdBu", value, min, max);
                case 'PiYG':
                    return mapValueTocolorSchemes("PiYG", value, min, max);
                case 'PRGn':
                    return mapValueTocolorSchemes("PRGn", value, min, max);
                case 'BrBG':
                    return mapValueTocolorSchemes("BrBG", value, min, max);
                case 'PuOr':
                    return mapValueTocolorSchemes("PuOr", value, min, max);
                case 'YlOrBr':
                    return mapValueTocolorSchemes("YlOrBr", value, min, max);
                case 'YlGn':
                    return mapValueTocolorSchemes("YlGn", value, min, max);
                case 'RdPu':
                    return mapValueTocolorSchemes("RdPu", value, min, max);
                case 'Purples':
                    return mapValueTocolorSchemes("Purples", value, min, max);
                case 'PuRd':
                    return mapValueTocolorSchemes("PuRd", value, min, max);
                case 'PuBuGn':
                    return mapValueTocolorSchemes("PuBuGn", value, min, max);
                case 'PuBu':
                    return mapValueTocolorSchemes("PuBu", value, min, max);
                case 'OrRd':
                    return mapValueTocolorSchemes("OrRd", value, min, max);
                case 'Oranges':
                    return mapValueTocolorSchemes("Oranges", value, min, max);
                case 'Greens':
                    return mapValueTocolorSchemes("Greens", value, min, max);
                case 'GnBu':
                    return mapValueTocolorSchemes("GnBu", value, min, max);
                case 'BuPu':
                    return mapValueTocolorSchemes("BuPu", value, min, max);
                case 'BuGn':
                    return mapValueTocolorSchemes("BuGn", value, min, max);
                case 'Spectral':
                    return mapValueTocolorSchemes("Spectral", value, min, max)
                case 'Set3':
                    return mapValueTocolorSchemes("Set3", value, min, max);
                case 'Set2':
                    return mapValueTocolorSchemes("Set2", value, min, max);
                case 'Set1':
                    return mapValueTocolorSchemes("Set1", value, min, max);
                case 'Pastel2':
                    return mapValueTocolorSchemes("Pastel2", value, min, max);
                case 'Pastel1':
                    return mapValueTocolorSchemes("Pastel1", value, min, max);
                case 'Paired':
                    return mapValueTocolorSchemes("Paired", value, min, max);
                case 'Dark2':
                    return mapValueTocolorSchemes("Dark2", value, min, max);
                case 'Accent':
                    return mapValueTocolorSchemes("Accent", value, min, max);
                case 'GAP_Rainbow':
                    return mapValueTocolorSchemes("GAP_Rainbow", value, min, max);
                case 'GAP_Blue_White_Red':
                    return mapValueTocolorSchemes("GAP_Blue_White_Red", value, min, max);
                default:
                    return new THREE.Color(0xffffff); // 預設白色
            }
        }

        // 更新顏色方案
        function updateColorScheme() {
            var colorSchemeSelect = document.getElementById('colorSchemeSelect');
            var selectedColorScheme = colorSchemeSelect.value;

            // 確保 globalMin 和 globalMax 已被定義
            if (typeof globalMin === 'number' && typeof globalMax === 'number') {
                scene.traverse(function (object) {
                    if (object instanceof THREE.Mesh) {
                        var value = object.userData.value;
                        // 確保 value 是有效的數字
                        if (typeof value === 'number' && !isNaN(value)) {
                            object.material.color = mapValueToColor(value, selectedColorScheme, globalMin, globalMax);
                            object.material.needsUpdate = true;
                        }
                    }
                });
            }
        }

        // 定義顏色方案的映射 (colorbrewer)
        const colorSchemes = {
            RdYlGn: ['#D73027', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#D9EF8B', '#A6D96A', '#66BD63', '#1A9850'],
            Blues: ['#EFF3FF', '#C6DBEF', '#9ECAE1', '#6BAED6', '#3182BD', '#08519C'],
            Reds: ['#FFF5F0', '#FEE0D2', '#FCBBA1', '#FC9272', '#FB6A4A', '#EF3B2C', '#CB181D', '#A50F15', '#67000D'],
            Greys: ['#f7f7f7', '#cccccc', '#969696', '#636363', '#252525'],
            YlGnBu: ['#ffffcc', '#a1dab4', '#41b6c4', '#2c7fb8', '#253494'],
            YlOrRd: ['#ffffb2', '#fecc5c', '#fd8d3c', '#f03b20', '#bd0026'],
            RdYlBu: ['#d73027', '#fc8d59', '#fee090', '#e0f3f8', '#91bfdb', '#4575b4'],
            RdGy: ['#ef3b2c', '#fcbba1', '#ffffff', '#bababa', '#878787', '#4d4d4d'],
            RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
            PiYG: ['#d01c8b', '#f1b6da', '#f7f7f7', '#b8e186', '#4dac26'],
            PRGn: ['#762a83', '#af8dc3', '#e7d4e8', '#d9f0d3', '#7fbf7b', '#1b7837'],
            BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
            PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
            dYlGn: ['#D73027', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#D9EF8B', '#A6D96A', '#66BD63', '#1A9850'],
            YlOrBr: ['#FFFFD4', '#FEE391', '#FEC44F', '#FE9929', '#EC7014', '#CC4C02', '#993404', '#662506'],
            YlGn: ['#FFFFCC', '#C7E9C0', '#A1D99B', '#74C476', '#41AB5D', '#238B45', '#006D2C', '#00441B'],
            RdPu: ['#FEEBE2', '#FCC5C0', '#FA9FB5', '#F768A1', '#DD3497', '#AE017E', '#7A0177'],
            Purples: ['#FCFBFD', '#EFEDF5', '#DADAEB', '#BCBDDC', '#9E9AC8', '#807DBA', '#6A51A3', '#54278F', '#3F007D'],
            PuRd: ['#F7F4F9', '#E7E1EF', '#D4B9DA', '#C994C7', '#DF65B0', '#E7298A', '#CE1256', '#980043', '#67001F'],
            PuBuGn: ['#F6EFF7', '#D0D1E6', '#A6BDDB', '#67A9CF', '#3690C0', '#02818A', '#016C59', '#014636'],
            PuBu: ['#F1EEF6', '#D0D1E6', '#A6BDDB', '#74A9CF', '#3690C0', '#0570B0', '#045A8D', '#023858'],
            OrRd: ['#FFF7EC', '#FEE8C8', '#FDD49E', '#FDBB84', '#FC8D59', '#EF6548', '#D7301F', '#B30000', '#7F0000'],
            Oranges: ['#FFF5EB', '#FEE6CE', '#FDD0A2', '#FDAE6B', '#FD8D3C', '#F16913', '#D94801', '#A63603', '#7F2704'],
            Greens: ['#F7FCF5', '#E5F5E0', '#C7E9C0', '#A1D99B', '#74C476', '#41AB5D', '#238B45', '#006D2C', '#00441B'],
            GnBu: ['#F7FCF0', '#E0F3DB', '#CCEBC5', '#A8DDB5', '#7BCCC4', '#4EB3D3', '#2B8CBE', '#0868AC', '#084081'],
            BuPu: ['#EDF8FB', '#BFD3E6', '#9EBCDA', '#8C96C6', '#8C6BB1', '#88419D', '#810F7C', '#4D004B'],
            BuGn: ['#F0F9E8', '#BAE4BC', '#7BCCC4', '#43A2CA', '#0868AC', '#084081'],
            Spectral: ['#D53E4F', '#F46D43', '#FDAE61', '#FEE08B', '#FFFFBF', '#E6F598', '#ABDDA4', '#66C2A5', '#3288BD'],
            Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9'],
            Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
            Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf'],
            Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
            Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec'],
            Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00'],
            Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
            Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
            GAP_Rainbow: ["#00008C", "#004DEB", "#007359", "#66A600", "#B3E600", "#CCF200", "#FFFF00", "#FFE600", "#FFB300", "#FF6600", "#FF0000", "#D90000", "#A60000"],
            GAP_Blue_White_Red: ["#00006B", "#00009E", "#0000BF", "#0000E8", "#2121FF", "#4A4AFF", "#7A7AFF", "#ADADFF", "#E0E0FF", "#FAFAFF", "#FFFAFA", "#FFC7C7", "#FF9494", "#FF6161", "#FF3838", "#FF0000", "#CF0000", "#AD0000", "#850000", "#520000"],
        };

        // 顏色映射函數
        function mapValueTocolorSchemes(schemeName, value, min, max) {
            var colors = colorSchemes[schemeName];
            reverse = document.getElementById('reverseColors').checked; // 檢查 checkbox 是否被勾選
            var normalized = normalize(value, min, max);
            var index = Math.floor(normalized * (colors.length - 1));

            if (reverse) {
                index = colors.length - 1 - index; // 反轉顏色索引
            }

            return new THREE.Color(colors[index]);
        }

        // 根據顏色方案更新 colorbar 的背景，並更新最小值和最大值標籤的內容
        function updateColorbar(colorScheme, min, max, colorbarContainer, colorbar, colorbarMinLabel, colorbarMaxLabel) {
            // 根據顏色方案更新 colorbar 的背景漸變
            var gradient = getColorGradient(colorScheme, 'reverseColors');
            colorbar.style.background = gradient;

            // 顯示 colorbar 容器
            colorbarContainer.style.display = 'block';

            // 更新最小值和最大值標籤的內容
            colorbarMinLabel.textContent = min; // 四捨五入?
            colorbarMaxLabel.textContent = max;
        }

        // 根據顏色方案獲取漸變樣式的函數
        function getColorGradient(colorScheme, reverseid) {
            if(reverseid=="")
                reverse = false;
            else
                reverse = document.getElementById(reverseid).checked; // 檢查 checkbox 是否被選中
            var direction = reverse ? 'to bottom' : 'to top'; // 根據是否反轉來決定漸變方向

            switch (colorScheme) {
                case 'RdYlGn':
                    return `linear-gradient(${direction}, red, yellow, green)`;
                case 'Blues':
                    return `linear-gradient(${direction}, #f7fbff, #4292c6)`;
                case 'Reds':
                    return `linear-gradient(${direction}, #fff5f0, #cb181d)`;
                case 'Greys':
                    return `linear-gradient(${direction}, #f7f7f7, #cccccc, #969696, #636363, #252525)`;
                case 'YlGnBu':
                    return `linear-gradient(${direction}, #ffffcc, #a1dab4, #41b6c4, #2c7fb8, #253494)`;
                case 'YlOrRd':
                    return `linear-gradient(${direction}, #ffffb2, #fecc5c, #fd8d3c, #f03b20, #bd0026)`;
                case 'RdYlBu':
                    return `linear-gradient(${direction}, #d73027, #fc8d59, #fee090, #e0f3f8, #91bfdb, #4575b4)`;
                case 'RdGy':
                    return `linear-gradient(${direction}, #ef3b2c, #fcbba1, #ffffff, #bababa, #878787, #4d4d4d)`;
                case 'RdBu':
                    return `linear-gradient(${direction}, #67001f, #b2182b, #d6604d, #f4a582, #fddbc7, #d1e5f0, #92c5de, #4393c3, #2166ac, #053061)`;
                case 'PiYG':
                    return `linear-gradient(${direction}, #d01c8b, #f1b6da, #f7f7f7, #b8e186, #4dac26)`;
                case 'PRGn':
                    return `linear-gradient(${direction}, #762a83, #af8dc3, #e7d4e8, #d9f0d3, #7fbf7b, #1b7837)`;
                case 'BrBG':
                    return `linear-gradient(${direction}, #543005, #8c510a, #bf812d, #dfc27d, #f6e8c3, #c7eae5, #80cdc1, #35978f, #01665e, #003c30)`;
                case 'PuOr':
                    return `linear-gradient(${direction}, #7f3b08, #b35806, #e08214, #fdb863, #fee0b6, #d8daeb, #b2abd2, #8073ac, #542788, #2d004b)`;
                case 'YlOrBr':
                    return `linear-gradient(${direction}, #FFFFD4, #FEE391, #FEC44F, #FE9929, #EC7014, #CC4C02, #993404, #662506)`;
                case 'YlGn':
                    return `linear-gradient(${direction}, #FFFFCC, #C7E9C0, #A1D99B, #74C476, #41AB5D, #238B45, #006D2C, #00441B)`;
                case 'RdPu':
                    return `linear-gradient(${direction}, #FEEBE2, #FCC5C0, #FA9FB5, #F768A1, #DD3497, #AE017E, #7A0177)`;
                case 'Purples':
                    return `linear-gradient(${direction}, #FCFBFD, #EFEDF5, #DADAEB, #BCBDDC, #9E9AC8, #807DBA, #6A51A3, #54278F, #3F007D)`;
                case 'PuRd':
                    return `linear-gradient(${direction}, #F7F4F9, #E7E1EF, #D4B9DA, #C994C7, #DF65B0, #E7298A, #CE1256, #980043, #67001F)`;
                case 'PuBuGn':
                    return `linear-gradient(${direction}, #F6EFF7, #D0D1E6, #A6BDDB, #67A9CF, #3690C0, #02818A, #016C59, #014636)`;
                case 'PuBu':
                    return `linear-gradient(${direction}, #F1EEF6, #D0D1E6, #A6BDDB, #74A9CF, #3690C0, #0570B0, #045A8D, #023858)`;
                case 'OrRd':
                    return `linear-gradient(${direction}, #FFF7EC, #FEE8C8, #FDD49E, #FDBB84, #FC8D59, #EF6548, #D7301F, #B30000, #7F0000)`;
                case 'Oranges':
                    return `linear-gradient(${direction}, #FFF5EB, #FEE6CE, #FDD0A2, #FDAE6B, #FD8D3C, #F16913, #D94801, #A63603, #7F2704)`;
                case 'Greens':
                    return `linear-gradient(${direction}, #F7FCF5, #E5F5E0, #C7E9C0, #A1D99B, #74C476, #41AB5D, #238B45, #006D2C, #00441B)`;
                case 'GnBu':
                    return `linear-gradient(${direction}, #F7FCF0, #E0F3DB, #CCEBC5, #A8DDB5, #7BCCC4, #4EB3D3, #2B8CBE, #0868AC, #084081)`;
                case 'BuPu':
                    return `linear-gradient(${direction}, #EDF8FB, #BFD3E6, #9EBCDA, #8C96C6, #8C6BB1, #88419D, #810F7C, #4D004B)`;
                case 'BuGn':
                    return `linear-gradient(${direction}, #F0F9E8, #BAE4BC, #7BCCC4, #43A2CA, #0868AC, #084081)`;
                case 'Spectral':
                    return `linear-gradient(${direction}, #D53E4F, #F46D43, #FDAE61, #FEE08B, #FFFFBF, #E6F598, #ABDDA4, #66C2A5, #3288BD)`;
                case 'Set3':
                    return `linear-gradient(${direction}, #8dd3c7, #ffffb3, #bebada)`;
                case 'Set2':
                    return `linear-gradient(${direction}, #66c2a5, #fc8d62, #8da0cb)`;
                case 'Set1':
                    return `linear-gradient(${direction}, #e41a1c, #377eb8, #4daf4a)`;
                case 'Pastel2':
                    return `linear-gradient(${direction}, #b3e2cd, #fdcdac, #cbd5e8)`;
                case 'Pastel1':
                    return `linear-gradient(${direction}, #fbb4ae, #b3cde3, #ccebc5)`;
                case 'Paired':
                    return `linear-gradient(${direction}, #a6cee3, #1f78b4, #b2df8a)`;
                case 'Dark2':
                    return `linear-gradient(${direction}, #1b9e77, #d95f02, #7570b3)`;
                case 'Accent':
                    return `linear-gradient(${direction}, #7fc97f, #beaed4, #fdc086)`;
                case 'GAP_Rainbow':
                    return `linear-gradient(${direction}, #00008C, #004DEB, #007359, #66A600, #B3E600, #CCF200, #FFFF00, #FFE600, #FFB300, #FF6600, #FF0000, #D90000, #A60000)`;
                case 'GAP_Blue_White_Red':
                    return `linear-gradient(${direction}, #00006B, #00009E, #0000BF, #0000E8, #2121FF, #4A4AFF, #7A7AFF, #ADADFF, #E0E0FF, #FAFAFF, #FFFAFA, #FFC7C7, #FF9494, #FF6161, #FF3838, #FF0000, #CF0000, #AD0000, #850000, #520000)`;
                default:
                    return `linear-gradient(${direction}, white, black)`; // 預設漸變
            }
        }

        // colorbar container for cube
        var colorbarContainerforcube = document.getElementById('colorbar-container');
        var colorbarforcube = document.getElementById('colorbar');
        var colorbarMinLabelforcube = document.getElementById('colorbar-min-label');
        var colorbarMaxLabelforcube = document.getElementById('colorbar-max-label');

        // colorbar 在資料載入後才出現
        function updateEverycolorthingBasedOnCurrentSettings() {
            var selectedColorScheme = document.getElementById('colorSchemeSelect').value;
            if (isDataLoaded) { // 只有在資料載入後才調用
                updateColorbar(selectedColorScheme, globalMin, globalMax, colorbarContainerforcube, colorbarforcube, colorbarMinLabelforcube, colorbarMaxLabelforcube);
                // 也更新其他需要根據這些設定變化的元素，例如場景中的物體顏色
                updateColorScheme();
            }
        }

        // 確保在顏色方案發生變化時 updateColorbar 函數能夠根據當前的反轉狀態更新色條
        document.getElementById('colorSchemeSelect').addEventListener('change', function() {
            // 只有在資料載入後才調用
            if (isDataLoaded) {
                updateEverycolorthingBasedOnCurrentSettings();

                applyChangesBasedOnNewIndices(globalvaluedfields);

                filterCubes();
            }
        });

        // reverseColors
        document.getElementById('reverseColors').addEventListener('change', function() {
            // 只有在資料載入後才調用
            if (isDataLoaded) {
                updateEverycolorthingBasedOnCurrentSettings();

                applyChangesBasedOnNewIndices(globalvaluedfields);
                
                filterCubes();
            }
        });

        // X Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforXproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforXproximity").property("value");
            var newCondition = "RangeMatrix";

            gapX.optionTargetDataMap = "rp";
            gapX.rpPaletteReverse = document.getElementById('reverseColorforX').checked;
            gapX.changePalette(newCondition, newPalette, "#windowProxforX_svg");
        });

        // X Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforX').addEventListener('change', function() {
            var newPalette = d3.select("#colorforXproximity").property("value");
            var newCondition = "RangeMatrix";

            gapX.optionTargetDataMap = "rp";
            gapX.rpPaletteReverse = document.getElementById('reverseColorforX').checked;
            gapX.changePalette(newCondition, newPalette, "#windowProxforX_svg");
        });

        // Y Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforYproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforYproximity").property("value");
            var newCondition = "RangeMatrix";

            gapY.optionTargetDataMap = "rp";
            gapY.rpPaletteReverse = document.getElementById('reverseColorforY').checked;
            gapY.changePalette(newCondition, newPalette, "#windowProxforY_svg");
        });

        // Y Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforY').addEventListener('change', function() {
            var newPalette = d3.select("#colorforYproximity").property("value");
            var newCondition = "RangeMatrix";

            gapY.optionTargetDataMap = "rp";
            gapY.rpPaletteReverse = document.getElementById('reverseColorforY').checked;
            gapY.changePalette(newCondition, newPalette, "#windowProxforY_svg");
        });

        // Z Proxiimity Matrix 改變顏色方案
        document.getElementById('colorforZproximity').addEventListener('change', function() {
            var newPalette = d3.select("#colorforZproximity").property("value");
            var newCondition = "RangeMatrix";

            gapZ.optionTargetDataMap = "rp";
            gapZ.rpPaletteReverse = document.getElementById('reverseColorforZ').checked;
            gapZ.changePalette(newCondition, newPalette, "#windowProxforZ_svg");
        });

        // Z Proxiimity Matrix reverseColors
        document.getElementById('reverseColorforZ').addEventListener('change', function() {
            var newPalette = d3.select("#colorforZproximity").property("value");
            var newCondition = "RangeMatrix";

            gapZ.optionTargetDataMap = "rp";
            gapZ.rpPaletteReverse = document.getElementById('reverseColorforZ').checked;
            gapZ.changePalette(newCondition, newPalette, "#windowProxforZ_svg");
        });

        // 更改邊長
        function updateCubeSizesAndPositions() {
            if (!allowUpdateSizes) return; // 如果不允許修改邊長，直接返回

            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value);
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value);
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value);

            // 更新顯示值
            document.getElementById('cubeSizeXValue').textContent = cubeSizeX;
            document.getElementById('cubeSizeYValue').textContent = cubeSizeY;
            document.getElementById('cubeSizeZValue').textContent = cubeSizeZ;

            // ### 禁止分開小立方體
            if (cubeSizeX == 1 && cubeSizeY == 1 && cubeSizeZ == 1) {
                allowUpdatehollowSizes = true; // 確保在 cubeSizeX cubeSizeY cubeSizeZ 皆等於 1 時 能分開小立方體
            } else {
                allowUpdatehollowSizes = false;
            }

            // 停用或啟用滑桿
            hollowSize.disabled = !allowUpdatehollowSizes;

            // 切換禁止鼠標樣式
            if (allowUpdatehollowSizes) {
                hollowSize.style.cursor = 'auto';
            } else {
                hollowSize.style.cursor = 'not-allowed';
            }

            // ### 禁止選擇切片
            // 如果 newSize 不等於 1，禁用 xAxis, yAxis, zAxis 以及 SliceRange
            if (cubeSizeX != 1 || cubeSizeY != 1 || cubeSizeZ != 1) {
                document.getElementById('xAxis').disabled = true;
                document.getElementById('yAxis').disabled = true;
                document.getElementById('zAxis').disabled = true;
                document.getElementById('SliceRange').disabled = true;

                // 顯示禁止標誌
                document.getElementById('xAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="xAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="xAxis"]').style.opacity = '.5';

                document.getElementById('yAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="yAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="yAxis"]').style.opacity = '.5';

                document.getElementById('zAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="zAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="zAxis"]').style.opacity = '.5';

                document.getElementById('SliceRange').style.cursor = 'not-allowed';
            } else {
                // 啟用 xAxis, yAxis, zAxis 以及 SliceRange
                document.getElementById('xAxis').disabled = false;
                document.getElementById('yAxis').disabled = false;
                document.getElementById('zAxis').disabled = false;
                document.getElementById('SliceRange').disabled = false;

                // 恢復正常滑鼠樣式
                document.getElementById('xAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="xAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="xAxis"]').style.opacity = '1';

                document.getElementById('yAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="yAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="yAxis"]').style.opacity = '1';

                document.getElementById('zAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="zAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="zAxis"]').style.opacity = '1';
                document.getElementById('SliceRange').style.cursor = 'auto';
            }

            // 先清除現有的軸線
            clearAxesLines();

            for (let i = 0; i < cubes.length; i++) {
                for (let j = 0; j < cubes[i].length; j++) {
                    for (let k = 0; k < cubes[i][j].length; k++) {
                        let cube = cubes[i][j][k];
                        if (cube) {
                            // 更新立方體的尺寸
                            cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                            // 計算並更新立方體的新位置
                            var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            cube.position.set(posX, posY, posZ);

                            // if (newSize == 1) {
                            //     // 更新立方體的尺寸
                            //     cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                            //     // 計算並更新立方體的新位置
                            //     var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            //     var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            //     var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            //     cube.position.set(posX, posY, posZ);
                            // } else {
                            //     // 調整縮放比例
                            //     // cube.scale.set(newSize, newSize, newSize);

                            //     // 計算並更新立方體的新位置
                            //     var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            //     var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            //     var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                            //     cube.position.set(posX, posY, posZ);
                            // }
                        }
                    }
                }
            }

            // 在立方體創建後添加軸線，且直接與邊長同步縮放
            // updateAxesStartPoint();

            // 呼叫渲染函數來更新場景
            // renderer.render(scene, camera);
        }

        // 為每個滑桿新增事件監聽器
        document.getElementById('cubeSizeX').addEventListener('input', updateCubeSizesAndPositions);
        document.getElementById('cubeSizeY').addEventListener('input', updateCubeSizesAndPositions);
        document.getElementById('cubeSizeZ').addEventListener('input', updateCubeSizesAndPositions);

        // 更新 X, Y, Z 軸邊長之滑桿值顯示
        document.getElementById('cubeSizeX').addEventListener('input', function() {
            // 取得滑動條目前的值
            var value = this.value;
            // 更新顯示目前值的 <span> 元素的內容
            document.getElementById('cubeSizeXValue').textContent = value;
        });

        document.getElementById('cubeSizeY').addEventListener('input', function() {
            var value = this.value;
            document.getElementById('cubeSizeYValue').textContent = value;
        });

        document.getElementById('cubeSizeZ').addEventListener('input', function() {
            var value = this.value;
            document.getElementById('cubeSizeZValue').textContent = value;
        });

        // 更改 X 軸排序
        function updateXOrder() {           
            var XsortOrder = now_sortXOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Xflip_side == "r2e")
                nowFlip = 1;
            else if(now_Xflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Xflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;

            // flip 防呆 (r2e => heatmap_utility.js)
            if (XsortOrder == "r2e" || XsortOrder == "singlelinkage" || XsortOrder == "averagelinkage" || XsortOrder == "completelinkage")
            {
                //$("#Xflip").prop("disabled",false);
                $("#Xflip_side").prop("disabled",false);
            }


            if (XsortOrder === "original_X") {
                // 產生原始排序的 X 軸索引
                var originalXIndices = [...Array(uniqueX.length).keys()]

                // 用原始順序更新 Xindices
                Xindices = originalXIndices;

                if (typeof gapX !== "undefined")
                    if(!gapX.firstRunRowTree)
                        d3.select("#windowProxforX").selectAll("#rowTree").remove();
            } else if (XsortOrder === "random_X") {
                // 產生隨機排序的 X 軸索引
                var randomXIndices = [...Array(uniqueX.length).keys()].sort(() => Math.random() - 0.5);

                // 用隨機順序更新 Xindices
                Xindices = randomXIndices;

                if (typeof gapX !== "undefined")
                    if(!gapX.firstRunRowTree)
                        d3.select("#windowProxforX").selectAll("#rowTree").remove();
            } else if (XsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 X 軸索引                       81 - 89、751 - 752 * 3、dendrogram.js 35, 236
                // runHCTree_3D(sortedTarget, hctType, flipType, nowID, x, y, heatmapId, isSimilarity, axisdatamt, gapTmp)
                var sorted_avg = runHCTree_3D(0, 2, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);

                // 用 averagelinkage 順序更新 Xindices
                Xindices = sorted_avg;
            } else if (XsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 X 軸索引
                var sorted_sin = runHCTree_3D(0, 0, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);
                
                // 用 singlelinkage 順序更新 Xindices
                Xindices = sorted_sin;
            } else if (XsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 X 軸索引
                var sorted_com = runHCTree_3D(0, 1, nowFlip, "rowTree", gapX.row_number*gapX.cellHeight+13, 0, `#windowProxforX`, gapX.rowIsSimilarity, rowProxDataX, gapX);
                
                // 用 completelinkage 順序更新 Xindices
                Xindices = sorted_com;
            }
             else if (XsortOrder === "r2e") {
                if(!gapX.firstRunRowTree)
                    d3.select("#windowProxforX").selectAll("#rowTree").remove();
                if(gapX.row_r2e_order.length>0)
                {
                    Xindices = gapX.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataX, gapX.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapX.row_r2e_order = sorted_r2e;
                    Xindices = sorted_r2e;

                    //$("#Xflip_side option[value='r2e']").prop("disabled",false);   
                    $("#Xflip_side option[value='r2e']").prop("disabled",false);  
                }
                
             }

            if(gapX)
            {
                for(let i=0 ;i< gapX.row_number; i++)
                {
                    gapX.rowCurrentOrder[i] = Xindices[i];
                    gapX.row_output_order_array[i] = gapX.rowCurrentOrder[i];
                }
                gapX.rowOrderId = XsortOrder;
                var windowID = "#windowProxforX";
                gapX.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapX.yc>0)
                    gapX.redrawHeatmap("mv12", gapX.yc_X, 0, 12, windowID); 
                if(gapX.yd>0)
                    gapX.redrawHeatmap("mv11", gapX.yd_X, 0, 11, windowID); 
                gapX.redrawRowLabels(windowID);
            }

            return Xindices;

        }

        // 更改 Y 軸排序
        function updateYOrder() {
            var YsortOrder = now_sortYOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Yflip_side == "r2e")
                nowFlip = 1;
            else if(now_Yflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Yflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;

            // flip 防呆
            if (YsortOrder == "r2e" || YsortOrder == "singlelinkage" || YsortOrder == "averagelinkage" || YsortOrder == "completelinkage")
            {
                //$("#Yflip").prop("disabled",false);
                $("#Yflip_side").prop("disabled",false);
            }

            if (YsortOrder === "original_Y") {
                // 用原始順序更新 Yindices
                var originalYIndices = [...Array(uniqueY.length).keys()];

                // 用原始順序更新 Yindices
                Yindices = originalYIndices;

                if (typeof gapY !== "undefined")
                    if(!gapY.firstRunRowTree)
                        d3.select("#windowProxforY").selectAll("#rowTree").remove();

            } else if (YsortOrder === "random_Y") {
                // 產生隨機排序的 Y 軸索引
                var randomYIndices = [...Array(uniqueY.length).keys()].sort(() => Math.random() - 0.5);

                // 用隨機順序更新 Yindices
                Yindices = randomYIndices;

                if (typeof gapY !== "undefined")
                    if(!gapY.firstRunRowTree)
                        d3.select("#windowProxforY").selectAll("#rowTree").remove();
            } else if (YsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 Y 軸索引
                var sorted_avg = runHCTree_3D(1, 2, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);

                // 用 averagelinkage 順序更新 Yindices
                Yindices = sorted_avg;
            } else if (YsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 Y 軸索引
                var sorted_sin = runHCTree_3D(1, 0, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);
                
                // 用 singlelinkage 順序更新 Yindices
                Yindices = sorted_sin;
            } else if (YsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 Y 軸索引
                //function runHCTree_3D(sortedTarget, hctType, flipType, nowID, x, y, heatmapId, isSimilarity, axisdatamt) 
                var sorted_com = runHCTree_3D(1, 1, nowFlip, "rowTree", gapY.row_number*gapY.cellHeight+13, 0, `#windowProxforY`, gapY.rowIsSimilarity, rowProxDataY, gapY);
                
                // 用 completelinkage 順序更新 Yindices
                Yindices = sorted_com;
            }
            else if (YsortOrder === "r2e") {
                if(!gapY.firstRunRowTree)
                    d3.select("#windowProxforY").selectAll("#rowTree").remove();
                if(gapY.row_r2e_order.length>0)
                {
                    Yindices = gapY.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataY, gapY.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapY.row_r2e_order = sorted_r2e;
                    Yindices = sorted_r2e;

                    $("#Yflip_side option[value='r2e']").prop("disabled",false);  
                }

             }


            if(gapY)
            {
                for(let i=0 ;i< gapY.row_number; i++)
                {
                    gapY.rowCurrentOrder[i] = Yindices[i];
                    gapY.row_output_order_array[i] = gapY.rowCurrentOrder[i];
                }
                gapY.rowOrderId = YsortOrder;
                var windowID = "#windowProxforY";
                gapY.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapY.yc>0)
                    gapY.redrawHeatmap("mv12", gapY.yc_X, 0, 12, windowID); 
                if(gapY.yd>0)
                    gapY.redrawHeatmap("mv11", gapY.yd_X, 0, 11, windowID); 
                gapY.redrawRowLabels(windowID);
            }

            return Yindices;
        } 

        // 更改 Z 軸排序
        function updateZOrder(ZsortOrder) {
            var ZsortOrder = now_sortZOrderSelect;
            var row_number = numX;
            var col_number = numY;

            var nowFlip = 0;
            if(now_Zflip_side == "r2e")
                nowFlip = 1;
            else if(now_Zflip_side  == "uncle")
                nowFlip = 2;
            else if(now_Zflip_side  == "grandpa")
                nowFlip = 3;
            else
                nowFlip = 0;
            
            // flip 防呆
            if (ZsortOrder == "r2e" || ZsortOrder == "singlelinkage" || ZsortOrder == "averagelinkage" || ZsortOrder == "completelinkage")
            {
                // $("#Xflip").prop("disabled",false);
                $("#Zflip_side").prop("disabled",false);
            }

            if (ZsortOrder === "original_Z") {
                // 用原始順序更新 Zindices
                var originalZIndices = [...Array(uniqueZ.length).keys()];

                // 用原始順序更新 Zindices
                Zindices = originalZIndices;

                if (typeof gapZ !== "undefined")
                    if(!gapZ.firstRunRowTree)
                        d3.select("#windowProxforZ").selectAll("#rowTree").remove();
            } else if (ZsortOrder === "random_Z") {
                // 產生隨機排序的 Z 軸索引
                var randomZIndices = [...Array(uniqueZ.length).keys()].sort(() => Math.random() - 0.5);

                // 用原始順序更新 Zindices
                Zindices = randomZIndices;

                if (typeof gapZ !== "undefined")
                    if(!gapZ.firstRunRowTree)
                        d3.select("#windowProxforZ").selectAll("#rowTree").remove();
            } else if (ZsortOrder === "averagelinkage") {
                // 產生 averagelinkage 排序的 Z 軸索引
                var sorted_avg = runHCTree_3D(2, 2, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);

                // 用 averagelinkage 順序更新 Zindices
                Zindices = sorted_avg;
            } else if (ZsortOrder === "singlelinkage") {
                // 產生 singlelinkage 排序的 Z 軸索引
                var sorted_sin = runHCTree_3D(2, 0, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);
                
                // 用 singlelinkage 順序更新 Zindices
                Zindices = sorted_sin;
            } else if (ZsortOrder === "completelinkage") {
                // 產生 completelinkage 排序的 Z 軸索引
                var sorted_com = runHCTree_3D(2, 1, nowFlip, "rowTree", gapZ.row_number*gapZ.cellHeight+13, 0, `#windowProxforZ`, gapZ.rowIsSimilarity, rowProxDataZ, gapZ);
                
                // 用 completelinkage 順序更新 Zindices
                Zindices = sorted_com;
            }
            else if (ZsortOrder === "r2e") {
                if(!gapZ.firstRunRowTree)
                    d3.select("#windowProxforZ").selectAll("#rowTree").remove();
                if(gapZ.row_r2e_order.length>0)
                {
                    Zindices = gapZ.row_r2e_order;
                }
                else
                {
                    // 產生 r2e 排序的 X 軸索引
                    var sorted_r2e = runR2E(0, rowProxDataZ, gapZ.row_number).slice();
                    
                     // 用 r2e 順序更新 Xindices
                    gapZ.row_r2e_order = sorted_r2e;
                    Zindices = sorted_r2e;

                    $("#Zflip_side option[value='r2e']").prop("disabled",false);  
                }

             }

            if(gapZ)
            {
                for(let i=0 ;i< gapZ.row_number; i++)
                {
                    gapZ.rowCurrentOrder[i] = Zindices[i];
                    gapZ.row_output_order_array[i] = gapZ.rowCurrentOrder[i];
                }
                gapZ.rowOrderId = ZsortOrder;
                var windowID = "#windowProxforZ";
                gapZ.redrawHeatmap("mv2", 0, 0, 1, windowID);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                if(gapZ.yc>0)
                    gapZ.redrawHeatmap("mv12", gapZ.yc_X, 0, 12, windowID); 
                if(gapZ.yd>0)
                    gapZ.redrawHeatmap("mv11", gapZ.yd_X, 0, 11, windowID); 
                gapZ.redrawRowLabels(windowID);
            }

            return Zindices;
        }

        // 依據更新後的 indices 重新映射 cube 之顏色
        function applyChangesBasedOnNewIndices(fieldvalue) {
            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value);
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value);
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value);

            // 取得目前選擇的欄位 value
            // selectedValueField = document.getElementById('singleSelect').value;

            // 從 DOM 取得目前選取的 displayCondition
            displayCondition = document.getElementById('DisplayCondition').value;

            // 清空目前顏色 array
            currentCubeColors.length = 0;

            if (displayCondition === 'RangeX') {
                for (let i = 0; i < Xindices.length; i++) {
                    let uniqueValue = uniqueX[Xindices[i]]; // 取得目前 uniqueX 類別的值
                    let minMax = minMaxByUniqueX[uniqueValue]; // 取得這個類別的最小值和最大值

                    for (let j = 0; j < Yindices.length; j++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            let cube = cubes[i][j][k]; // 取得現有的立方體
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    // 獲取當前選擇的顏色方案
                                    currentColorScheme = document.getElementById('colorSchemeSelect').value;

                                    // 使用目前類別的最小值和最大值來對應顏色
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0; // 空值立方体保持完全透明
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;

                                // 更新立方體材料的顏色
                                cube.material.color.set(color);

                                // 儲存顏色資料值和顏色方案，即使是透明的立方體也這樣做，以便保持資訊的完整性
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;

                                // 儲存顏色及位置資訊
                                currentCubeColors.push({
                                    position: { i, j, k },
                                    color: cube.material.color.getStyle(), // 轉換為 CSS 顏色字串
                                });
                            }
                        }
                    }
                }
            } else if (displayCondition === 'RangeY') {
                for (let j = 0; j < Yindices.length; j++) {
                    let uniqueValue = uniqueY[Yindices[j]];
                    let minMax = minMaxByUniqueY[uniqueValue];

                    for (let i = 0; i < Xindices.length; i++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            let cube = cubes[i][j][k];
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0;
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;
                                cube.material.color.set(color);

                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;

                                // 儲存顏色及位置資訊
                                currentCubeColors.push({
                                    position: { i, j, k },
                                    color: cube.material.color.getStyle(), // 轉換為 CSS 顏色字串
                                });
                            }
                        }
                    }
                }
            } else if (displayCondition === 'RangeZ') {
                for (let k = 0; k < Zindices.length; k++) {
                    let uniqueValue = uniqueZ[Zindices[k]];
                    let minMax = minMaxByUniqueZ[uniqueValue];

                    for (let i = 0; i < Xindices.length; i++) {
                        for (let j = 0; j < Yindices.length; j++) {
                            let cube = cubes[i][j][k];
                            if (cube) {
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                if (value !== null) {
                                    currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    var color = mapValueToColor(value, currentColorScheme, minMax.min, minMax.max);

                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0;
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;
                                cube.material.color.set(color);

                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;

                                // 儲存顏色及位置資訊
                                currentCubeColors.push({
                                    position: { i, j, k },
                                    color: cube.material.color.getStyle(), // 轉換為 CSS 顏色字串
                                });
                            }
                        }
                    }
                }
            } else {
                // 遍歷現有的 cubes 並更新顏色
                for (let i = 0; i < Xindices.length; i++) {
                    for (let j = 0; j < Yindices.length; j++) {
                        for (let k = 0; k < Zindices.length; k++) {
                            // 在立方體已經創建的基礎上進行
                            let cube = cubes[i][j][k]; // 取得現有的立方體

                            if (cube) {
                                // 使用排序後的索引從 data_array 取得值
                                let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                                let color;

                                if (value !== null) {
                                    // 獲取當前選擇的顏色方案
                                    currentColorScheme = document.getElementById('colorSchemeSelect').value;
                                    // 使用 mapValueToColor 函數和正規化後的值來設置立方體的顏色
                                    color = mapValueToColor(value, currentColorScheme, globalMin, globalMax);

                                    // 使用全域透明度變數
                                    // cube.material.opacity = currentOpacity;
                                    cube.material.opacity = cubesOpacity[i][j][k]; // 透明度更新為目前透明度
                                } else {
                                    cube.material.opacity = 0; // 空值立方體保持完全透明
                                }

                                cubesOpacity[i][j][k] = cube.material.opacity;

                                // 更新立方體材料的顏色
                                cube.material.color.set(color);

                                // 儲存顏色資料值和顏色方案，即使是透明的立方體也這樣做，以便保持資訊的完整性
                                cube.userData.value = value;
                                cube.userData.colorScheme = currentColorScheme;

                                cube.userData.tooltipText = fieldX + "：" + uniqueX[Xindices[i]] + "<br>" +
                                    fieldY + "：" + uniqueY[Yindices[j]] + "<br>" +
                                    fieldZ + "：" + uniqueZ[Zindices[k]] + "<br>" +
                                    fieldvalue + "：" + value; // 存儲懸浮提示文本

                                cube.material.transparent = true;
                                cube.material.needsUpdate = true; // 確保 Three.js 知道需要更新材料

                                // 儲存顏色及位置資訊
                                currentCubeColors.push({
                                    position: { i, j, k },
                                    color: cube.material.color.getStyle(), // 轉換為 CSS 顏色字串
                                });
                            }
                        }
                    }
                }
                updateCubeColorsBasedOnSlider(globalSliderMinforcolor, globalSliderMaxforcolor);
            }
            // 在立方體創建後更新 colorbar
            updateColorbar(currentColorScheme, globalMin, globalMax, colorbarContainerforcube, colorbarforcube, colorbarMinLabelforcube, colorbarMaxLabelforcube);

            // // currentCubeColors 包含了所有當前顏色
            // console.log('Current Cube Colors:', currentCubeColors);
        }
        
        // 為 display Condition 下拉式選單新增事件監聽器
        document.getElementById('DisplayCondition').addEventListener('change', function() {
            // 只有在資料載入後才調用
            if (isDataLoaded) {
            // clearbar();

            if (this.value != 'RangeMatrix') {
                // 停用滑動條並顯示禁止標誌
                $("#double-slider").slider("disable"); // 禁用滑動條
                $("#double-slider").css("cursor", "not-allowed !important"); // 顯示禁止滑鼠樣式
            } else {
                // 恢復滑動條啟用狀態
                $("#double-slider").slider("enable");
                $("#double-slider").css("cursor", "pointer"); // 滑動條的正常滑鼠樣式
            }

            // 重置滑動條到初始位置
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示
            var handles = $("#double-slider .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            // 更新全域變數
            globalSliderMinforcolor = globalMin;
            globalSliderMaxforcolor = globalMax;

            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();
            }
        });

        // 為 X 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortXOrderSelect').addEventListener('change', function() {
            var previousOrderIsR2E = false;
            if(now_sortXOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortXOrderSelect = this.value;

            if (now_sortXOrderSelect == "singlelinkage" || now_sortXOrderSelect == "averagelinkage" || now_sortXOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Xflip_side").prop('selectedIndex', 1);
                    now_Xflip_side = "r2e";
                }
            }
            else if(now_sortXOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Xflip_side").prop('selectedIndex', 0); 
                now_Xflip_side = "null";
            }
            else if(now_sortXOrderSelect == "original_X")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Xflip_side").prop('selectedIndex', 0); 
                now_Xflip_side = "null";
            }
        
            updateXOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();
            
            let chartDataX= calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            //console.log(chartDataX);
            updateBarChart('chartX', chartDataX, 'X');
        });

        // 為 Y 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortYOrderSelect').addEventListener('change', function() {

            var previousOrderIsR2E = false;
            if(now_sortYOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortYOrderSelect = this.value;

            if (now_sortYOrderSelect == "singlelinkage" || now_sortYOrderSelect == "averagelinkage" || now_sortYOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Yflip_side").prop('selectedIndex', 1);
                    now_Yflip_side = "r2e";
                }
            }
            else if(now_sortYOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Yflip_side").prop('selectedIndex', 0); 
                now_Yflip_side = "null";
            }
            else if(now_sortYOrderSelect == "original_Y")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Yflip_side").prop('selectedIndex', 0); 
                now_Yflip_side = "null";
            }

            updateYOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            // console.log(Yindices);
            // console.log(chartDataY);
            updateBarChart('chartY', chartDataY, 'Y');
        });

        // 為 Z 軸排序下拉式選單新增事件監聽器
        document.getElementById('sortZOrderSelect').addEventListener('change', function() {
            var previousOrderIsR2E = false;
            if(now_sortZOrderSelect == "r2e")
                previousOrderIsR2E = true;
            else
                previousOrderIsR2E = false;

            now_sortZOrderSelect = this.value;

            if (now_sortZOrderSelect == "singlelinkage" || now_sortZOrderSelect == "averagelinkage" || now_sortZOrderSelect == "completelinkage") 
            { 
                if(previousOrderIsR2E)
                {
                    //$("#rowflip").prop('selectedIndex', 1);
                    $("#Zflip_side").prop('selectedIndex', 1);
                    now_Zflip_side = "r2e";
                }
            }
            else if(now_sortZOrderSelect == "r2e")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Zflip_side").prop('selectedIndex', 0); 
                now_Zflip_side = "null";
            }
            else if(now_sortZOrderSelect == "original_Z")
            {
                //$("#rowflip").prop('selectedIndex', 0);  
                $("#Zflip_side").prop('selectedIndex', 0); 
                now_Zflip_side = "null";
            }
            updateZOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            // console.log(Zindices);
            // console.log(chartDataZ.results_name);
            // console.log(chartDataZ.results_value);
            updateBarChart('chartZ', chartDataZ, 'Z');
        });

        // 為 X 軸 flip 下拉式選單新增事件監聽器
        document.getElementById('Xflip_side').addEventListener('change', function() {
            now_Xflip_side = this.value;
            updateXOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();

            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            updateBarChart('chartX', chartDataX, 'X');
        });

        // 為 Y 軸 flip 下拉式選單新增事件監聽器
        document.getElementById('Yflip_side').addEventListener('change', function() {
            now_Yflip_side = this.value;
            updateYOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            updateBarChart('chartY', chartDataY, 'Y');
        });

        // 為 Z 軸 flip 下拉式選單新增事件監聽器
        document.getElementById('Zflip_side').addEventListener('change', function() {
            now_Zflip_side = this.value;
            updateZOrder();
            applyChangesBasedOnNewIndices(globalvaluedfields);

            filterCubes();

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            updateBarChart('chartZ', chartDataZ, 'Z');
        });

        // 創建一個 Raycaster 物件 (在 Three.js 中 Raycaster 用於計算和偵測射線與場景中物體的相交情況)
        var raycaster = new THREE.Raycaster();

        // 創建一個二維向量 mouse 用來儲存滑鼠在螢幕上的位置
        var mouse = new THREE.Vector2();

        // 監聽滑鼠移動事件 當滑鼠在頁面上移動時，呼叫名為 onMouseMove 的函數
        document.addEventListener('mousemove', onMouseMove, false);

        // 接收一個 event 參數 其中包含了事件的詳細訊息，如：滑鼠的螢幕座標
        function onMouseMove(event) {
            // 將滑鼠位置轉換為歸一化裝置座標 (NDC)
            var rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // // 將滑鼠位置轉換為歸一化裝置座標 (NDC)
            // mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            // mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // 更新射線的起點與方向
            raycaster.setFromCamera(mouse, camera);

            // 射線與物件的交點
            var intersects = raycaster.intersectObjects(cubes.flat().flat(), true);

            // If apply sepaprate cabe, use updateAxesBasedOnCubeCenter; otherwise use updateAxesStartPoint
            if (newSize != 1) {
                updateAxesBasedOnCubeCenter(intersects, cubeSizeX, cubeSizeY, cubeSizeZ);
            } else {
                updateAxesStartPoint(intersects, selectedAxis);
            }

            // 顯示懸浮提示
            showTooltip(event, intersects);
        }

        // 依不同軸線之中心點判斷其 Direction
        function updateAxesDirectionBasedOnVertex(closestVertex) {
            // 計算原始軸線之中心點
            var halfSizeX = numX * cubeSizeX / 2;
            var halfSizeY = numY * cubeSizeY / 2;
            var halfSizeZ = numZ * cubeSizeZ / 2;
            var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);

            // 基於最接近的頂點調整軸線的方向
            var directionX = new THREE.Vector3(1, 0, 0); // X 軸方向
            var directionY = new THREE.Vector3(0, 1, 0); // Y 軸方向
            var directionZ = new THREE.Vector3(0, 0, 1); // Z 軸方向

            // 如果頂點的 X Y Z 座標不等於中心的 X Y Z 座標 翻轉該軸方向
            if (closestVertex.x < 0) {
                directionX.negate(); // 翻轉 X 軸方向
            }
            if (closestVertex.y < 0) {
                directionY.negate(); // 翻轉 Y 軸方向
            }
            if (closestVertex.z < 0) {
                directionZ.negate(); // 翻轉 Z 軸方向
            }

            return [directionX, directionY, directionZ];
        }

        // 依不同軸線之中心點判斷其 Length
        function updateAxesLengthBasedOnVertex(closestVertex) {
            // 計算原始軸線之中心點
            var halfSizeX = numX * cubeSizeX / 2;
            var halfSizeY = numY * cubeSizeY / 2;
            var halfSizeZ = numZ * cubeSizeZ / 2;
            var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);

            // 初始化 axisLengthX、axisLengthY、axisLengthZ
            var axisLengthX = numX * cubeSizeX + .05;
            var axisLengthY = numY * cubeSizeY + .05;
            var axisLengthZ = numZ * cubeSizeZ + .05;

            // 初始化 differenceX、differenceY、differenceZ
            var differenceX = 0;
            var differenceY = 0;
            var differenceZ = 0;

            // 如果頂點的 X Y Z 座標不等於中心的 X Y Z 座標 翻轉該軸方向
            if (closestVertex.x < 0) {
                differenceX = closestVertex.x - center.x;
                axisLengthX = Math.abs(differenceX);
            } else {
                differenceX = closestVertex.x + center.x;
                axisLengthX = Math.abs(differenceX);
            }
            if (closestVertex.y < 0) {
                differenceY = closestVertex.y - center.y;
                axisLengthY = Math.abs(differenceY);
            } else {
                differenceY = closestVertex.y + center.y;
                axisLengthY = Math.abs(differenceY);
            }

            if (closestVertex.z < 0) {
                differenceZ = closestVertex.z - center.z;
                axisLengthZ = Math.abs(differenceZ);
            }else {
                differenceZ = closestVertex.z + center.z;
                axisLengthZ = Math.abs(differenceZ);
            }

            return [axisLengthX, axisLengthY, axisLengthZ];
        }

        // 依照鼠標更新軸線之中心點
        function updateAxesStartPoint(intersects, sliceAxis) {
            // if (!updateAxes) return; // 如果 updateAxes 為 false 則不執行更新

            // 獲取 Checkbox 的狀態
            tooltipEnabled = document.getElementById('tooltipCheckbox').checked;

            // 如果 Checkbox 未被勾選 則清除現有軸線並退出函數
            if (!tooltipEnabled) {
                clearAxesLines();
                return;
            }

            // 移除由 updateAxesBasedOnCubeCenter 創建的軸線
            ['axisX_positive', 'axisX_negative', 'axisY_positive', 'axisY_negative', 'axisZ_positive', 'axisZ_negative'].forEach(function(axisName) {
                var existingAxis = scene.getObjectByName(axisName);
                if (existingAxis) {
                    scene.remove(existingAxis);
                }
            });

            if (intersects.length > 0) {
                var intersect = intersects[0]; // 取第一個交點對象
                var intersectObject = intersect.object; // 取得實際相交的對象

                // 檢查 cube 的透明度是否為 0，如果為 0 則不繪製軸線
                if (intersectObject.material.opacity === 0) {
                    return;
                }

                intersectObject.geometry.computeBoundingBox();

                // 計算大立方體的所有頂點
                var bbox = intersectObject.geometry.boundingBox;

                var vertices = [
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z),
                    new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.max.z),
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.min.z),
                    new THREE.Vector3(bbox.min.x, bbox.max.y, bbox.max.z),
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.min.z),
                    new THREE.Vector3(bbox.max.x, bbox.min.y, bbox.max.z),
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.min.z),
                    new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.max.z)
                ].map(vertex => vertex.applyMatrix4(intersectObject.matrixWorld)); // 轉換到世界座標

                // 找出最接近交點的頂點
                closestVertex = vertices.reduce((closest, vertex) => {
                    return vertex.distanceTo(intersect.point) < closest.distanceTo(intersect.point) ? vertex : closest;
                }, vertices[0]);

                // 計算原始軸線之中心點 (左下)
                var halfSizeX = numX * cubeSizeX / 2;
                var halfSizeY = numY * cubeSizeY / 2;
                var halfSizeZ = numZ * cubeSizeZ / 2;
                var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);

                // 使用更新後之 Direction
                var [directionX, directionY, directionZ] = updateAxesDirectionBasedOnVertex(closestVertex);

                // 使用更新後之 Length
                var [axisLengthX, axisLengthY, axisLengthZ] = updateAxesLengthBasedOnVertex(closestVertex);

                var axesInfo = [
                    { color: "#0f0f0f", direction: directionX, length: axisLengthX, name: 'axisX' },
                    { color: "#0f0f0f", direction: directionY, length: axisLengthY, name: 'axisY' },
                    { color: "#0f0f0f", direction: directionZ, length: axisLengthZ, name: 'axisZ' }
                ];

                axesInfo.forEach(function(info) {
                    // 根據切片的軸 隱藏相對應之軸線
                    if ((sliceAxis === 'X' && info.name === 'axisX') ||
                        (sliceAxis === 'Y' && info.name === 'axisY') ||
                        (sliceAxis === 'Z' && info.name === 'axisZ')) {
                        return; // 跳過當前軸線，不繪製
                    }

                    var points = [closestVertex.clone()];
                    var end = closestVertex.clone().addScaledVector(info.direction, info.length);
                    points.push(end);

                    var geometry = new THREE.BufferGeometry().setFromPoints(points);
                    var material = new THREE.LineBasicMaterial({ color: info.color });
                    var axis = new THREE.Line(geometry, material);
                    axis.name = info.name;

                    var existingAxis = scene.getObjectByName(info.name);
                    if (existingAxis) {
                        scene.remove(existingAxis);
                    }

                    scene.add(axis);
                });
            }
        }

        // 依照鼠標更新軸線之中心點 for separate cubes
        function updateAxesBasedOnCubeCenter(intersects, cubeSizeX, cubeSizeY, cubeSizeZ) {
            // 獲取 Checkbox 的狀態
            const tooltipEnabled = document.getElementById('tooltipCheckbox').checked;

            // 如果 Checkbox 未被勾選 則清除現有軸線並退出函數
            if (!tooltipEnabled) {
                clearAxesLines(); // 清除現有軸線
                return;
            }

            // 移除由 updateAxesStartPoint 創建的軸線
            ['axisX', 'axisY', 'axisZ'].forEach(function(axisName) {
                var existingAxis = scene.getObjectByName(axisName);
                if (existingAxis) {
                    scene.remove(existingAxis);
                }
            });

            // 如果有交點
            if (intersects.length > 0) {
                const intersect = intersects[0]; // 取得第一個交點對象
                const cube = intersect.object; // 取得與鼠標交互的小立方體

                // 檢查 cube 的透明度是否為 0，如果為 0 則不繪製軸線
                if (cube.material.opacity === 0) {
                    return;
                }

                // 計算小立方體的中心點
                const cubeCenter = new THREE.Vector3();
                cube.geometry.computeBoundingBox(); // 計算立方體的包圍盒
                cube.geometry.boundingBox.getCenter(cubeCenter); // 取得中心點
                cubeCenter.applyMatrix4(cube.matrixWorld); // 將中心點轉換為世界座標

                // 計算每個軸線的長度和方向
                var [axisLengthX, axisLengthY, axisLengthZ] = updateAxesLengthBasedOnVertex(cubeCenter);
                var [directionX, directionY, directionZ] = updateAxesDirectionBasedOnVertex(cubeCenter);

                // 計算反方向軸線的長度
                const fullLengthX = numX * cubeSizeX;
                const fullLengthY = numY * cubeSizeY;
                const fullLengthZ = numZ * cubeSizeZ;

                const axisLengthXNegative = fullLengthX - axisLengthX;
                const axisLengthYNegative = fullLengthY - axisLengthY;
                const axisLengthZNegative = fullLengthZ - axisLengthZ;

                // 定義三個方向的軸線，以及它們的反方向
                const axesInfo = [
                    { color: "#0f0f0f", direction: directionX, length: axisLengthX, lengthNegative: axisLengthXNegative, name: 'axisX' },
                    { color: "#0f0f0f", direction: directionY, length: axisLengthY, lengthNegative: axisLengthYNegative, name: 'axisY' },
                    { color: "#0f0f0f", direction: directionZ, length: axisLengthZ, lengthNegative: axisLengthZNegative, name: 'axisZ' }
                ];

                // 遍歷每個軸線，繪製線段，包含正反方向
                axesInfo.forEach(function(info) {
                    // 正方向
                    var pointsPositive = [cubeCenter.clone()];
                    var endPositive = cubeCenter.clone().addScaledVector(info.direction, info.length);
                    pointsPositive.push(endPositive);

                    var geometryPositive = new THREE.BufferGeometry().setFromPoints(pointsPositive);
                    var materialPositive = new THREE.LineBasicMaterial({ color: info.color });
                    var axisPositive = new THREE.Line(geometryPositive, materialPositive);
                    axisPositive.name = info.name + '_positive';

                    // 反方向
                    var pointsNegative = [cubeCenter.clone()];
                    var endNegative = cubeCenter.clone().addScaledVector(info.direction.clone().negate(), info.lengthNegative);
                    pointsNegative.push(endNegative);

                    var geometryNegative = new THREE.BufferGeometry().setFromPoints(pointsNegative);
                    var materialNegative = new THREE.LineBasicMaterial({ color: info.color });
                    var axisNegative = new THREE.Line(geometryNegative, materialNegative);
                    axisNegative.name = info.name + '_negative';

                    // 檢查現有場景中是否已存在相同名稱的軸線，如果有，先移除
                    var existingAxisPositive = scene.getObjectByName(info.name + '_positive');
                    if (existingAxisPositive) {
                        scene.remove(existingAxisPositive);
                    }

                    var existingAxisNegative = scene.getObjectByName(info.name + '_negative');
                    if (existingAxisNegative) {
                        scene.remove(existingAxisNegative);
                    }

                    // 將新的軸線添加到場景
                    scene.add(axisPositive);
                    scene.add(axisNegative);
                });
            }
        }
 
        // 添加軸線 (所有邊)
        function createOrUpdateAxes(numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ) {
            // 取得目前選取的軸
            var selectedAxis = document.querySelector('input[name="axis"]:checked').value;

            // 根據選取的軸 (slices 的 ratio) 設定 邊界中心點到立方體中心的距離
            var halfSizeX = selectedAxis === 'X' ? numX * (cubeSizeX * sliceGap) / 2 : numX * cubeSizeX / 2;
            var halfSizeY = selectedAxis === 'Y' ? numY * (cubeSizeY * sliceGap) / 2 : numY * cubeSizeY / 2;
            var halfSizeZ = selectedAxis === 'Z' ? numZ * (cubeSizeZ * sliceGap) / 2 : numZ * cubeSizeZ / 2;

            // 根據選取的軸 (slices 的 ratio) 計算每個方向上軸線的長度 (根據 cube 之各邊長度)
            var axisLengthX = selectedAxis === 'X' ? numX * (cubeSizeX * sliceGap) + .05 : numX * cubeSizeX + .05;
            var axisLengthY = selectedAxis === 'Y' ? numY * (cubeSizeY * sliceGap) + .05 : numY * cubeSizeY + .05;
            var axisLengthZ = selectedAxis === 'Z' ? numZ * (cubeSizeZ * sliceGap) + .05 : numZ * cubeSizeZ + .05;
            
            // 定義所有 12 個邊的起點與方向
            var edgesInfo = [
                // 四條 X 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX1' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX2' },
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX3' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, halfSizeZ), direction: new THREE.Vector3(1, 0, 0), length: axisLengthX, name: 'edgeX4' },

                // 四條 Y 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY1' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY2' },
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY3' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, halfSizeZ), direction: new THREE.Vector3(0, 1, 0), length: axisLengthY, name: 'edgeY4' },

                // 四條 Z 軸方向的邊
                { start: new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ1' },
                { start: new THREE.Vector3(halfSizeX, -halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ2' },
                { start: new THREE.Vector3(-halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ3' },
                { start: new THREE.Vector3(halfSizeX, halfSizeY, -halfSizeZ), direction: new THREE.Vector3(0, 0, 1), length: axisLengthZ, name: 'edgeZ4' },
            ];

            edgesInfo.forEach(function(edge) {
                var material = new THREE.LineBasicMaterial({ color: "#5C5C5C" });
                var points = [edge.start, new THREE.Vector3().addVectors(edge.start, edge.direction.multiplyScalar(edge.length))];
                var geometry = new THREE.BufferGeometry().setFromPoints(points);
                var axisLine = new THREE.Line(geometry, material);

                // 移除舊的軸線
                var existingEdge = scene.getObjectByName(edge.name);
                if (existingEdge) {
                    scene.remove(existingEdge);
                }

                axisLine.name = edge.name; // 使用唯一的名稱
                scene.add(axisLine);
            });
        }

        // 更新懸浮提示
        function showTooltip(event, intersects) {
            var tooltip = document.getElementById('tooltip');

            // 獲取 Checkbox 的狀態
            tooltipEnabled = document.getElementById('tooltipCheckbox').checked;

            if (!tooltipEnabled) {
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
                return; // 如果 Checkbox 未被勾選 則不顯示懸浮提示並退出函數
            }

            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.setAttribute('id', 'tooltip');
                document.body.appendChild(tooltip);
                // 設置基本樣式
                tooltip.style.position = 'absolute';
                tooltip.style.display = 'none';
                tooltip.style.background = '#fff';
                tooltip.style.border = '1px solid #ddd';
                tooltip.style.padding = '5px';
                tooltip.style.fontSize = '12px';
                tooltip.style.pointerEvents = 'none'; // 確保懸浮提示不會干擾射線檢測
                tooltip.style.background.size = 'cover';
            }

            if (intersects.length > 0) {
                var intersect = intersects[0]; // 取得最近的交點對象
                const cube = intersect.object; // 取得與鼠標交互的小立方體

                // 檢查 cube 的透明度是否為 0，如果為 0 則不繪製軸線
                if (cube.material.opacity === 0) {
                    return;
                }

                if (intersect.object.userData.tooltipText) {
                    tooltip.innerHTML = intersect.object.userData.tooltipText;
                    // 使懸浮提示根據頂點座標改變位置
                    const tooltipWidth = tooltip.offsetWidth; // 懸浮提示的寬度
                    const tooltipHeight = tooltip.offsetHeight; // 懸浮提示的高度

                    // tooltip.style.left = (event.clientX + 15) + 'px'; // 滑鼠右側 15 像素處顯示懸浮提示
                    // tooltip.style.top = (event.clientY + 15) + 'px'; // 滑鼠下方 15 像素處顯示懸浮提示

                    tooltip.style.left = (event.clientX - (tooltipWidth / 2)) + 'px'; // 水平居中於滑鼠
                    tooltip.style.top = (event.clientY - tooltipHeight - 60) + 'px'; // 在滑鼠正上方顯示，距離 10 像素

                    tooltip.style.display = 'block';
                } else {
                    tooltip.style.display = 'none';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        // // 添加軸標籤
        // function createAxisLabel(text, position, size, axisLabelName) {
        //     var canvas = document.createElement('canvas'); // 創建一個新的 HTML <canvas> 元素
        //     var context = canvas.getContext('2d', { willReadFrequently: true }); // 獲取該 <canvas> 元素的 2D 繪圖上下文
            
        //     // 根據需要調整字體大小
        //     var fontSize = parseFloat(document.getElementById('fontSize').value);
        //     // 更新顯示值
        //     document.getElementById('fontSizeValue').textContent = fontSize;
        //     context.clearRect(0, 0, canvas.width, canvas.height);

        //     finalFontSize = 110 - fontSize;

        //     // 設定字體大小為 fontSize 像素，並且選擇字體樣式為 Arial
        //     context.font = `${finalFontSize}px Arial` ;

        //     context.fillStyle = 'rgba(92, 92, 92, 1.0)'; // 文字顏色：深灰色 (完全不透明) #5C5C5C

        //     // 計算文本寬度並根據此來設定 canvas 寬度
        //     var textWidth = context.measureText(text).width;
        //     canvas.width = 1000; // 設定固定的 canvas 寬度
        //     canvas.height = finalFontSize * 2; // 高度足夠容納文本

        //     context.textAlign = 'center'; // 將文本對齊方式：'center' 'right'
        //     context.textBaseline = 'middle'; // 設定文本基線為 'middle'，確保文本垂直居中
        //     context.fillText(text, canvas.width / 2, canvas.height / 2); // 在 <canvas> 上繪製實心的文本

        //     // 從剛才繪製的 <canvas> 創建一個新的 Three.js 材質的貼圖 (texture)
        //     var texture = new THREE.CanvasTexture(canvas);
        //     texture.minFilter = THREE.LinearFilter;
        //     texture.needsUpdate = true;

        //     // 創建一個 SpriteMaterial，它是一種用於創建具有純色或貼圖的矩形平面的材質
        //     var material = new THREE.SpriteMaterial({
        //         map: texture,
        //         depthTest: false // 添加這個屬性禁用深度測試
        //     });

        //     var sprite = new THREE.Sprite(material); // 使用該材質來創建一個 THREE.Sprite
        //     sprite.position.copy(position); // 將 sprite 的位置設定為傳入的 position
        //     sprite.scale.set(size * canvas.width / canvas.height, size, 1); // 調整標籤尺寸
        //     sprite.name = axisLabelName; // 為軸標籤設定一個唯一的名稱

        //     scene.add(sprite);
        // }

        // 繪製軸標籤文本
        function drawText(text, context, canvas, fontSize, fontStyle, fontColor) {
            context.clearRect(0, 0, canvas.width, canvas.height); // 清空畫布

            // 計算文本寬度並根據此來設定 canvas 寬度
            var textWidth = context.measureText(text).width;
            // canvas.width = textWidth + 20; // 根據文字寬度調整 canvas 大小
            canvas.width = 1000; // 設定固定的 canvas 寬度
            canvas.height = fontSize * 2; // 高度足夠容納文本

            context.font = `20px ${fontStyle}`;

            context.fillStyle = fontColor; // 設定顏色
            context.textAlign = 'center'; // 將文本對齊方式：'center' 'right'
            context.textBaseline = 'middle'; // 設定文本基線為 'middle'，確保文本垂直居中
            context.fillText(text, canvas.width / 2, canvas.height / 2); // 在 <canvas> 上繪製實心的文本
        }

        // 添加軸標籤
        function createAxisLabel(text, position, size, axisLabelName) {
            var canvas = document.createElement('canvas'); // 創建一個新的 HTML <canvas> 元素
            var context = canvas.getContext('2d', { willReadFrequently: true }); // 獲取該 <canvas> 元素的 2D 繪圖上下文

            // 根據需要調整字體大小
            var fontSize = parseFloat(document.getElementById('fontSize').value);
            document.getElementById('fontSizeValue').textContent = fontSize; // 更新顯示值

            var finalFontSize = 80 - fontSize;

            // 
            var fontStyle = document.getElementById('fontStyle').value;

            // 根據需要調整字體顏色
            var fontColor = document.getElementById('FontColor').value;

            // 繪製軸標籤文本
            drawText(text, context, canvas, finalFontSize, fontStyle, fontColor);

            // 從剛才繪製的 <canvas> 創建一個新的 Three.js 材質的貼圖 (texture)
            var texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // 創建一個 SpriteMaterial，它是一種用於創建具有純色或貼圖的矩形平面的材質
            var material = new THREE.SpriteMaterial({ map: texture, depthTest: false }); // 添加 depthTest 屬性禁用深度測試
            var sprite = scene.getObjectByName(axisLabelName); // 使用該材質來創建一個 THREE.Sprite

            if (!sprite) {
                sprite = new THREE.Sprite(material);
                sprite.position.copy(position); // 將 sprite 的位置設定為傳入的 position
                sprite.scale.set(size * canvas.width / canvas.height, size, 1); // 調整標籤尺寸
                // sprite.scale.set(size * 2 * canvas.width / canvas.height, size * 2, 1); // 放大 2 倍
                sprite.name = axisLabelName; // 為軸標籤設定一個唯一的名稱
                scene.add(sprite);
            } else {
                sprite.material.map = texture;
                sprite.material.needsUpdate = true;
            }

            // // 監聽顏色選擇器變化，重新繪製文字
            // document.getElementById('FontColor').addEventListener('input', () => {
            //     var newColor = document.getElementById('FontColor').value;
            //     drawText(text, context, canvas, finalFontSize, newColor); // 重新繪製文字
            // });
        }

        // 移除軸標籤 (可只移除一個軸)
        function removeAxisLabels(axis) {
            var removableObjects = [];
            scene.traverse((object) => {
                // 如果沒有指定軸，就檢查名稱是否以 "axisLabel" 開頭
                // 如果指定了軸，就檢查名稱是否以 "axisLabel" + 軸 的形式開頭
                if (object.name && (axis ? object.name.startsWith('axisLabel' + axis) : object.name.startsWith('axisLabel'))) {
                    removableObjects.push(object);
                }
            });
            removableObjects.forEach((object) => {
                scene.remove(object);
            });
        }

        // 根據視角更新軸標籤位置
        function updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ) {
            removeAxisLabels(); // 移除所有現有的軸標籤

            var selectedAxis = document.querySelector('input[name="axis"]:checked').value;

            // 更新 X 軸標籤
            Xindices.forEach((index, i) => {
                let category = uniqueX[index];
                var positionX = selectedAxis === 'X' ? -numX * (cubeSizeX * sliceGap) / 2 + (i * (cubeSizeX * sliceGap)) + ((cubeSizeX * sliceGap) / 2)
                                            : -numX * cubeSizeX / 2 + (i * cubeSizeX) + (cubeSizeX / 2);
                var position = new THREE.Vector3(positionX, -numY * cubeSizeY  / 2 + gapbwaxisandlabel, -numZ * cubeSizeZ / 2 - gapbwaxisandlabel);
                if (closestVertex_camera) { // 如果 closestVertex_camera 已定義 則根據相機位置調整
                    position.y = selectedAxis === 'Y' ? (closestVertex_camera.y > 0 ? 1 : -1) * (numY * (cubeSizeY * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.y > 0 ? 1 : -1) * (numY * cubeSizeY / 2 + gapbwaxisandlabel);
                    position.z = selectedAxis === 'Z' ? (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * (cubeSizeZ  * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * cubeSizeZ / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeX, 'axisLabelX' + index);
            });

            // 更新 Y 軸標籤
            Yindices.forEach((index, i) => {
                let category = uniqueY[index];
                var positionY = selectedAxis === 'Y' ? -numY * (cubeSizeY * sliceGap) / 2 + (i * (cubeSizeY * sliceGap)) + ((cubeSizeY * sliceGap) / 2 + .2)
                                            : -numY * cubeSizeY / 2 + (i * cubeSizeY) + (cubeSizeY / 2 + .2);
                var position = new THREE.Vector3(-numX * cubeSizeX / 2 - gapbwaxisandlabel, positionY, -numZ * cubeSizeZ / 2);
                if (closestVertex_camera) {
                    position.x = selectedAxis === 'X' ? (closestVertex_camera.x > 0 ? 1 : -1) * (numX * (cubeSizeX * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.x > 0 ? 1 : -1) * (numX * cubeSizeX / 2 + gapbwaxisandlabel);
                    position.z = selectedAxis === 'Z' ? (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * (cubeSizeZ * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.z > 0 ? 1 : -1) * (numZ * cubeSizeZ / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeY, 'axisLabelY' + index);
            });

            // 更新 Z 軸標籤
            Zindices.forEach((index, i) => {
                let category = uniqueZ[index];
                var positionZ = selectedAxis === 'Z' ? -numZ * (cubeSizeZ * sliceGap) / 2 + (i * (cubeSizeZ * sliceGap)) + ((cubeSizeZ * sliceGap) / 2)
                                            : -numZ * cubeSizeZ / 2 + (i * cubeSizeZ) + (cubeSizeZ / 2);
                var position = new THREE.Vector3(-numX * cubeSizeX / 2 - gapbwaxisandlabel, -numY * cubeSizeY / 2 + gapbwaxisandlabel, positionZ);
                if (closestVertex_camera) {
                    position.x = selectedAxis === 'X' ? (closestVertex_camera.x > 0 ? 1 : -1) * (numX * (cubeSizeX * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.x > 0 ? 1 : -1) * (numX * cubeSizeX / 2 + gapbwaxisandlabel);
                    position.y = selectedAxis === 'Y' ? (closestVertex_camera.y > 0 ? 1 : -1) * (numY * (cubeSizeY * sliceGap) / 2 + gapbwaxisandlabel)
                                            : (closestVertex_camera.y > 0 ? 1 : -1) * (numY * cubeSizeY / 2 + gapbwaxisandlabel);
                }
                createAxisLabel(category, position, cubeSizeZ, 'axisLabelZ' + index);
            });
        }

        // 清除現有的軸線
        function clearAxesLines() {
            var axes = ['axisX', 'axisY', 'axisZ'];

            axes.forEach(function(axisName) {
                var existingAxis = scene.getObjectByName(axisName);
                if (existingAxis) {
                    scene.remove(existingAxis);
                }
            });
        }

        // 根據視角更新軸線與軸標籤
        function updateAxesAndLabelByCamera() {
            // 計算立方體中心點
            var halfSizeX = numX * cubeSizeX / 2;
            var halfSizeY = numY * cubeSizeY / 2;
            var halfSizeZ = numZ * cubeSizeZ / 2;
            var center = new THREE.Vector3(-halfSizeX, -halfSizeY, -halfSizeZ);
            
            // 計算立方體的 8 個頂點
            var vertices = [
                new THREE.Vector3(center.x, center.y, center.z),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y, center.z),
                new THREE.Vector3(center.x, center.y + numY * cubeSizeY, center.z),
                new THREE.Vector3(center.x, center.y, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y + numY * cubeSizeY, center.z),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x, center.y + numY * cubeSizeY, center.z + numZ * cubeSizeZ),
                new THREE.Vector3(center.x + numX * cubeSizeX, center.y + numY * cubeSizeY, center.z + numZ * cubeSizeZ),
            ];

            // 找出最接近相機的頂點
            var closestVertex_camera;
            var minDistance = Infinity;
            var cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition); // 取得相機的世界位置

            vertices.forEach((vertex) => {
                var distance = vertex.distanceTo(cameraPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestVertex_camera = vertex;
                }
            });

            updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ);
        }

        // 生成二維 array (X * (Y * Z)、Y * (X * Z)、Z * (X * Y))
        function convert3DArrayTo2D(axis) {
            let result = []; // 最終的二維 array
            let header = []; // 用於儲存列標籤
            let rowLabels = []; // 用於儲存行標籤

            if (axis === 'X') {
                // 添加 Z 軸作為列標籤 (X * (Y * Z))
                header.push(''); // 第一個空白單元格作為行標籤和列標籤的交叉點
                for (let j = 0; j < uniqueY.length; j++) {
                    for (let k = 0; k < uniqueZ.length; k++) {
                        header.push(`${uniqueY[j]}-${uniqueZ[k]}`); // Y-Z 標籤
                    }
                }
                result.push(header);

                // 遍歷 X 軸
                for (let i = 0; i < data_array.length; i++) {
                    let row = []; // 用於儲存目前 i 下所有 Y * Z 合併後的資料
                    row.push(uniqueX[i]); // 添加 X 軸標籤作為行標籤

                    // 遍歷 Y 軸
                    for (let j = 0; j < data_array[i].length; j++) {
                        // 遍歷 Z 軸
                        for (let k = 0; k < data_array[i][j].length; k++) {
                            row.push(data_array[i][j][k]); // 將 Y 軸和 Z 軸的資料加入 array 中
                        }
                    }
                    result.push(row); // 將目前 array 新增至結果 array 中
                }
            } else if (axis === 'Y') {
                // 添加 X 和 Z 作為列標籤 (Y * (X * Z))
                header.push('');
                for (let i = 0; i < uniqueX.length; i++) {
                    for (let k = 0; k < uniqueZ.length; k++) {
                        header.push(`${uniqueX[i]}-${uniqueZ[k]}`);
                    }
                }
                result.push(header);

                // 遍歷 Y 軸
                for (let j = 0; j < data_array[0].length; j++) {
                    let row = [];
                    row.push(uniqueY[j]); // 添加 Y 軸標籤作為行標籤

                    // 遍歷 X 軸
                    for (let i = 0; i < data_array.length; i++) {
                        // 遍歷 Z 軸
                        for (let k = 0; k < data_array[i][j].length; k++) {
                            row.push(data_array[i][j][k]);
                        }
                    }
                    result.push(row);
                }
            } else if (axis === 'Z') {
                // 添加 X 和 Y 作為列標籤 (Z * (X * Y))
                header.push('');
                for (let i = 0; i < uniqueX.length; i++) {
                    for (let j = 0; j < uniqueY.length; j++) {
                        header.push(`${uniqueX[i]}-${uniqueY[j]}`);
                    }
                }
                result.push(header);

                // 遍歷 Z 軸
                for (let k = 0; k < data_array[0][0].length; k++) {
                    let row = [];
                    row.push(uniqueZ[k]); // 添加 Z 軸標籤作為行標籤

                    // 遍歷 X 軸
                    for (let i = 0; i < data_array.length; i++) {
                        // 遍歷 Y 軸
                        for (let j = 0; j < data_array[i].length; j++) {
                            row.push(data_array[i][j][k]);
                        }
                    }
                    result.push(row);
                }
            }
            return result;
        }

        // 在頁面載入時停用 color for proximity 的下拉式選單
        document.addEventListener('DOMContentLoaded', function() {
            // 禁用整個下拉選單並顯示禁止標誌
            $("#colorforXproximity").prop('disabled', true).css('cursor', 'not-allowed');
            $("#reverseColorforX").prop('disabled', true).css('cursor', 'not-allowed');
            $("label[for='reverseColorforX']").css({
                'cursor': 'not-allowed',
                'opacity': '.5' // 設置透明度
            });

            $("#colorforYproximity").prop('disabled', true).css('cursor', 'not-allowed');
            $("#reverseColorforY").prop('disabled', true).css('cursor', 'not-allowed');
            $("label[for='reverseColorforY']").css({
                'cursor': 'not-allowed',
                'opacity': '.5' // 設置透明度
            });

            $("#colorforZproximity").prop('disabled', true).css('cursor', 'not-allowed');
            $("#reverseColorforZ").prop('disabled', true).css('cursor', 'not-allowed');
            $("label[for='reverseColorforZ']").css({
                'cursor': 'not-allowed',
                'opacity': '.5' // 設置透明度
            });
        });

        // 為 proxi MT X 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxX').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 0);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                // 設置浮動視窗標題
                var title = `Euclidean Distance of X-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforXproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxX = Math.round(Math.max(...rowProxData1D));
                var minProxX = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `Pearson's Correlation of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxX = 1;
                var minProxX = -1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `Kendall's tau of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxX = 1;
                var minProxX = -1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `Spearman's Rank of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxX = 1;
                var minProxX = -1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `atan Correlation of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxX = 1;
                var minProxX = -1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `City-Block (L1) of X-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforXproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxX = Math.round(Math.max(...rowProxData1D));
                var minProxX = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 0);

                //var windowID = `window${this.value}forX`;
                var windowID = `windowProxforX`;

                var title = `abs(Pearson's Correlation) of X-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforXproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforXproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforXproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxX = 1;
                var minProxX = -1;
            }

            $("label[for='reverseColorforX']").css({
                'cursor': 'default',
                'opacity': '1' // 恢復透明度
            });

            for(let i = 0; i < numX; i++) {
                for(let j = 0; j < numX; j++) {
                    rowProxDataX[i][j] = rowProxData1D[i*numX+j];
                }
            }

            // console.log(rowProxData1D);
            // console.log('rowProxDataX', rowProxDataX);

            // console.log('最大值:', maxProxX);
            // console.log('最小值:', minProxX);

            if (d3.select("#"+windowID).empty()) {

                gapX = new GAP();
                // 取得 RowProx 二維陣列資料
                gapX.rowProxData = rowProxDataX;

                // 設定 row_number
                gapX.row_number = numX;

                let covCount = 0;
                // 設定 yc
                if(xc_num>0)
                {
                    gapX.yc = xc_num;
                    gapX.ycData = xc;
                    gapX.yc_name = xc_name;
                    gapX.yc_X = -10-gapX.yc*gapX.ycov_cellWidth;
                    gapX.compute_yc_minmax();
                    covCount++;
                }
                // 設定 yd
                if(xd_num>0)
                {
                    gapX.yd = xd_num;
                    gapX.ydData = xd;
                    gapX.yd_cate_col = xd_cate_col;
                    gapX.yd_name = xd_name;
                    gapX.yd_X = gapX.yc_X -10-gapX.yd*gapX.ycov_cellWidth;
                    covCount++;
                }

                gapX.row_Scale_id = row_Scale_id;

                gapX.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapX.row_number; i++) {
                    gapX.rowCurrentOrder[i] = Xindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerX = document.createElement('div');
                //svgContainerX.innerHTML = '<div id="${windowID}" class="row" style="width: 500px; height: 500px;></div>';

                // 建立 colorbar 的 HTML 元素
                var colorbarX = document.createElement('div');

                // 計算增加的寬度
                let plusWidth = (gapX.yc+gapX.yd)*gapX.ycov_cellWidth+covCount*10;

                // 在資料輸入時才創建浮動視窗
                if (isDataLoaded) {
                    // 呼叫 createFloatingWindow 來創建浮動視窗
                    createFloatingWindow(windowID, title, svgContainerX, colorbarX, 'colorforXproximity', 'reverseColorforX', maxProxX, minProxX, 396, 110, 440+plusWidth, 380, gapX.yd, gapX.yc);
                } else {
                    return
                }
                
                // 呼叫 funtion 在 windowID 下建立 svg
                gapX.setupProximityData(`#${windowID}_svg`);

                // 畫出 Row Proximity 矩陣圖
                gapX.setupHeatmap2(gapX.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapX.row_name = uniqueX;
                //gapX.setupProxLabel(`#${windowID}`);
                gapX.isRowProxfirst = false;
                gapX.rowIsSimilarity = rowIsSimilarity;

                // let ArrayYZ = convert3DArrayTo2D('X');
                // console.log(ArrayYZ);
                // 輸出成 txt
                // exportArrayToTxt(ArrayYZ, 'ArrayYZ.txt');

                // 更新全域變數
                currentRowProxDataX = rowProxDataX;

                // 畫Xc(須先畫，才能計算Xd位置)
                if(xc_num>0)
                {
                    gapX.ycPalette = "GAP_Rainbow";
                    gapX.setupHeatmap2(gapX.ycData,"mv12",gapX.yc_X,0,12, `#${windowID}`, d3.interpolateSpectral);
                    gapX.setupycLabel(gapX.yc_X-gapX.col_fontsize/2, -5, `#${windowID}`);
                }
                // 畫Xd
                if(xd_num>0)
                {
                    gapX.ydPalette = "GAP_Color_16";
                    gapX.setupHeatmap2(gapX.ydData,"mv11",gapX.yd_X,0,11, `#${windowID}`, d3.schemeSet1);
                    gapX.setupydLabel(gapX.yd_X-gapX.col_fontsize/2, -5, `#${windowID}`);
                }

                //畫出X proximity的label
                gapX.setupProxLabel(`#${windowID}`);
            }
            else
            {
                //for(let i=0 ;i< gapX.row_number; i++)
                    //gapX.rowCurrentOrder[i] = i;
                //gapX.rowOrderId == "sortinit_row";
                //if(gapX)
                //gapX.redrawHeatmap("mv2", 0, 0, 1, `#${windowID}`);  //redrawHeatmap(nowID, x, y, mode, heatmapId)  
                //gapX.redrawHeatmap("mv11", gap2.yd_X, 0, 11, "#heatmap2");
            }
            // order 防呆
            // $("#sortXOrderSelect").prop("disabled",false);
            $("#sortXOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortXOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // 為 proxi MT Y 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxY').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 1);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                // 設置浮動視窗標題
                var title = `Euclidean Distance of Y-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforYproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxY = Math.round(Math.max(...rowProxData1D));
                var minProxY = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `Pearson's Correlation of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxY = 1;
                var minProxY = -1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `Kendall's tau of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxY = 1;
                var minProxY = -1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `Spearman's Rank of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxY = 1;
                var minProxY = -1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `atan Correlation of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxY = 1;
                var minProxY = -1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `City-Block (L1) of Y-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforYproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxY = Math.round(Math.max(...rowProxData1D));
                var minProxY = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 1);

                //var windowID = `window${this.value}forY`;
                var windowID = `windowProxforY`;

                var title = `abs(Pearson's Correlation) of Y-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforYproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforYproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforYproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxY = 1;
                var minProxY = -1;
            }

            $("label[for='reverseColorforY']").css({
                'cursor': 'default',
                'opacity': '1' // 恢復透明度
            });

            for(let i = 0; i < numY; i++) {
                for(let j = 0; j < numY; j++) {
                    rowProxDataY[i][j] = rowProxData1D[i*numY+j];
                }
            }

            if (d3.select("#"+windowID).empty()) {
                gapY = new GAP();
                // 取得 RowProx 二維陣列資料
                gapY.rowProxData = rowProxDataY;

                // 設定 row_number
                gapY.row_number = numY;

                let covCount = 0;
                // 設定 yc
                if(yc_num>0)
                {
                    gapY.yc = yc_num;
                    gapY.ycData = yc;
                    gapY.yc_name = yc_name;
                    gapY.yc_X = -10-gapY.yc*gapY.ycov_cellWidth;
                    gapY.compute_yc_minmax();
                    covCount++;
                }
                // 設定Yd
                if(yd_num>0)
                {
                    gapY.yd = yd_num;
                    gapY.ydData = yd;
                    gapY.yd_cate_col = yd_cate_col;
                    gapY.yd_name = yd_name;
                    gapY.yd_X = gapY.yc_X -10-gapY.yd*gapY.ycov_cellWidth;
                    covCount++;
                }

                gapY.row_Scale_id = row_Scale_id;

                gapY.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapY.row_number; i++) {
                    gapY.rowCurrentOrder[i] = Yindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerY = document.createElement('div');
                //svgContainerY.innerHTML = '<div id="${windowID}" class="row" style="width: 500px; height: 500px;></div>';

                // 建立 colorbar 的 HTML 元素
                var colorbarY = document.createElement('div');

                // 計算增加的寬度
                let plusWidth = (gapY.yc+gapY.yd)*gapY.ycov_cellWidth+covCount*10;

                // 在資料輸入時才創建浮動視窗
                if (isDataLoaded) {
                    // 呼叫 createFloatingWindow 來創建浮動視窗
                    createFloatingWindow(windowID, title, svgContainerY, colorbarY, 'colorforYproximity', 'reverseColorforY', maxProxY, minProxY, 396, 340, 440+plusWidth, 380, gapY.yd, gapY.yc);
                } else {
                    return
                }

                // 呼叫 funtion 在 windowID 下建立 svg
                gapY.setupProximityData(`#${windowID}_svg`);

                // 設定色階
                //var colorID = d3.interpolateSpectral;

                // 畫出 Row Proximity 矩陣圖
                gapY.setupHeatmap2(gapY.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapY.row_name = uniqueY;
                
                gapY.isRowProxfirst = false;
                gapY.rowIsSimilarity = rowIsSimilarity;

                // let ArrayXZ = convert3DArrayTo2D('Y');
                // console.log(ArrayXZ);
                // exportArrayToTxt(ArrayXZ, 'ArrayXZ.txt');

                // 更新全域變數
                currentRowProxDataY = rowProxDataY;

                // 畫Yc(須先畫，才能計算Xd位置)
                if(yc_num>0)
                {
                    gapY.ycPalette = "GAP_Rainbow";
                    gapY.setupHeatmap2(gapY.ycData,"mv12",gapY.yc_X,0,12, `#${windowID}`, d3.interpolateSpectral);
                    gapY.setupycLabel(gapY.yc_X-gapY.col_fontsize/2, -5, `#${windowID}`);
                }
                //Yd
                if(yd_num>0)
                {
                    gapY.ydPalette = "GAP_Color_16";
                    gapY.setupHeatmap2(gapY.ydData,"mv11",gapY.yd_X,0,11, `#${windowID}`, d3.schemeSet1);
                    gapY.setupydLabel(gapY.yd_X-gapY.col_fontsize/2, -5, `#${windowID}`);
                }

                //畫出Y proximity的label
                gapY.setupProxLabel(`#${windowID}`);
            }
            else
            {

            }
            // order 防呆
            // $("#sortYOrderSelect").prop("disabled",false);
            $("#sortYOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortYOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // 為 proxi MT Z 軸下拉式選單新增事件監聽器
        document.getElementById('rowproxZ').addEventListener('change', function() {
            // 設定色階
            var colorID = d3.interpolateSpectral;
            var rpPalette = "GAP_Rainbow";
            if (this.value == "euclidean_distance"){
                var rowProxData1D = runProximity(0, 0, 0, 2);

                // 設置浮動視窗 ID
                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                // 設置浮動視窗標題
                var title = `Euclidean Distance of Z-axis`;

                var colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforZproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxZ = Math.round(Math.max(...rowProxData1D));
                var minProxZ = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "pearson_correlation"){
                var rowProxData1D = runProximity(1, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `Pearson's Correlation of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxZ = 1;
                var minProxZ = -1;
            }
            else if(this.value == "kendalls_tau"){
                var rowProxData1D = runProximity(2, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `Kendall's tau of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxZ = 1;
                var minProxZ = -1;
            }
            else if(this.value == "spearman_rank"){
                var rowProxData1D = runProximity(3, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `Spearman's Rank of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxZ = 1;
                var minProxZ = -1;
            }
            else if(this.value == "atan_correlation"){
                var rowProxData1D = runProximity(4, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `atan Correlation of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxZ = 1;
                var minProxZ = -1;
            }
            else if(this.value == "city_block"){
                var rowProxData1D = runProximity(5, 0, 0, 2);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `City-Block (L1) of Z-axis`;

                colorID = d3.interpolateSpectral;
                // rpPalette = "Spectral";
                rpPalette = "GAP_Rainbow";
                // $("#colorforZproximity option[value='GAP_Rainbow']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Rainbow']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = false;
                var row_Scale_id = 3;

                // 計算最大值和最小值，並四捨五入到整數位
                var maxProxZ = Math.round(Math.max(...rowProxData1D));
                var minProxZ = Math.round(Math.min(...rowProxData1D));
            }
            else if(this.value == "abs_pearson_correlation"){
                var rowProxData1D = runProximity(6, 0, 0, 0);

                //var windowID = `window${this.value}forZ`;
                var windowID = `windowProxforZ`;

                var title = `abs(Pearson's Correlation) of Z-axis`;

                colorID = d3.interpolateRdBu;
                // rpPalette = "RdBu";
                rpPalette = "GAP_Blue_White_Red";
                // $("#colorforZproximity option[value='GAP_Blue_White_Red']").attr('selected','selected');
                $("#colorforZproximity option[value='GAP_Blue_White_Red']").prop('selected', true);
                $("#colorforZproximity").change();
                var rowIsSimilarity = true;
                var row_Scale_id = 1;

                // 設定最大值為 1，最小值為 -1
                var maxProxZ = 1;
                var minProxZ = -1;
            }

            $("label[for='reverseColorforZ']").css({
                'cursor': 'default',
                'opacity': '1' // 恢復透明度
            });

            for(let i = 0; i < numZ; i++) {
                for(let j = 0; j < numZ; j++) {
                    rowProxDataZ[i][j] = rowProxData1D[i*numZ+j];
                }
            }

            if (d3.select("#"+windowID).empty()) {
                gapZ = new GAP();
                // 取得 RowProx 二維陣列資料
                gapZ.rowProxData = rowProxDataZ;

                // 設定 row_number
                gapZ.row_number = numZ;

                let covCount = 0;
                // 設定 zc
                if(zc_num>0)
                {
                    gapZ.yc = zc_num;
                    gapZ.ycData = zc;
                    gapZ.yc_name = zc_name;
                    gapZ.yc_X = -10-gapZ.yc*gapZ.ycov_cellWidth;
                    gapZ.compute_yc_minmax();
                    covCount++;
                }
                // 設定zd
                if(zd_num>0)
                {
                    gapZ.yd = zd_num;
                    gapZ.ydData = zd;
                    gapZ.yd_cate_col = zd_cate_col;
                    gapZ.yd_name = zd_name;
                    gapZ.yd_X = gapZ.yc_X -10-gapZ.yd*gapZ.ycov_cellWidth;
                    covCount++;
                }

                gapZ.row_Scale_id = row_Scale_id;

                gapZ.rpPalette = rpPalette;

                // 放入排序結果 使用 gap 物件中的序
                for(let i=0 ;i< gapZ.row_number; i++) {
                    gapZ.rowCurrentOrder[i] = Zindices[i];
                }

                // 要在浮動視窗中顯示的內容
                var svgContainerZ = document.createElement('div');
                //svgContainerZ.innerHTML = '<div id="${windowID}_svg" class="row" style="width: 100%; height: 100%;></div>';

                // 建立 colorbar 的 HTML 元素
                var colorbarZ = document.createElement('div');

                // 計算增加的寬度
                let plusWidth = (gapZ.yc+gapZ.yd)*gapZ.ycov_cellWidth+covCount*10;

                // 在資料輸入時才創建浮動視窗
                if (isDataLoaded) {
                    // 呼叫 createFloatingWindow 來創建浮動視窗
                    createFloatingWindow(windowID, title, svgContainerZ, colorbarZ, 'colorforZproximity', 'reverseColorforZ', maxProxZ, minProxZ, 396, 570, 440+plusWidth, 380, gapZ.yd, gapZ.yc);
                } else {
                    return
                }

                // 呼叫 funtion 在 windowID 下建立 svg
                gapZ.setupProximityData(`#${windowID}_svg`);

                // 設定色階
                //var colorID = d3.interpolateSpectral;

                // 畫出 Row Proximity 矩陣圖
                gapZ.setupHeatmap2(gapZ.rowProxData,"mv2", 0, 0, 1, `#${windowID}`, colorID);

                gapZ.row_name = uniqueZ;
                //gapZ.setupProxLabel(`#${windowID}`);
                gapZ.isRowProxfirst = false;
                gapZ.rowIsSimilarity = rowIsSimilarity;

                // let ArrayXY = convert3DArrayTo2D('Z');
                // console.log(rowProxDataZ);
                // exportArrayToTxt(rowProxDataZ, 'ArrayXY.txt');

                // 更新全域變數
                currentRowProxDataZ = rowProxDataZ;

                // 畫zc(須先畫，才能計算Xd位置)
                if(zc_num>0)
                {
                    gapZ.ycPalette = "GAP_Rainbow";
                    gapZ.setupHeatmap2(gapZ.ycData,"mv12",gapZ.yc_X,0,12, `#${windowID}`, d3.interpolateSpectral);
                    gapZ.setupycLabel(gapZ.yc_X-gapZ.col_fontsize/2, -5, `#${windowID}`);
                }
                //zd
                if(zd_num>0)
                {
                    gapZ.ydPalette = "GAP_Color_16";
                    gapZ.setupHeatmap2(gapZ.ydData,"mv11",gapZ.yd_X,0,11, `#${windowID}`, d3.schemeSet1);
                    gapZ.setupydLabel(gapZ.yd_X-gapZ.col_fontsize/2, -5, `#${windowID}`);
                }

                //畫出Z proximity的label
                gapZ.setupProxLabel(`#${windowID}`);
            }
            else
            {

            }
            // order 防呆
            // $("#sortZOrderSelect").prop("disabled",false);
            $("#sortZOrderSelect option[value='averagelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='singlelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='completelinkage']").removeAttr('disabled');
            $("#sortZOrderSelect option[value='r2e']").removeAttr('disabled');
        });

        // array 輸出 txt for export proximity
        function exportArrayToTxt(array, axis, filename) {
            // 檢查是否找到對象
            if (!array || array.length === 0) {
                // console.log("Element " + filename + " not found.");
                return;
            }

            // 檢測 array 維度
            const isTwoDimensional = Array.isArray(array[0]);
            let text = '';

            // 處理 uniqueX, uniqueY, uniqueZ，將空白字符替換成 '_'
            const cleanLabels = (labels) => labels.map(label => label.replace(/\s+/g, '_'));

            // 根據 axis 添加對應的標籤，並處理空白字符
            if (axis === 'X') {
                const processedUniqueX = cleanLabels(uniqueX); // 處理空白字符
                text += '\t' + processedUniqueX.join('\t') + '\n'; // 添加 column 標題
            } else if (axis === 'Y') {
                const processedUniqueY = cleanLabels(uniqueY); // 處理空白字符
                text += '\t' + processedUniqueY.join('\t') + '\n'; // 添加 column 標題
            } else if (axis === 'Z') {
                const processedUniqueZ = cleanLabels(uniqueZ); // 處理空白字符
                text += '\t' + processedUniqueZ.join('\t') + '\n'; // 添加 column 標題
            }

            // 將 array 中的資料加入到文本內容
            if (isTwoDimensional) {
                // 如果是二維 array 每個 array 元素佔一列 列內元素以 tab 鍵分隔
                array.forEach((row, index) => {
                    let rowLabel = ''; // 用於儲存列標籤
                    if (axis === 'X') {
                        const processedUniqueX = cleanLabels(uniqueX); // 處理空白字符
                        rowLabel = processedUniqueX[index]; // 用 X 軸的標籤作為 row 標籤
                    } else if (axis === 'Y') {
                        const processedUniqueY = cleanLabels(uniqueY); // 處理空白字符
                        rowLabel = processedUniqueY[index]; // 用 Y 軸的標籤作為 row 標籤
                    } else if (axis === 'Z') {
                        const processedUniqueZ = cleanLabels(uniqueZ); // 處理空白字符
                        rowLabel = processedUniqueZ[index]; // 用 Z 軸的標籤作為 row 標籤
                    }
                    text += rowLabel + '\t' + row.join('\t') + '\n'; // 加上 row 標籤和該列資料
                });
            } else {
                // 如果是一維 array 直接用 tab 鍵連接所有元素
                text = array.join('\t');
            }

            // 建立一個 blob 對象 指定內容類型為純文字
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });

            // 建立一個隱藏的 a 標籤 用於觸發下載
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename; // 設定下載檔案的檔案名
            document.body.appendChild(a); // 新增 a 標籤到 body
            a.click(); // 觸發下載
            document.body.removeChild(a); // 下載後移除 a 標籤
        }


        // 為 exportProximity 按鈕新增點擊事件，只會執行一次
        document.getElementById('exportProximity').addEventListener('click', function() {
            let exported = false; // 標記是否有資料被匯出

            if (currentRowProxDataX) {
                exportArrayToTxt(currentRowProxDataX, 'X', 'Proximity_X.txt');
                exported = true;
            }

            if (currentRowProxDataY) {
                exportArrayToTxt(currentRowProxDataY, 'Y', 'Proximity_Y.txt');
                exported = true;
            }

            if (currentRowProxDataZ) {
                exportArrayToTxt(currentRowProxDataZ, 'Z', 'Proximity_Z.txt');
                exported = true;
            }
            // // 如果沒有任何資料被匯出，輸出提示
            // if (!exported) {
            //     console.log("No proximity data available for export.");
            // }
        });

        // 建立浮動視窗
        function createFloatingWindow(windowId, title, contentElement, colorbarElement, selectedSchemeforproximity, reverseColorforproximity, maxLabelText, minLabelText, left, top, width, height, dCovNum, cCovNum) {
            // 建立浮動視窗元素
            const floatWindow = document.createElement('div');
            floatWindow.classList.add('floating-window');
            floatWindow.id = windowId;

            // 設定樣式
            floatWindow.style.position = 'absolute';
            floatWindow.style.display = 'flex'; // 將浮動視窗的佈局設定為 Flexbox，以便並排顯示內容
            floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
            floatWindow.style.top = top + 'px'; // 使用傳入的 top
            floatWindow.style.width = width + 'px'; // 設置初始寬度
            floatWindow.style.height = height + 'px'; // 設置初始高度
            floatWindow.style.margin = '0'; // 去除任何外邊距
            floatWindow.style.padding = '0'; // 去除任何內邊距
            floatWindow.style.flexDirection = 'column'; // 確保標題和內容從上到下排列
            floatWindow.style.zIndex = '10'; // 確保 floatWindow 在正常層級
            floatWindow.style.overflow = 'hidden'; // 阻止捲軸出現
            floatWindow.style.boxSizing = 'border-box'; // 對 floatWindow 也做同樣設置

            // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
            const header = document.createElement('div');
            header.classList.add('window-header');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
            header.style.alignItems = 'center'; // 垂直居中對齊
            // header.style.margin = '0'; // 去除任何外邊距
            // header.style.padding = '0'; // 去除任何內邊距
            header.style.position = 'relative';
            header.style.zIndex = '15'; // 讓標題層級比內容區域高

            // 建立標題元素
            const titleElement = document.createElement('span');
            titleElement.textContent = title;
            header.appendChild(titleElement);

            // 建立最小化/還原按鈕
            const toggleButton = document.createElement('span');
            toggleButton.textContent = '–'; // 使用減號表示最小化
            toggleButton.classList.add('toggle');
            toggleButton.style.fontSize = '24px'; // 增大字體大小
            toggleButton.style.cursor = 'pointer'; // 滑鼠懸停時顯示手形圖標
            toggleButton.style.marginLeft = 'auto'; // 將按鈕推到右邊
            toggleButton.style.marginRight = '8px'; // 調整按鈕之間的間距
            toggleButton.onclick = function() {
                if (floatWindow.classList.contains('minimized')) {
                    // 如果已經是最小化狀態，還原視窗
                    floatWindow.style.height = floatWindow.dataset.originalHeight;
                    contentElement.style.display = 'block'; // 再次顯示內容
                    colorbarElement.style.display = 'block'; // 再次顯示 colorbar
                    maxLabel.style.display = 'block'; // 顯示最大值標籤
                    minLabel.style.display = 'block'; // 顯示最小值標籤
                    floatWindow.style.resize = 'both'; // 允許再次調整視窗大小
                    floatWindow.classList.remove('minimized');
                    toggleButton.textContent = '–'; // 切換回最小化按鈕
                } else {
                    // 最小化視窗
                    floatWindow.dataset.originalHeight = floatWindow.style.height; // 儲存原始高度
                    floatWindow.style.height = header.offsetHeight + 'px'; // 設定高度為頭部高度
                    contentElement.style.display = 'none'; // 隱藏內容
                    colorbarElement.style.display = 'none'; // 隱藏 colorbar
                    maxLabel.style.display = 'none'; // 隱藏最大值標籤
                    minLabel.style.display = 'none'; // 隱藏最小值標籤
                    floatWindow.style.resize = 'none'; // 禁止調整視窗大小
                    floatWindow.classList.add('minimized');
                    toggleButton.textContent = ' + '; // 切換為還原按鈕
                }
            };
            header.appendChild(toggleButton);

            // 建立關閉按鈕
            const closeButton = document.createElement('span');
            closeButton.textContent = '×';
            closeButton.classList.add('close');
            closeButton.style.marginRight = '10px'; // 給關閉按鈕一點左邊距
            closeButton.onclick = function() {
                floatWindow.remove();
                // 按關閉按鈕時，同時禁用 color for proximity
                $("#"+selectedSchemeforproximity).prop('disabled', true).css('cursor', 'not-allowed');
                $("#"+reverseColorforproximity).prop('disabled', true).css('cursor', 'not-allowed');

                // 重置 selectedSchemeforproximity 下拉式選單回到預設選項 (GAP_Rainbow)
                $("#" + selectedSchemeforproximity + " option[value='GAP_Rainbow']").prop('selected', true);
                $("#" + selectedSchemeforproximity).change();

                // 重置 reverseColorforproximity 狀態
                document.getElementById(reverseColorforproximity).checked = false;
            };
            header.appendChild(closeButton);

            // 設置拖移事件
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 將頭部添加到浮動窗口
            floatWindow.appendChild(header);

            // 建立內容容器，並將 heatmap 和 colorbar 添加到其中
            const container = document.createElement('div');

            container.style.display = 'flex'; // 使用 Flexbox 佈局
            container.style.position = 'absolute'; // 設定為相對定位，以便 colorbar 使用絕對定位
            container.style.alignItems = 'center'; // 垂直居中對齊
            container.style.width = '100%'; // 讓容器填滿視窗寬度
            // container.style.height = '99%'; // 讓容器填滿視窗高度
            container.style.height = `calc(100% - 39px)`; // 設定 container 的高度為視窗高度減去 header 的實際高度
            container.style.margin = '0'; // 去除任何外邊距
            container.style.padding = '0'; // 去除任何內邊距
            // container.style.border = '2px solid red';

            // 設定 heatmap 樣式並新增到容器
            contentElement.style.height = '100%'; // 讓內容區域填滿容器高度
            contentElement.style.width = '99%'; // 讓內容區域填滿容器寬度
            contentElement.style.margin = '0'; // 去除任何外邊距
            contentElement.style.padding = '0'; // 去除任何內邊距
            contentElement.id = windowId + "_svg";
            contentElement.style.overflow = 'hidden'; // 確保內容區域不會超出視窗
            contentElement.style.boxSizing = 'border-box'; // 包含邊框和 padding 在元素寬高中
            // contentElement.style.border = '2px solid yellow';

            // 建立colorbarContainerMain
            //<div style="height: 100%;display: flex;position: absolute;/* margin-right: 30px; */align-items: center;margin-top: 0px;margin-bottom: 0px;padding: 0px;right: 0px;width: 80px;background: linear-gradient(to right, rgba(255, 255, 250, 0) 0%, rgba(255, 255, 244, 1) 50%, rgba(255, 255, 240, 1) 100%);">
            const colorbarContainerMain = document.createElement('div');
            colorbarContainerMain.id = 'colorbarforprox-container-main';

            //colorbarContainerMain.classList.add('content');
            colorbarContainerMain.style.height = '100%';
            colorbarContainerMain.style.display = 'flex';
            colorbarContainerMain.style.position = 'absolute';
            colorbarContainerMain.style.alignItems = 'center';
            colorbarContainerMain.style.marginTop = '0px';
            colorbarContainerMain.style.marginBottom = '0px';
            colorbarContainerMain.style.padding = '0px';
            colorbarContainerMain.style.right = '0px';
            colorbarContainerMain.style.width = '80px';
            colorbarContainerMain.style.background = 'linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 50%, rgba(255, 255, 255, 1) 100%)';

            // 建立menu bar
            const tabMenuContainer = document.createElement('div');
            tabMenuContainer.id = "tab-menu";
            tabMenuContainer.classList.add('tab-menu');           

            // 建立menu tab
            const button = document.createElement('button');
            button.innerText = 'proximity'; // 按鈕文字
            button.setAttribute('data-target', 'tab1'); // 設置 data-target 屬性
            button.classList.add('active'); // 添加 active class
            tabMenuContainer.appendChild(button);

            if(dCovNum > 0)
            {
                const button1 = document.createElement('button');
                button1.innerText = 'discr. cov.'; // 按鈕文字
                button1.setAttribute('data-target', 'tab2'); // 設置 data-target 屬性
                tabMenuContainer.appendChild(button1);                
            }
            if(cCovNum > 0)
            {
                const button2 = document.createElement('button');
                button2.innerText = 'conti. cov.'; // 按鈕文字
                button2.setAttribute('data-target', 'tab3'); // 設置 data-target 屬性
                tabMenuContainer.appendChild(button2);                
            }

            // 建立 colorbar 容器和標籤
            const colorbarContainer = document.createElement('div');

            colorbarContainer.id = 'colorbarforprox-container';
            colorbarContainer.classList.add('content');
            //colorbarContainer.classList.add('tab-content', 'active');
            // colorbarContainer.style.flexDirection = 'row'; // 横向排列元素
            colorbarContainer.style.display = 'flex';
            //colorbarContainer.style.position = 'absolute';
            colorbarContainer.style.marginRight = '30px'; // 給標籤留一些空間
            colorbarContainer.style.alignItems = 'center'; // 內容從頂部對齊
            colorbarContainer.style.marginTop = '0'; // 去除上邊距
            colorbarContainer.style.marginBottom = '0'; // 去除下邊距
            colorbarContainer.style.padding = '0'; // 去除任何內邊距
            colorbarContainer.style.right = '0'; // 去除任何內邊距
            // colorbarContainer.style.border = '2px solid blue';

            // 建立 colorbar 容器
            const colorbarPanel = document.createElement('div');
            colorbarPanel.id = 'tab1';
            colorbarPanel.classList.add('tab-content', 'active');
            colorbarPanel.style.left = '14px'; // 去除任何內邊距

            // 設定 colorbar 樣式並新增到容器
            //colorbarElement.classList.add('tab-content', 'active');
            colorbarElement.style.width = '20px'; // 設定 colorbar 的寬度
            colorbarElement.style.height = '200px'; // 設定 colorbar 的高度
            colorbarElement.style.border = '1px solid #FFF'; // 設定 colorbar 的邊框樣式
            colorbarElement.style.position = 'relative'; // 設定 colorbar 相對定位，以便標籤使用絕對定位
            colorbarElement.style.alignItems = 'flex-start'; // 內容從頂部對齊
            colorbarElement.style.boxSizing = 'border-box'; // 確保 padding 和 border 不會影響佈局
            colorbarElement.style.marginTop = '0'; // 去除上邊距
            colorbarElement.style.marginBottom = '0'; // 去除下邊距
            colorbarElement.style.padding = '0'; // 去除任何內邊距

            // 設定顏色方案下拉式選單的監聽器
            const colorforproximity = document.getElementById(selectedSchemeforproximity);

            colorforproximity.addEventListener('change', function() {
                const selectedScheme = colorforproximity.value; // 取得所選的顏色方案
                const gradient = getColorGradient(selectedScheme, reverseColorforproximity); // 取得對應的漸層樣式 'reverseColorforX' 
                colorbarElement.style.background = gradient; // 將漸層樣式套用到 colorbar
            });

            // 初始化時設定預設的顏色方案
            const initialColorScheme = colorforproximity.value;
            colorbarElement.style.background = getColorGradient(initialColorScheme, reverseColorforproximity)

            // 監聽 reverseColorforproximityCheckbox 的變化
            const reverseColorforproximityCheckbox = document.getElementById(reverseColorforproximity);

            reverseColorforproximityCheckbox.addEventListener('change', function() {
                const selectedScheme = colorforproximity.value; // 取得所選的顏色方案
                const gradient = getColorGradient(selectedScheme, reverseColorforproximity); // 取得對應的漸層樣式
                colorbarElement.style.background = gradient; // 將漸層樣式套用到 colorbar
            });

            // 建立最大值標籤
            const maxLabel = document.createElement('div');
            maxLabel.id = 'colorbarforprox-max-label';
            maxLabel.classList.add('colorbarforprox-label');
            maxLabel.textContent = maxLabelText;

            // 設定最大值標籤樣式
            maxLabel.style.position = 'absolute';
            maxLabel.style.left = '36px'; // 距離 colorbar 右側 24px
            maxLabel.style.bottom = '95%'; // 與 colorbar 頂部對齊
            maxLabel.style.fontSize = '12px';
            maxLabel.style.fontFamily = 'Arial, sans-serif';
            maxLabel.style.textAlign = 'left'; // 標籤靠左顯示
            maxLabel.style.margin = '0'; // 去除任何外邊距
            maxLabel.style.padding = '0'; // 去除任何內邊距
            // maxLabel.style.border = '2px solid gray';

            // 建立最小值標籤
            const minLabel = document.createElement('div');
            minLabel.id = 'colorbarforprox-min-label';
            minLabel.classList.add('colorbarforprox-label');
            minLabel.textContent = minLabelText;

            // 設定最小值標籤樣式
            minLabel.style.position = 'absolute';
            minLabel.style.left = '36px'; // 距離 colorbar 右側 24px
            minLabel.style.top = '95%'; // 與 colorbar 底部對齊
            minLabel.style.fontSize = '12px';
            minLabel.style.fontFamily = 'Arial, sans-serif';
            minLabel.style.textAlign = 'left';
            minLabel.style.margin = '0'; // 去除任何外邊距
            minLabel.style.padding = '0'; // 去除任何內邊距
            // minLabel.style.border = '2px solid gray';s

            // 將標籤和 colorbar 加入 colorbarPanel
            colorbarPanel.appendChild(maxLabel);
            colorbarPanel.appendChild(colorbarElement);
            colorbarPanel.appendChild(minLabel);

            //colorbarPanel 加入 colorbarContainer
            colorbarContainer.appendChild(colorbarPanel);

            if(dCovNum > 0)
            {
                // 建立 colorbar 容器
                const colorbarPanel1 = document.createElement('div');
                colorbarPanel1.id = 'tab2';
                colorbarPanel1.classList.add('tab-content');
                colorbarPanel1.style.left = '14px'; // 去除任何內邊距

                // 設定 colorbar 樣式並新增到容器
                const colorbarElement1 = document.createElement('div');
                colorbarElement1.style.width = '20px'; // 設定 colorbar 的寬度
                colorbarElement1.style.height = '202px'; // 設定 colorbar 的高度
                colorbarElement1.style.border = '1px solid #C0C0C0'; // 設定 colorbar 的邊框樣式
                colorbarElement1.style.position = 'relative'; // 設定 colorbar 相對定位，以便標籤使用絕對定位
                colorbarElement1.style.alignItems = 'flex-start'; // 內容從頂部對齊
                colorbarElement1.style.boxSizing = 'border-box'; // 確保 padding 和 border 不會影響佈局
                colorbarElement1.style.marginTop = '0'; // 去除上邊距
                colorbarElement1.style.marginBottom = '0'; // 去除下邊距
                colorbarElement1.style.padding = '0'; // 去除任何內邊距

                const GAPColor16 = ["#FF0000", "#007F00", "#0000FF", "#FFFF00", "#00FFFF", 
                        "#FF00FF", "#7F7F7F", "#FF7F00", "#7F007F", "#7FFF00", 
                        "#7F3F3F", "#7F7F00", "#3F7F7F", "#FF7F7F", "#00007F", "#FFFFFF"];

                GAPColor16.reverse().forEach(color => {
                    const div = document.createElement('div');
                    //div.classList.add('color-div');
                    div.style.width = '18px';
                    div.style.height = '12.5px';
                    div.style.backgroundColor = color;
                    colorbarElement1.appendChild(div);
                });

                // 建立最大值標籤
                const maxLabel1 = document.createElement('div');
                maxLabel1.id = 'colorbarforprox-max-label';
                maxLabel1.classList.add('colorbarforprox-label');
                maxLabel1.textContent = 'Max';

                // 設定最大值標籤樣式
                maxLabel1.style.position = 'absolute';
                maxLabel1.style.left = '36px'; // 距離 colorbar 右側 24px
                maxLabel1.style.bottom = '95%'; // 與 colorbar 頂部對齊
                maxLabel1.style.fontSize = '12px';
                maxLabel1.style.fontFamily = 'Arial, sans-serif';
                maxLabel1.style.textAlign = 'left'; // 標籤靠左顯示
                maxLabel1.style.margin = '0'; // 去除任何外邊距
                maxLabel1.style.padding = '0'; // 去除任何內邊距
                // maxLabel.style.border = '2px solid gray';

                // 建立最小值標籤
                const minLabel1 = document.createElement('div');
                minLabel1.id = 'colorbarforprox-min-label';
                minLabel1.classList.add('colorbarforprox-label');
                minLabel1.textContent = 'Min';

                // 設定最小值標籤樣式
                minLabel1.style.position = 'absolute';
                minLabel1.style.left = '36px'; // 距離 colorbar 右側 24px
                minLabel1.style.top = '95%'; // 與 colorbar 底部對齊
                minLabel1.style.fontSize = '12px';
                minLabel1.style.fontFamily = 'Arial, sans-serif';
                minLabel1.style.textAlign = 'left';
                minLabel1.style.margin = '0'; // 去除任何外邊距
                minLabel1.style.padding = '0'; // 去除任何內邊距

                // 將標籤和 colorbar 加入 colorbarPanel
                colorbarPanel1.appendChild(maxLabel1);
                colorbarPanel1.appendChild(colorbarElement1);
                colorbarPanel1.appendChild(minLabel1);

                //colorbarPanel 加入 colorbarContainer
                colorbarContainer.appendChild(colorbarPanel1);
            }

            if(cCovNum > 0)
            {
                // 建立 colorbar 容器
                const colorbarPanel2 = document.createElement('div');
                colorbarPanel2.id = 'tab3';
                colorbarPanel2.classList.add('tab-content');
                colorbarPanel2.style.left = '14px'; // 去除任何內邊距

                // 設定 colorbar 樣式並新增到容器
                const colorbarElement2 = document.createElement('div');
                colorbarElement2.style.width = '20px'; // 設定 colorbar 的寬度
                colorbarElement2.style.height = '200px'; // 設定 colorbar 的高度
                colorbarElement2.style.border = '1px solid #FFF'; // 設定 colorbar 的邊框樣式
                colorbarElement2.style.position = 'relative'; // 設定 colorbar 相對定位，以便標籤使用絕對定位
                colorbarElement2.style.alignItems = 'flex-start'; // 內容從頂部對齊
                colorbarElement2.style.boxSizing = 'border-box'; // 確保 padding 和 border 不會影響佈局
                colorbarElement2.style.marginTop = '0'; // 去除上邊距
                colorbarElement2.style.marginBottom = '0'; // 去除下邊距
                colorbarElement2.style.padding = '0'; // 去除任何內邊距
             
                colorbarElement2.style.background = getColorGradient('GAP_Rainbow', "");

                // 建立最大值標籤
                const maxLabel2 = document.createElement('div');
                maxLabel2.id = 'colorbarforprox-max-label';
                maxLabel2.classList.add('colorbarforprox-label');
                maxLabel2.textContent = "Max";

                // 設定最大值標籤樣式
                maxLabel2.style.position = 'absolute';
                maxLabel2.style.left = '36px'; // 距離 colorbar 右側 24px
                maxLabel2.style.bottom = '95%'; // 與 colorbar 頂部對齊
                maxLabel2.style.fontSize = '12px';
                maxLabel2.style.fontFamily = 'Arial, sans-serif';
                maxLabel2.style.textAlign = 'left'; // 標籤靠左顯示
                maxLabel2.style.margin = '0'; // 去除任何外邊距
                maxLabel2.style.padding = '0'; // 去除任何內邊距
                // maxLabel.style.border = '2px solid gray';

                // 建立最小值標籤
                const minLabel2 = document.createElement('div');
                minLabel2.id = 'colorbarforprox-min-label';
                minLabel2.classList.add('colorbarforprox-label');
                minLabel2.textContent = "Min";

                // 設定最小值標籤樣式
                minLabel2.style.position = 'absolute';
                minLabel2.style.left = '36px'; // 距離 colorbar 右側 24px
                minLabel2.style.top = '95%'; // 與 colorbar 底部對齊
                minLabel2.style.fontSize = '12px';
                minLabel2.style.fontFamily = 'Arial, sans-serif';
                minLabel2.style.textAlign = 'left';
                minLabel2.style.margin = '0'; // 去除任何外邊距
                minLabel2.style.padding = '0'; // 去除任何內邊距

                // 將標籤和 colorbar 加入 colorbarPanel
                colorbarPanel2.appendChild(maxLabel2);
                colorbarPanel2.appendChild(colorbarElement2);
                colorbarPanel2.appendChild(minLabel2);

                //colorbarPanel 加入 colorbarContainer
                colorbarContainer.appendChild(colorbarPanel2);
            }


            // 將colorbarContainer加入 colorbarContainerMain
            colorbarContainerMain.appendChild(colorbarContainer);
            colorbarContainerMain.appendChild(tabMenuContainer);

            // 將內容容器新增到浮動視窗中
            container.appendChild(contentElement); // 將 heatmap 元素加入容器中
            container.appendChild(colorbarContainerMain); // 將 colorbarContainer 元素加入容器中

            // 將內容容器新增到浮動視窗中
            floatWindow.appendChild(container);
            // floatWindow.appendChild(colorbarContainer);

            // 組裝視窗並顯示
            document.getElementById('floatingWindowContainer').appendChild(floatWindow);
            floatWindow.style.display = 'block';

            // 每次建立後啟用 color for proximity
            if (document.getElementById(windowId)) {
                $("#"+selectedSchemeforproximity).prop('disabled', false).css('cursor', 'auto');
                $("#"+reverseColorforproximity).prop('disabled', false).css('cursor', 'auto');
            }

            // 設定視窗的初始 z-index
            floatWindow.style.zIndex = highestZIndex++;

            // 新增點擊事件監聽器來調整 z-index
            floatWindow.addEventListener('click', function() {
                this.style.zIndex = ++highestZIndex;
            });

            // 新增點擊tab的功能
            const buttons = colorbarContainerMain.querySelectorAll('.tab-menu button');
            const contents = colorbarContainerMain.querySelectorAll('.tab-content');

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    // 移除所有按鈕的 active 狀態
                    buttons.forEach(btn => btn.classList.remove('active'));
                    // 為點擊的按鈕添加 active 狀態
                    button.classList.add('active');

                    // 隱藏所有內容
                    contents.forEach(content => content.classList.remove('active'));
                    // 顯示點擊按鈕對應的內容
                    //const target = colorbarContainerMain.getElementById(button.getAttribute('data-target'));
                    const target = colorbarContainerMain.querySelector(`#${button.getAttribute('data-target')}`);
                    target.classList.add('active');
                });
            });
        }

        function createFloatingWindow_forchart(windowId, title, contentElement, left, right, top, width, height) {
            // 建立浮動視窗元素
            const floatWindow = document.createElement('div');
            floatWindow.classList.add('floating-window');
            floatWindow.id = windowId;

            // 設定樣式
            floatWindow.style.position = 'absolute';
            floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
            floatWindow.style.right = right + 'px'; // 使用傳入的 right 值
            floatWindow.style.top = top + 'px'; // 使用傳入的 top
            floatWindow.style.width = width + 'px'; // 設置初始寬度
            floatWindow.style.height = height + 'px'; // 設置初始高度

            // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
            const header = document.createElement('div');
            header.classList.add('window-header');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
            header.style.alignItems = 'center'; // 垂直居中對齊

            // 建立標題元素
            const titleElement = document.createElement('span');
            titleElement.textContent = title;
            header.appendChild(titleElement);

            // 最小化/還原按鈕
            const toggleButton = document.createElement('span');
            toggleButton.textContent = '–'; // 使用減號表示最小化
            toggleButton.classList.add('toggle');
            toggleButton.style.fontSize = '24px'; // 增大字體大小
            toggleButton.style.marginLeft = 'auto'; // 將按鈕推到右邊
            toggleButton.style.cursor = 'pointer'; // 滑鼠懸停時顯示手形圖標
            toggleButton.onclick = function() {
                if (floatWindow.classList.contains('minimized')) {
                    // 如果已經是最小化狀態，還原視窗
                    floatWindow.style.height = floatWindow.dataset.originalHeight;
                    contentElement.style.display = 'block'; // 再次顯示內容
                    floatWindow.classList.remove('minimized');
                    toggleButton.textContent = '–'; // 切換回最小化按鈕
                } else {
                    // 最小化視窗
                    floatWindow.dataset.originalHeight = floatWindow.style.height; // 儲存原始高度
                    floatWindow.style.height = header.offsetHeight + 'px'; // 設定高度為頭部高度
                    contentElement.style.display = 'none'; // 隱藏內容
                    floatWindow.classList.add('minimized');
                    toggleButton.textContent = ' + '; // 切換為還原按鈕
                }
            };
            header.appendChild(toggleButton);
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 將頭部添加到浮動窗口
            floatWindow.appendChild(header);

            // 將提供的內容新增到浮動視窗中
            floatWindow.appendChild(contentElement);

            // 組裝視窗並顯示
            document.getElementById('floatingWindowContainer').appendChild(floatWindow);
            floatWindow.style.display = 'block';

            // 設定視窗的初始 z-index
            floatWindow.style.zIndex = highestZIndex++;

            // 新增點擊事件監聽器來調整 z-index
            floatWindow.addEventListener('click', function() {
                this.style.zIndex = ++highestZIndex;
            });
        }

        function createFloatingWindow_samplelist(windowId, title, contentElement, left, right, top, width, height) {
            // 建立浮動視窗元素
            const floatWindow = document.createElement('div');
            floatWindow.classList.add('floating-window');
            floatWindow.id = windowId;

            // 設定樣式
            floatWindow.style.position = 'absolute';
            floatWindow.style.left = left + 'px'; // 使用傳入的 left 值
            floatWindow.style.right = right + 'px'; // 使用傳入的 right 值
            floatWindow.style.top = top + 'px'; // 使用傳入的 top
            floatWindow.style.width = width + 'px'; // 設置初始寬度
            floatWindow.style.height = height + 'px'; // 設置初始高度

            // 建立視窗頭部 並使用 Flexbox 佈局 (for 拖移)
            const header = document.createElement('div');
            header.classList.add('window-header');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between'; // 在頭部兩端分佈元素
            header.style.alignItems = 'center'; // 垂直居中對齊

            // 建立標題元素
            const titleElement = document.createElement('span');
            titleElement.textContent = title;
            header.appendChild(titleElement);

            // 最小化/還原按鈕
            const toggleButton = document.createElement('span');
            toggleButton.textContent = '–'; // 使用減號表示最小化
            toggleButton.classList.add('toggle');
            toggleButton.style.fontSize = '24px'; // 增大字體大小
            toggleButton.style.marginLeft = 'auto'; // 將按鈕推到右邊
            toggleButton.style.cursor = 'pointer'; // 滑鼠懸停時顯示手形圖標
            toggleButton.onclick = function() {
                if (floatWindow.classList.contains('minimized')) {
                    // 如果已經是最小化狀態，還原視窗
                    floatWindow.style.height = floatWindow.dataset.originalHeight;
                    contentElement.style.display = 'block'; // 再次顯示內容
                    floatWindow.classList.remove('minimized');
                    toggleButton.textContent = '–'; // 切換回最小化按鈕
                } else {
                    // 最小化視窗
                    floatWindow.dataset.originalHeight = floatWindow.style.height; // 儲存原始高度
                    floatWindow.style.height = header.offsetHeight + 'px'; // 設定高度為頭部高度
                    contentElement.style.display = 'none'; // 隱藏內容
                    floatWindow.classList.add('minimized');
                    toggleButton.textContent = ' + '; // 切換為還原按鈕
                }
            };
            header.appendChild(toggleButton);
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 建立關閉按鈕
            const closeButton = document.createElement('span');
            closeButton.textContent = '×';
            closeButton.classList.add('close');
            closeButton.style.marginLeft = '8px'; // 給關閉按鈕一點左邊距
            closeButton.onclick = function() {
                floatWindow.remove();
            };
            header.appendChild(closeButton);

            // 設置拖移事件
            header.onmousedown = function(event) {
                startDrag(event, windowId);
            };

            // 將頭部添加到浮動窗口
            floatWindow.appendChild(header);

            // 將提供的內容新增到浮動視窗中
            floatWindow.appendChild(contentElement);

            // 組裝視窗並顯示
            document.getElementById('floatingWindowContainer').appendChild(floatWindow);
            floatWindow.style.display = 'block';

            // 設定視窗的初始 z-index
            floatWindow.style.zIndex = highestZIndex++;

            // 新增點擊事件監聽器來調整 z-index
            floatWindow.addEventListener('click', function() {
                this.style.zIndex = ++highestZIndex;
            });
        }

        function startDrag(e, id) {
            const elem = document.getElementById(id);
            let offsetX = e.clientX - elem.getBoundingClientRect().left;
            let offsetY = e.clientY - elem.getBoundingClientRect().top;

            function onMouseMove(e) {
                elem.style.left = (e.clientX - offsetX) + 'px';
                elem.style.top = (e.clientY - offsetY) + 'px';
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // 切片
        function sliceCubeByAxis(axis) {
            // updateAxes = false; // 切片操作時不更新軸線與軸標籤

            clearAxesLines();

            SliceRange = document.getElementById('SliceRange');
            sliceGap = parseFloat(SliceRange.value);
            document.getElementById('SliceValue').textContent = sliceGap;

            switch (axis) {
                case 'X':
                    allowUpdateSizes = false; // 在切片操作時停用修改邊長
                    allowUpdatehollowSizes = false; // 在切片操作時停用分開所有小立方體

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(.01, 1, 1);

                                     // 計算並更新立方體的新位置
                                    let posX = (i - (cubes.length - 1) / 2) * (cubeSizeX * sliceGap);
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'Y':
                    allowUpdateSizes = false;
                    allowUpdatehollowSizes = false;

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(1, .01, 1);
                                    
                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    let posY = (j - (cubes[i].length - 1) / 2) * (cubeSizeY * sliceGap);
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'Z':
                    allowUpdateSizes = false;
                    allowUpdatehollowSizes = false;
                    
                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(1, 1, .01);
                                    
                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    let posZ = (k - (cubes[i][j].length - 1) / 2) * (cubeSizeZ * sliceGap);
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
                case 'O':
                    allowUpdateSizes = true; // 當選擇回原始 cube 時，回復修改邊長功能
                    allowUpdatehollowSizes = true; // 當選擇回原始 cube 時，回復分開所有小立方體

                    // updateAxes = true; // 當選擇回原始 cube 時，回復軸線功能

                    for (let i = 0; i < cubes.length; i++) {
                        for (let j = 0; j < cubes[i].length; j++) {
                            for (let k = 0; k < cubes[i][j].length; k++) {
                                let cube = cubes[i][j][k];
                                if (cube) {
                                    // 更新立方體的尺寸
                                    cube.scale.set(cubeSizeX, cubeSizeY, cubeSizeZ);

                                    // 計算並更新立方體的新位置
                                    var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                                    var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                                    var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;
                                    cube.position.set(posX, posY, posZ);
                                }
                            }
                        }
                    }
                    break;
            }
            // ### for cubesize
            // 停用或啟用滑桿
            cubeSizeXslider.disabled = !allowUpdateSizes;
            cubeSizeYslider.disabled = !allowUpdateSizes;
            cubeSizeZslider.disabled = !allowUpdateSizes;

            // 切換禁止鼠標樣式
            if (allowUpdateSizes) {
                cubeSizeXslider.style.cursor = 'auto';
                cubeSizeYslider.style.cursor = 'auto';
                cubeSizeZslider.style.cursor = 'auto';
            } else {
                cubeSizeXslider.style.cursor = 'not-allowed';
                cubeSizeYslider.style.cursor = 'not-allowed';
                cubeSizeZslider.style.cursor = 'not-allowed';
            }

            // ### for separate cube
            // 停用或啟用滑桿
            hollowSize.disabled = !allowUpdatehollowSizes;

            // 切換禁止鼠標樣式
            if (allowUpdatehollowSizes) {
                hollowSize.style.cursor = 'auto';
            } else {
                hollowSize.style.cursor = 'not-allowed';
            }

            // 呼叫渲染函數來更新場景
            // renderer.render(scene, camera);
        }

        // 偵測 radio 按鈕的變化
        document.getElementById("axisSelection").addEventListener("change", function(event) {
            // 取得選取的軸
            selectedAxis = event.target.value;

            // 呼叫 sliceCubeByAxis 函數，傳入選中的軸
            sliceCubeByAxis(selectedAxis);
        });

        // 滑動條值改變時呼叫 sliceCubeByAxis 函數
        document.getElementById('SliceRange').addEventListener('input', function() {
            // 呼叫 sliceCubeByAxis 函數，傳入選中的軸
            sliceCubeByAxis(selectedAxis);
        });

        // 調整 cube 分開時之大小
        document.getElementById('hollowSize').addEventListener('input', function() {
            newSize = this.value;
            hollowCube(newSize);
            document.getElementById('hollowSizeValue').textContent = newSize;

            // 如果 newSize 不等於 1，禁用 xAxis, yAxis, zAxis 以及 SliceRange
            if (newSize != 1) {
                document.getElementById('xAxis').disabled = true;
                document.getElementById('yAxis').disabled = true;
                document.getElementById('zAxis').disabled = true;
                document.getElementById('SliceRange').disabled = true;

                // 顯示禁止標誌
                document.getElementById('xAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="xAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="xAxis"]').style.opacity = '.5';

                document.getElementById('yAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="yAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="yAxis"]').style.opacity = '.5';

                document.getElementById('zAxis').parentElement.style.cursor = 'not-allowed';
                document.querySelector('label[for="zAxis"]').style.cursor = 'not-allowed';
                document.querySelector('label[for="zAxis"]').style.opacity = '.5';

                document.getElementById('SliceRange').style.cursor = 'not-allowed';
            } else {
                // 啟用 xAxis, yAxis, zAxis 以及 SliceRange
                document.getElementById('xAxis').disabled = false;
                document.getElementById('yAxis').disabled = false;
                document.getElementById('zAxis').disabled = false;
                document.getElementById('SliceRange').disabled = false;

                // 恢復正常滑鼠樣式
                document.getElementById('xAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="xAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="xAxis"]').style.opacity = '1';

                document.getElementById('yAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="yAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="yAxis"]').style.opacity = '1';

                document.getElementById('zAxis').parentElement.style.cursor = 'auto';
                document.querySelector('label[for="zAxis"]').style.cursor = 'auto';
                document.querySelector('label[for="zAxis"]').style.opacity = '1';

                document.getElementById('SliceRange').style.cursor = 'auto';
            }
        });

        // for 停用或啟用滑桿
        const cubeSizeXslider = document.getElementById('cubeSizeX');
        const cubeSizeYslider = document.getElementById('cubeSizeY');
        const cubeSizeZslider = document.getElementById('cubeSizeZ');

        // 將 cube 分開
        function hollowCube(newSize) {
            if (!allowUpdatehollowSizes) return; // 如果不允許分開所有小立方體，直接返回

            if (newSize != 1) {
                allowUpdateSizes = false;
            } else {
                allowUpdateSizes = true; // 確保在 newSize 等於 1 時 也能調整立方體大小
            }

            // 停用或啟用滑桿
            cubeSizeXslider.disabled = !allowUpdateSizes;
            cubeSizeYslider.disabled = !allowUpdateSizes;
            cubeSizeZslider.disabled = !allowUpdateSizes;

            // 切換禁止鼠標樣式
            if (allowUpdateSizes) {
                cubeSizeXslider.style.cursor = 'auto';
                cubeSizeYslider.style.cursor = 'auto';
                cubeSizeZslider.style.cursor = 'auto';
            } else {
                cubeSizeXslider.style.cursor = 'not-allowed';
                cubeSizeYslider.style.cursor = 'not-allowed';
                cubeSizeZslider.style.cursor = 'not-allowed';
            }

            // newSize 為更新之新尺寸
            for (let i = 0; i < cubes.length; i++) {
                for (let j = 0; j < cubes[i].length; j++) {
                    for (let k = 0; k < cubes[i][j].length; k++) {
                        let cube = cubes[i][j][k];
                        if (cube) {
                            cube.scale.set(newSize, newSize, newSize);

                            // // 計算並更新立方體的新位置
                            // var posX = (i - (cubes.length - 1) / 2) * cubeSizeX;
                            // var posY = (j - (cubes[i].length - 1) / 2) * cubeSizeY;
                            // var posZ = (k - (cubes[i][j].length - 1) / 2) * cubeSizeZ;

                            // cube.position.set(posX, posY, posZ);
                        }
                    }
                }
            }
        }

        // 根據類別計算資料 (for bar chart)
        function calculateDataPoints(dataArray, uniqueX, uniqueY, uniqueZ, axis, calculationType) {
            //let results = {};
            let results_name = [];
            let results_value = [];

            if (axis === 'X') {
                for (let idx = 0; idx < Xindices.length; idx++) { // 使用全域變數 Xindices
                    let i = Xindices[idx];
                    let total = 0, count = 0;
                    for (let j = 0; j < uniqueY.length; j++) {
                        for (let k = 0; k < uniqueZ.length; k++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }
                    //results[uniqueX[i]] = calculationType === 'mean' ? total / count : total;
                    results_name[idx] = uniqueX[i];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }
            } else if (axis === 'Y') {
                for (let idx = 0; idx < Yindices.length; idx++) { // 使用全域變數 Yindices
                    let j = Yindices[idx];
                    let total = 0, count = 0;
                    for (let i = 0; i < uniqueX.length; i++) {
                        for (let k = 0; k < uniqueZ.length; k++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }
                    //results[uniqueY[j]] = calculationType === 'mean' ? total / count : total;
                    //console.log(j+","+uniqueY[j] +","+ results[uniqueY[j]]);
                    results_name[idx] = uniqueY[j];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }
            } else if (axis === 'Z') {
                for (let idx = 0; idx < Zindices.length; idx++) { // 使用全域變數 Zindices
                    let k = Zindices[idx];
                    //console.log(idx+","+Zindices[idx]);
                    let total = 0, count = 0;
                    for (let i = 0; i < uniqueX.length; i++) {
                        for (let j = 0; j < uniqueY.length; j++) {
                            total += dataArray[i][j][k];
                            count++;
                        }
                    }

                    //results[uniqueZ[k]] = calculationType === 'mean' ? total / count : total;
                    //console.log(k+","+uniqueZ[k] +","+ results[uniqueZ[k]]);
                    results_name[idx] = uniqueZ[k];
                    results_value[idx] = calculationType === 'mean' ? total / count : total;
                }

            }
            //return results;
            return {results_name, results_value};
        }

        // 根據不同軸輸出一二維陣列
        function extractDataForAxis(axis, index) {
            let result = [];
            
            if (axis === 'X') {
                // 選取 X 軸時 只有 X 軸的排序維持不變 並提取一個 Y * Z 的二維數組
                let xIndex = index; // X 軸索引不變
                for (let i = 0; i < Yindices.length; i++) {
                    let yIndex = Yindices[i]; // 使用 Yindices 重新排序 Y 軸索引
                    let row = [];
                    for (let j = 0; j < Zindices.length; j++) {
                        let zIndex = Zindices[j]; // 使用 Zindices 重新排序Z軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            } else if (axis === 'Y') {
                // 選取 Y 軸時 只有 Y 軸的排序保持不變 並提取一個 X * Z 的二維數組
                let yIndex = index; // Y 軸索引不變
                for (let i = 0; i < Xindices.length; i++) {
                    let xIndex = Xindices[i]; // 使用 Xindices 重新排序X軸索引
                    let row = [];
                    for (let j = 0; j < Zindices.length; j++) {
                        let zIndex = Zindices[j]; // 使用 Zindices 重新排序Z軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            } else if (axis === 'Z') {
                // 選取 Z 軸時 只有 Z 軸的排序維持不變 並提取一個 X * Y 的二維數組
                let zIndex = index; // Z 軸索引不變
                for (let i = 0; i < Xindices.length; i++) {
                    let xIndex = Xindices[i]; // 使用 Xindices 重新排序X軸索引
                    let row = [];
                    for (let j = 0; j < Yindices.length; j++) {
                        let yIndex = Yindices[j]; // 使用 Yindices 重新排序 Y 軸索引
                        row.push(data_array[xIndex][yIndex][zIndex]);
                    }
                    result.push(row);
                }
            }
            return result;
        }

        // 創建 bar chart
        function updateBarChart(containerId, dataPoints, axis) {
            // 如果圖表已經存在，先銷毀它
            if (window[containerId + 'ChartInstance']) {
                // console.log('銷毀圖表實例:', containerId);
                window[containerId + 'ChartInstance'].destroy();
                window[containerId + 'ChartInstance'] = null; // 清空實例
            }

            const ctx = document.getElementById(containerId).getContext('2d', { willReadFrequently: true });

            // 預設和選取狀態下的顏色
            const defaultColor = 'rgba(133, 163, 245, 0.2)';
            const selectedColor = 'rgba(57, 108, 247, 0.5)';

            // // 排序資料點
            // const sortedDataPoints = Object.keys(dataPoints)
            //     .sort((a, b) => parseFloat(a) - parseFloat(b)) // 這裡確保數字類別能夠正確排序
            //     .reduce((acc, key) => {
            //         acc[key] = dataPoints[key];
            //         return acc;
            //     }, {});

            // 根據是否選取設定每個 bar 的顏色
            const backgroundColors = dataPoints.results_name.map(label => 
                categoryConditions.has(`${axis}:${label}`) ? selectedColor : defaultColor
            );

            // 建立新的長條圖
            window[containerId + 'ChartInstance'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    //labels: Object.keys(dataPoints),
                    labels: dataPoints.results_name,
                    datasets: [{
                        label: 'Value',
                        //data: Object.values(dataPoints), // 對應的資料點
                        data: dataPoints.results_value, // 對應的資料點
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(133, 163, 245, 0.7)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: { beginAtZero: true },
                        x: {
                            ticks: {
                                padding: 1, // 設定標籤與 Y 軸之間的距離
                                maxRotation: 90, // 最大旋轉角度
                                // minRotation: 90, // 最小旋轉角度 (設定為相同值使所有標籤保持相同角度)
                            }
                        }
                    },
                    responsive: true, // 確保響應式開啟
                    maintainAspectRatio: false // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
                }
            });

            // 綁定 mouse 事件處理拖曳
            ctx.canvas.addEventListener('mousedown', function(evt) {
                const element = window[containerId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                if (element.length > 0) {
                    isDragging = true;
                    dragStartIndex = element[0].index;
                    lastValidIndex = element[0].index;  // 初始化最後有效索引
                }
            });

            ctx.canvas.addEventListener('mousemove', function(evt) {
                if (isDragging) {
                    const element = window[containerId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                    if (element.length > 0) {
                        lastValidIndex = element[0].index;  // 更新最後有效索引
                    }
                }
            });

            ctx.canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    const end = Math.max(dragStartIndex, lastValidIndex);
                    const start = Math.min(dragStartIndex, lastValidIndex);
                    
                    // 對範圍內的每個 bar 進行選擇或取消選擇
                    for (let i = start; i <= end; i++) {
                        const label = window[containerId + 'ChartInstance'].data.labels[i];

                        // console.log(label);

                        const categoryKey = `${axis}:${label}`;

                        if (categoryConditions.has(categoryKey)) {
                            // 根據點擊的 bar 將條件添加至 categoryConditions
                            categoryConditions.delete(categoryKey);
                            window[containerId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = defaultColor; // 將顏色變回未選取的顏色
                        } else {
                            // 根據點擊的 bar 將條件添加至 categoryConditions
                            categoryConditions.add(categoryKey);
                            window[containerId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = selectedColor; // 將顏色變為選取的顏色
                        }
                        // console.log(categoryConditions);
                    }
                    window[containerId + 'ChartInstance'].update();

                    filterCubes();  // 根據所選條件進行篩選
                    isDragging = false;
                }
            });
            window[containerId + 'ChartInstance'];
        }

        // 計算 Histogram 用之 bins, counts
        function calculateBinsAndCounts(dataArray, globalMin, globalMax) {
            // 無限階扁平化數組
            const flattenData = dataArray.flat(Infinity);

            // 計算所有有效資料點的總數
            const n = flattenData.length;

            // 使用 Sturges' formula 計算區間數
            const numBins = Math.ceil(Math.log2(n) + 1);

            const minValue = globalMin;
            const maxValue = globalMax;
            const binSize = (maxValue - minValue) / numBins;

            let bins = Array.from({ length: numBins }, (_, i) => minValue + binSize * i);
            let counts = new Array(numBins).fill(0);

            // 遍歷扁平化後的資料數組
            flattenData.forEach(value => {
                let binIndex = Math.min(
                    Math.floor((value - minValue) / binSize),
                    numBins - 1 // 防止最大值超出最後一個區間
                );
                counts[binIndex]++;
            });

            // 更新 bins 為更友善的字串表示形式
            bins = bins.map((start, index) => {
                const end = start + binSize;
                return `${start.toFixed(2)}-${end.toFixed(2)}`;
            });

            return { bins, counts };
        }

        // 創建 Histogram
        function drawHistogram(chartId, bins, counts) {
            const ctx = document.getElementById(chartId).getContext('2d', { willReadFrequently: true });
            
            // 如果圖表已經存在，先銷毀它
            if (window[chartId + 'ChartInstance']) {
                window[chartId + 'ChartInstance'].destroy();
            }

            // 預設和選取狀態下的顏色
            const defaultColor = 'rgb(75, 192, 192, .2)';
            const selectedColor = 'rgb(23, 191, 191, .5)';

            // 根據是否選取設定每個 bar 的顏色
            const backgroundColors = bins.map(bin => selectedHistogramBars.has(bin) ? selectedColor : defaultColor);

            window[chartId + 'ChartInstance'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: bins, // 區間作為標籤
                    datasets: [{
                        label: 'Distribution',
                        data: counts, // 區間內資料點數量
                        backgroundColor: backgroundColors,
                        borderColor: 'rgb(75, 192, 192, .7)',
                        borderWidth: .5 // 邊框的寬度
                    }]
                },
                options: {
                    scales: {
                        y: { // y 軸配置
                            beginAtZero: true, // y 軸從 0 開始
                            title: {
                                display: true, // 顯示 y 軸標題
                                text: 'counts' // y 軸標題文本
                            }
                        }
                    },
                    barPercentage: 1.0, // 直方圖寬度佔分類寬度的比例 設定為 1 使柱子緊密排列
                    categoryPercentage: 1.0, // 類別之間的寬度佔總類別寬度的比例 設定為 1 減少類別之間的間隔
                    responsive: true, // 確保響應式開啟
                    maintainAspectRatio: false, // 如果需要，可以設定為 false 來允許高度也隨著寬度而變化
                }
            });

            // 綁定 mouse 事件處理拖曳
            ctx.canvas.addEventListener('mousedown', function(evt) {
                const element = window[chartId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                if (element.length > 0) {
                    isDragging = true;
                    dragStartIndex = element[0].index;
                    lastValidIndex = element[0].index;  // 初始化最後有效索引
                }
            });

            ctx.canvas.addEventListener('mousemove', function(evt) {
                if (isDragging) {
                    const element = window[chartId + 'ChartInstance'].getElementsAtEventForMode(evt, 'index', { intersect: true }, false);
                    if (element.length > 0) {
                        lastValidIndex = element[0].index;  // 更新最後有效索引
                    }
                }
            });

            ctx.canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    const end = Math.max(dragStartIndex, lastValidIndex);
                    const start = Math.min(dragStartIndex, lastValidIndex);
                    
                    // 對範圍內的每個 bar 進行選擇或取消選擇
                    for (let i = start; i <= end; i++) {
                        const label = window[chartId + 'ChartInstance'].data.labels[i];
                        if (selectedHistogramBars.has(label)) {
                            selectedHistogramBars.delete(label);
                            window[chartId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = defaultColor;  // 將顏色變回未選取的顏色

                            // 根據所選 value range 將條件添加至 rangeConditions
                            filterCubesbyvalueaddinselectedCategories(label)
                        } else {
                            selectedHistogramBars.add(label);
                            window[chartId + 'ChartInstance'].data.datasets[0].backgroundColor[i] = selectedColor;  // 將顏色變為選取的顏色

                            // 根據所選 value range 將條件添加至 rangeConditions
                            filterCubesbyvalueaddinselectedCategories(label)
                        }
                    }
                    window[chartId + 'ChartInstance'].update();

                    filterCubes();  // 根據所選條件進行篩選
                    isDragging = false;
                }
            });

            window[chartId + 'ChartInstance'];
        }

        // 根據所選 value range 將條件添加至 rangeConditions
        function filterCubesbyvalueaddinselectedCategories(clickedLabel) {
            const rangeParts = clickedLabel.split("-");
            const minValue = parseFloat(rangeParts[0]);
            const maxValue = parseFloat(rangeParts[rangeParts.length - 1]);

            const rangeKey = `${minValue}-${maxValue}`;

            if (rangeConditions.has(rangeKey)) {
                rangeConditions.delete(rangeKey);
            } else {
                rangeConditions.add(rangeKey);
            }
        }

        // 新增事件監聽器以便於當使用者改變選擇時執行操作
        document.getElementById('UnionorIntersection').addEventListener('change', function() {
            // 取得目前選取的值
            selectionType = this.value;
            filterCubes();
        });

        // 在頁面載入時停用 filteropacityRange
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('filteropacityRange').disabled = true;
            document.getElementById('filteropacityRange').style.cursor = 'not-allowed';
        });

        // 根據條件更新立方體的顯示狀態
        function filterCubes() {
            // console.log('-------');
            // console.log(categoryConditions);
            // console.log(rangeConditions);

            // 清空之前的過濾結果 (for 取得 cube 的位置)
            filteredPositions = [];

            var opacityRange = document.getElementById('opacityRange');
            var newOpacity = parseFloat(opacityRange.value);
            document.getElementById('opacityValue').textContent = newOpacity;

            // 更新 filter 掉之 cubes 透明度
            var filteropacityRange = document.getElementById('filteropacityRange');
            var filternewOpacity = parseFloat(filteropacityRange.value);
            document.getElementById('filteropacityValue').textContent = filternewOpacity;

            // for 禁止使用 and 禁止標誌
            if (categoryConditions.size != 0 || rangeConditions.size != 0) {
                document.getElementById('filteropacityRange').disabled = false;
                document.getElementById('filteropacityRange').style.cursor = 'auto';
            } else {
                document.getElementById('filteropacityRange').disabled = true;
                document.getElementById('filteropacityRange').style.cursor = 'not-allowed';
            }

            cubes.forEach((cubeRow, i) => cubeRow.forEach((cubeColumn, j) => cubeColumn.forEach((cube, k) => {
                if (cube) {
                    const cubeValue = cube.userData.value;
                    matchesCategoryConditions = categoryConditions.size === 0; // 如果沒有類別條件，則預設匹配
                    matchesRangeConditions = rangeConditions.size === 0; // 如果沒有範圍條件，則預設匹配

                    // 檢查類別條件
                    if (categoryConditions.size > 0 && rangeConditions.size == 0) {
                        if (selectionType === "Union") {
                            matchesCategoryConditions = [...categoryConditions].some(condition => {
                                const [axis, label] = condition.split(":");

                                const selectedIndex = {
                                    'X': uniqueX.indexOf(label),
                                    'Y': uniqueY.indexOf(label),
                                    'Z': uniqueZ.indexOf(label)
                                }[axis];
                                return {
                                    'X': Xindices[i] === selectedIndex,
                                    'Y': Yindices[j] === selectedIndex,
                                    'Z': Zindices[k] === selectedIndex
                                }[axis];
                            });

                            // // 移除浮動視窗及其包含的表格
                            // const existingWindow = document.getElementById('filtersamplelist');

                            // if (existingWindow) {
                            //     existingWindow.remove();
                            // }
                        } else if (selectionType === "Intersection") {
                            // 將 categoryConditions 轉換為 Array 以使用 filter
                            const categoryConditionsArray = Array.from(categoryConditions);

                            // 對於每個軸分開處理
                            const xConditions = categoryConditionsArray.filter(condition => condition.startsWith('X:')).map(condition => condition.split(':')[1]);
                            const yConditions = categoryConditionsArray.filter(condition => condition.startsWith('Y:')).map(condition => condition.split(':')[1]);
                            const zConditions = categoryConditionsArray.filter(condition => condition.startsWith('Z:')).map(condition => condition.split(':')[1]);

                            // 判斷 x, y, z 軸的條件是否符合
                            const matchX = xConditions.length === 0 || xConditions.some(label => Xindices[i] === uniqueX.indexOf(label));
                            const matchY = yConditions.length === 0 || yConditions.some(label => Yindices[j] === uniqueY.indexOf(label));
                            const matchZ = zConditions.length === 0 || zConditions.some(label => Zindices[k] === uniqueZ.indexOf(label));

                            // 如果 x, y, z 軸條件都滿足則匹配
                            matchesCategoryConditions = matchX && matchY && matchZ;
                        }
                    } else if (rangeConditions.size > 0 && categoryConditions.size == 0) { // 檢查數值範圍條件
                        matchesRangeConditions = [...rangeConditions].some(condition => {
                            const [minValue, maxValue] = condition.split("-").map(Number);
                            return cubeValue >= minValue && cubeValue <= maxValue;
                        });
                    } else if (categoryConditions.size > 0 && rangeConditions.size > 0) { // 若同時有類別條件和數值範圍條件，必須同時滿足
                        matchesCategoryConditions = [...categoryConditions].some(condition => {
                            const [axis, label] = condition.split(":");
                            const selectedIndex = {
                                'X': uniqueX.indexOf(label),
                                'Y': uniqueY.indexOf(label),
                                'Z': uniqueZ.indexOf(label)
                            }[axis];
                            return {
                                'X': Xindices[i] === selectedIndex,
                                'Y': Yindices[j] === selectedIndex,
                                'Z': Zindices[k] === selectedIndex
                            }[axis];
                        });
                        matchesRangeConditions = [...rangeConditions].some(condition => {
                            const [minValue, maxValue] = condition.split("-").map(Number);
                            return cubeValue >= minValue && cubeValue <= maxValue;
                        });

                        // 重置 UnionorIntersection 下拉式選單回到預設選項 (Union)
                        document.getElementById('UnionorIntersection').selectedIndex = 0;

                        selectionType = 'Union';

                        // // 移除浮動視窗及其包含的表格
                        // const existingWindow = document.getElementById('filtersamplelist');

                        // if (existingWindow) {
                        //     existingWindow.remove();
                        // }
                    }
                    
                    var value = cube.userData.value; // 立方體的值

                    if (value == null) { // 如果為遺失值，透明度為 0
                        cube.material.opacity = 0;
                        cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                    } 
                    else {
                        if (categoryConditions.size == 0 && rangeConditions.size == 0) { // 如果長條圖跟直方圖都沒有選擇 bar，且非遺失值，則更新透明度
                            // 非遺失值值立方體根據滑動條更新透明度
                            if (value < globalSliderMin || value > globalSliderMax) {
                                // 值不在滑動條選擇的範圍內
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                // console.log(cubesOpacity);
                            } else if (globalSliderMin <= value <= globalSliderMax) {
                                // 值在滑動條選擇的範圍內
                                cube.material.opacity = newOpacity;

                                // 追蹤透明度值
                                cubesOpacity[i][j][k] = cube.material.opacity; 
                                //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);

                                if (selectionType === "Intersection") {
                                    if (globalSliderMin != globalMin || globalSliderMax != globalMax) {
                                        // 將符合條件的 cube 的位置儲存到 array 中
                                        filteredPositions.push({ i, j, k });
                                    }
                                }
                                // if (globalSliderMin != globalMin || globalSliderMax != globalMax) {
                                //     // 將符合條件的 cube 的位置儲存到 array 中
                                //     filteredPositions.push({ i, j, k });
                                // }
                            }
                        }
                        else
                        {   
                            // 非遺失值立方體根據滑動條更新透明度
                            if (value < globalSliderMin || value > globalSliderMax) {
                                // 值不在滑動條選擇的範圍內
                                cube.material.opacity = 0;
                                cubesOpacity[i][j][k] = 0; // 追蹤透明度值
                                // console.log(cubesOpacity);
                            } else if (globalSliderMin <= value <= globalSliderMax) {
                                // 值在滑動條選擇的範圍內
                                if (matchesCategoryConditions && matchesRangeConditions) {
                                    cube.material.opacity = newOpacity;
                                    cubesOpacity[i][j][k] = cube.material.opacity;

                                    if (selectionType === "Intersection") {
                                        // 將符合條件的 cube 的位置儲存到 array 中
                                        filteredPositions.push({ i, j, k });
                                    }
                                    // // 將符合條件的 cube 的位置儲存到 array 中
                                    // filteredPositions.push({ i, j, k });
                                } else {
                                    cube.material.opacity = filternewOpacity;
                                    cubesOpacity[i][j][k] = cube.material.opacity;

                                    //console.log(globalSliderMin+","+globalSliderMax+": "+value+":"+i+","+j+","+k);
                                }
                            }
                        }
                    }
                }
            })));
            // console.log('matchesCategoryConditions', matchesCategoryConditions);
            // console.log('matchesRangeConditions', matchesRangeConditions);

            // 呼叫函數創建變數列表
            transferPositionsToDatatable();
        }

        // 創建變數列表
        function transferPositionsToDatatable() {
            // 查找是否已經存在浮動視窗
            const existingWindow = document.getElementById('filtersamplelist');

            // 清空目前 filteredColors
            filteredColors = [];

            // 將 currentCubeColors 轉換為一個位置到顏色的映射
            const colorMap = {};
            currentCubeColors.forEach(({ position, color }) => {
                const key = `${position.i},${position.j},${position.k}`;
                colorMap[key] = color;
            });

            // 將 filteredPositions 和 colorMap 結合
            filteredColors = filteredPositions.map(({ i, j, k }) => {
                const key = `${i},${j},${k}`;
                return {
                    position: { i, j, k },
                    color: colorMap[key] || 'rgba(255,255,255,0)' // 如果沒有顏色資料則使用預設顏色
                };
            });

            // 檢查 filteredColors 是否為空
            if (filteredColors.length === 0) {
                // 如果 filteredColors 為空
                if (existingWindow) {
                    // 如果已有浮動視窗，則移除它
                    existingWindow.remove();
                }
                // 否則不需要建立任何浮動視窗，函數結束
                return;
            } else {
                // 如果 filteredColors 不為空
                let table;
            
                // 如果 filteredColors 不為空，且如果浮動視窗已存在，直接更新內容；否則建立新視窗
                if (existingWindow) {
                    // 找到現有視窗中的表格容器
                    table = existingWindow.querySelector('table.data-table');
                    table.innerHTML = ''; // 清空舊的表格內容
                } else {
                    // 建立一個表格元素
                    table = document.createElement('table');
                    table.classList.add('data-table'); // 新增一個類別以便於樣式調整

                    // 新增邊框樣式
                    table.style.borderCollapse = 'collapse'; // 確保邊框合併
                    table.style.width = 'calc(100% - 40px)'; // 表格寬度，減去左右邊距
                    table.style.margin = '20px auto'; // 上下邊距 20px，左右置中

                    // 使用 createFloatingWindow_samplelist 建立一個浮動視窗來顯示表格
                    createFloatingWindow_samplelist('filtersamplelist', 'Filtered Sample Table', table, 'auto', 75, 110, 350, 350);
                }

                // 建立表頭
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');

                // 設定表頭的欄位名稱
                [fieldX, fieldY, fieldZ, selectedValueField].forEach(fieldName => {
                    const th = document.createElement('th');
                    th.textContent = fieldName;

                    // 新增表頭 cell 的邊框樣式
                    th.style.border = '1px solid #ddd'; // 設定邊框樣式
                    th.style.padding = '8px'; // 內邊距
                    th.style.backgroundColor = '#f2f2f2'; // 表頭背景色
                    th.style.textAlign = 'left'; // cell 內容左對齊
                    th.style.fontSize = '13px'; // 表頭字體大小

                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);
                table.appendChild(thead);

                // 建立表格主體
                tbody = document.createElement('tbody');

                // // 查看結合後之訊息
                // console.log('filteredColors', filteredColors);

                // 遍歷 filteredColors
                filteredColors.forEach(({ position, color }) => {
                    const { i, j, k } = position;

                    // 取得 data_array 中的值
                    const dataValue = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                    // 取得各軸類別的值
                    const xLabel = uniqueX[Xindices[i]];
                    const yLabel = uniqueY[Yindices[j]];
                    const zLabel = uniqueZ[Zindices[k]];

                    // 建立表格 row
                    const row = document.createElement('tr');

                    // 建立並新增 cell (新增儲存格邊框樣式)
                    const cellX = document.createElement('td');
                    cellX.textContent = xLabel;
                    cellX.style.border = '1px solid #ddd'; // cell 邊框
                    cellX.style.padding = '8px'; // 內邊距
                    cellX.style.textAlign = 'left'; // cell 內容左對齊
                    cellX.style.fontSize = '13px'; // 字體大小
                    row.appendChild(cellX);

                    const cellY = document.createElement('td');
                    cellY.textContent = yLabel;
                    cellY.style.border = '1px solid #ddd'; // cell 邊框
                    cellY.style.padding = '8px'; // 內邊距
                    cellY.style.textAlign = 'left'; // cell 內容左對齊
                    cellY.style.fontSize = '13px'; // 字體大小
                    row.appendChild(cellY);

                    const cellZ = document.createElement('td');
                    cellZ.textContent = zLabel;
                    cellZ.style.border = '1px solid #ddd'; // cell 邊框
                    cellZ.style.padding = '8px'; // 內邊距
                    cellZ.style.textAlign = 'left'; // cell 內容左對齊
                    cellZ.style.fontSize = '13px'; // 字體大小
                    row.appendChild(cellZ);

                    const cellValue = document.createElement('td');
                    cellValue.textContent = dataValue;
                    cellValue.style.border = '1px solid #ddd'; // cell 邊框
                    cellValue.style.padding = '8px'; // 內邊距
                    cellValue.style.textAlign = 'left'; // cell 內容左對齊
                    cellValue.style.fontSize = '13px'; // 字體大小

                    // 將 RGB 顏色轉換為 rgba 顏色 (新增透明度)
                    const rgbaColor = color.replace('rgb', 'rgba').replace(')', `,${.3})`);

                    // 設定初始背景顏色
                    cellValue.style.backgroundColor = rgbaColor;

                    row.appendChild(cellValue);

                    // 將 row 新增至表格主體
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
            }
        }

        // 按下 Reset Filter Setting 按鈕時，將 cube 回復原狀
        document.getElementById('resetToOriginalCube').addEventListener('click', function() {
            for (let i = 0; i < Xindices.length; i++) {
                for (let j = 0; j < Yindices.length; j++) {
                    for (let k = 0; k < Zindices.length; k++) {
                        // 在立方體已經創建的基礎上進行
                        let cube = cubes[i][j][k]; // 取得現有的立方體

                        if (cube) {
                            // 使用排序後的索引從 data_array 取得值
                            let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                            if (value !== null) {

                                cube.material.opacity = currentOpacity;
                                // 追蹤透明度值
                                cubesOpacity[i][j][k] = cube.material.opacity; 

                            } else {
                                cube.material.opacity = 0; // 空值立方體保持完全透明
                            }
                        }
                    }
                }
            }
            clearbar();

            applyChangesBasedOnNewIndices(globalvaluedfields);

            // 重置 calculationType 下拉式選單回到預設選項 (sum)
            document.getElementById('calculationType').selectedIndex = 0;

            calculationType = 'sum';

            // 根據 calculationType 重新繪圖
            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            updateBarChart('chartX', chartDataX, 'X');

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            updateBarChart('chartY', chartDataY, 'Y');

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            updateBarChart('chartZ', chartDataZ, 'Z');
            
            // 重置 UnionorIntersection 下拉式選單回到預設選項 (Union)
            document.getElementById('UnionorIntersection').selectedIndex = 0;

            selectionType = 'Union';

            // 重置滑動條到原始狀態 (Restricted Display)
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 更新滑動條上顯示的標籤 (Restricted Display)
            $("#double-slider .ui-slider-handle").eq(0).find(".ui-slider-value").text(globalMin.toFixed(1));
            $("#double-slider .ui-slider-handle").eq(1).find(".ui-slider-value").text(globalMax.toFixed(1));

            // 更新全域變數
            globalSliderMinforcolor = globalMin;
            globalSliderMaxforcolor = globalMax;

            // 重置滑動條到原始狀態 (Filter Cubes Value)
            $("#double-slider-cubesvalue").slider("values", [globalMin, globalMax]);

            // 更新滑動條上顯示的標籤 (Filter Cubes Value)
            $("#double-slider-cubesvalue .ui-slider-handle").eq(0).find(".ui-slider-value").text(globalMin.toFixed(1));
            $("#double-slider-cubesvalue .ui-slider-handle").eq(1).find(".ui-slider-value").text(globalMax.toFixed(1));

            // 更新全域變數
            globalSliderMin = globalMin;
            globalSliderMax = globalMax;

            // 重置 Filter Cubes Opacity 滑動條和顯示的值
            document.getElementById('filteropacityRange').value = 0;
            document.getElementById('filteropacityValue').textContent = 0;

            // 自動隱藏表格
            const existingWindow = document.getElementById('filtersamplelist');
            if (existingWindow) {
                existingWindow.remove(); // 移除浮動視窗及其包含的表格
            }
        });

        function clearbar() {
            // 清空集合
            categoryConditions.clear();
            rangeConditions.clear(); // 用於追蹤選中的範圍 (for histogram)

            // console.log(categoryConditions);

            selectedHistogramBars.clear();

            const chartInstances = ['chartXChartInstance', 'chartYChartInstance', 'chartZChartInstance'];

            // 檢查 bar chart 圖表實例是否存在 if so 重設顏色
            chartInstances.forEach(updateChartColors);

            // 檢查 Histogram 圖表實例是否存在 if so 重設顏色
            if (window.HistogramChartInstance) {
                const datasetforHistogram = window.HistogramChartInstance.data.datasets[0];
                const defaultColorforHistogram = 'rgb(75, 192, 192, .2)';

                // 變更所有條形的顏色為預設顏色
                datasetforHistogram.backgroundColor = datasetforHistogram.backgroundColor.map(() => defaultColorforHistogram);

                // 更新圖表以應用顏色更改
                window.HistogramChartInstance.update();
            }
        }

        // 更新圖表顏色 (for resetToOriginalCube)
        function updateChartColors(chartInstanceName) {
            const defaultColor = 'rgba(133, 163, 245, 0.2)'; // 設定預設顏色
            const chartInstance = window[chartInstanceName]; // window[chartId + 'ChartInstance']
            if (chartInstance) {
                const dataset = chartInstance.data.datasets[0];
                dataset.backgroundColor = dataset.backgroundColor.map(() => defaultColor);
                chartInstance.update();
            }
        }

        // 清除場景中的所有子對象並釋放內存
        function clearAllSceneObjects() {
            // 遍歷並移除場景中的所有子對象
            scene.children.forEach(object => {
                // 如果有幾何體，釋放它
                if (object.geometry) {
                    object.geometry.dispose();
                }

                // 如果有材質，釋放它
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        // 如果材質是 array，遍歷釋放
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }

                // 如果有紋理，釋放它
                if (object.material && object.material.map) {
                    object.material.map.dispose();
                }

                // 從場景中移除對象
                scene.remove(object);
            });

            // 再次遍歷刪除所有子對象，確保場景完全清空
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            // 重新渲染場景以反映更新
            // renderer.render(scene, camera);
        }

        // 清除所有浮動視窗
        function clearAllFloatingWindows() {
            const container = document.getElementById('floatingWindowContainer');
            // 檢查容器是否存在
            if (container) {
                // 遍歷並移除容器中的所有子元素
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }
        }

        // 清除 colorbar
        function removeColorbar() {
            var colorbarContainer = document.getElementById('colorbar-container');
            
            if (!isDataLoaded) {
                if (colorbarContainer) {
                    // 移除 colorbar 容器及其子元素
                    colorbarContainer.remove();
                }
            }
        }
    
        // 觸發文件輸入的點擊事件
        document.getElementById('fileButton').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        // 顯示資料處理面板
        document.getElementById('fileInput').addEventListener('change', function() {
            if (this.files && this.files.length > 0) {
                document.getElementById('dataProcessingPanel').style.display = 'block';
            }
        });

        // 按 ok button 之後隱藏面板
        document.getElementById('okButton').addEventListener('click', function() {
            document.getElementById('dataProcessingPanel').style.display = 'none';
        });

        // 按 cancel button 之後隱藏面板並重置 file input
        document.getElementById('cancelButton').addEventListener('click', function() {
            document.getElementById('dataProcessingPanel').style.display = 'none';
            // 重置 file input，這樣再次選擇同一個文件也會觸發 change 事件
            document.getElementById('fileInput').value = null;
        });

        // 追蹤欄位之反白狀態
        var highlightedColumns = {
            'multiSelectX': null,
            'multiSelectY': null,
            'multiSelectZ': null,
            'singleSelect': null
        };

        // 將下拉式選單所選之欄位反白
        function highlightColumn(selectElementId, selectedColumnName, highlightClass) {
            var headers = document.querySelectorAll('#dataPreviewHead th');
            var columnIndex = -1;

            // 找出對應的 column 索引
            headers.forEach((th, index) => {
                if (th.textContent === selectedColumnName) {
                    columnIndex = index;
                }
            });

            // 清除之前這個下拉式選單反白的欄位
            if (highlightedColumns[selectElementId] !== null) {
                document.querySelectorAll(`#dataPreviewBody tr`).forEach(row => {
                    var cell = row.cells[highlightedColumns[selectElementId]];
                    if (cell) {
                        // 移除舊的反白類別
                        cell.classList.remove(highlightClass);
                    }
                });
            }

            // 更新物件以追蹤新的反白欄位
            highlightedColumns[selectElementId] = columnIndex;

            // 反白新的欄位
            if (columnIndex > -1) {
                document.querySelectorAll(`#dataPreviewBody tr`).forEach(row => {
                    var cell = row.cells[columnIndex];
                    if (cell) {
                        // 添加新的反白類別
                        cell.classList.add(highlightClass);
                    }
                });
            }
        }

        // 檢查是否有 singleSelect 的選項被清除，如果有移除其反白效果
        function clearSingleSelectHighlight() {
            var singleSelect = document.getElementById('singleSelect');
            if (singleSelect.value) {
                // 清空 singleSelect 的值
                singleSelect.value = null;
                // 調用 highlightColumn 移除反白效果
                highlightColumn('singleSelect', '', 'highlight-color-4');
                
                // 同時更新最小最大值顯示為預設或空白
                document.getElementById('valuemin').textContent = '';
                document.getElementById('valuemax').textContent = '';
            }
        }

        // 監聽 discr、conti 之 6 個下拉式選單
        document.addEventListener('DOMContentLoaded', function() {
            // 為每個下拉式選單設定事件監聽器
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`select${i}`).addEventListener('change', function() {
                    // 重新計算並應用 highlight
                    applyHighlights();
                });
            }
        });

        // 根據下拉式選單的選擇應用 highlight
        function applyHighlights() {
            // 首先清除所有 highlight
            document.querySelectorAll('#dataPreviewBody tr td').forEach(cell => {
                for (let i = 1; i <= 6; i++) {
                    cell.classList.remove(`highlight-${i}`);
                }
            });

            let highlightIndex = 0; // 記錄從哪一列開始 highlight

            for (let i = 1; i <= 6; i++) {
                const selectValue = parseInt(document.getElementById(`select${i}`).value, 10);
                
                // highlight 從 highlightIndex 開始的 selectValue 個列
                if (selectValue > 0) {
                    document.querySelectorAll('#dataPreviewBody tr').forEach(row => {
                        for (let j = highlightIndex; j < highlightIndex + selectValue && j < row.cells.length; j++) {
                            const cell = row.cells[j];
                            if (cell) {
                                cell.classList.add(`highlight-${i}`); // 使用對應的顏色進行 highlight
                            }
                        }
                    });

                    // 蒐集選取的 column 名
                    logSelectedColumnNames(highlightIndex, selectValue, i);
                    // console.log(selectedColumns[`select${i}`]); // selectedColumns.select1
                }
                highlightIndex += selectValue; // 更新下一個 highlight column 的起始索引
            }
        }

        // 定義一個物件來儲存每個 Select 的 columnNames (1: Xd、2: Xc、3: Yd、4: Yc、5: Zd、6: Zc)
        let selectedColumns = {
            select1: [],
            select2: [],
            select3: [],
            select4: [],
            select5: [],
            select6: []
        };

        // 蒐集選取的 column 名
        function logSelectedColumnNames(startIndex, count, selectNumber) {
            let columnNames = [];
            // 從第 startIndex 欄位開始，收集 count 個 column 名
            for (let i = startIndex; i < startIndex + count; i++) {
                let columnName = document.querySelector(`#dataPreviewHead th:nth-child(${i + 1})`).textContent;
                columnNames.push(columnName);
            }

            // 根據 selectNumber 儲存到對應的 key 中
            selectedColumns[`select${selectNumber}`] = columnNames;

            // 列印選取的 column 名
            // console.log(`Select${selectNumber} selected columns:`, columnNames.join(", "));
        }

        // 這個物件將用來存儲對應的資料
        let selectedData = {
            select1: [],
            select2: [],
            select3: [],
            select4: [],
            select5: [],
            select6: []
        };
        
        // 用來存儲重新編碼的類別映射
        let categoryMapping = {};

        // // 依據欄位名稱，從 parsedData 中提取對應的資料，並對 select1, select3, select5 重新編碼
        // function extractDataBasedOnSelectedColumns() {
        //     for (let i = 1; i <= 6; i++) {
        //         // 取得每個 select 中的欄位名稱陣列
        //         let columns = selectedColumns[`select${i}`];
        //         selectedData[`select${i}`] = [];

        //         // 只有 select1, select3, select5 需要重新編碼
        //         if (i === 1 || i === 3 || i === 5) {
        //             categoryMapping[`select${i}`] = {}; // 初始化類別映射表

        //             // 建立每個欄位的類別重新編碼映射
        //             columns.forEach(columnName => {
        //                 let uniqueValues = [...new Set(parsedData.map(row => row[columnName]))]; // 找到欄位的唯一值
        //                 // console.log(uniqueValues);
        //                 uniqueValues.forEach((value, index) => {
        //                     categoryMapping[`select${i}`][value] = index; // 從 0 開始編碼
        //                 });
        //             });

        //             // 遍歷 parsedData 的每一列，並根據欄位名稱提取對應的資料
        //             parsedData.forEach(row => {
        //                 let rowData = {};
        //                 columns.forEach(columnName => {
        //                     let originalValue = row[columnName];
        //                     let recodedValue = categoryMapping[`select${i}`][originalValue]; // 重新編碼
        //                     rowData[columnName] = recodedValue;
        //                 });
        //                 // 將提取的資料 push 到對應的 select array 中
        //                 selectedData[`select${i}`].push(rowData);
        //             });

        //         } else {
        //             // 不需要重新編碼，直接提取資料
        //             parsedData.forEach(row => {
        //                 let rowData = {};
        //                 columns.forEach(columnName => {
        //                     rowData[columnName] = row[columnName]; // 保持原始資料
        //                 });
        //                 // 將提取的資料 push 到對應的 select array 中
        //                 selectedData[`select${i}`].push(rowData);
        //             });
        //         }
        //     }
        //     // 列印 selectedData 和 categoryMapping 來檢查結果
        //     console.log('Re-coded Selected Data:', selectedData);
        //     console.log('Category Mapping:', categoryMapping);
        // }

        // 依據欄位名稱，從 parsedData 中提取對應的資料，並對 select1, select3, select5 重新編碼
        function extractDataBasedOnSelectedColumns() {
            for (let i = 1; i <= 6; i++) {
                // 取得每個 select 中的欄位名稱陣列
                let columns = selectedColumns[`select${i}`];
                selectedData[`select${i}`] = [];

                // 如果 columns 為空，不進行後續操作
                if (!columns || columns.length === 0) {
                    continue; // 略過該 select 的處理
                }

                // 確定要加入的前置欄位（依據 select1/2, select3/4, select5/6）
                let prefixField;
                if (i === 1 || i === 2) {
                    prefixField = fieldX;
                } else if (i === 3 || i === 4) {
                    prefixField = fieldY;
                } else if (i === 5 || i === 6) {
                    prefixField = fieldZ;
                }

                // 只有 select1, select3, select5 需要重新編碼
                if (i === 1 || i === 3 || i === 5) {
                    categoryMapping[`select${i}`] = {}; // 初始化類別映射表

                    // 建立每個欄位的類別重新編碼映射
                    columns.forEach(columnName => {
                        let uniqueValues = [...new Set(parsedData.map(row => row[columnName]))]; // 找到欄位的唯一值
                        uniqueValues.forEach((value, index) => {
                            categoryMapping[`select${i}`][value] = index; // 從 0 開始編碼
                        });
                    });

                    // 遍歷 parsedData 的每一列，並根據欄位名稱提取對應的資料
                    let uniqueSet = new Set();
                    parsedData.forEach(row => {
                        let rowData = {};
                        if (prefixField) {
                            rowData[prefixField] = row[prefixField]; // 加入前置欄位的資料
                        }
                        columns.forEach(columnName => {
                            let originalValue = row[columnName];
                            let recodedValue = categoryMapping[`select${i}`][originalValue]; // 重新編碼
                            rowData[columnName] = recodedValue;
                        });

                        // 使用 JSON.stringify 將每個 rowData 轉換為字符串來確保唯一性
                        let rowDataString = JSON.stringify(rowData);
                        if (!uniqueSet.has(rowDataString)) {
                            uniqueSet.add(rowDataString); // 添加到唯一集合中
                            selectedData[`select${i}`].push(rowData); // 只有當不重複時才 push 資料
                        }
                    });

                    if(i == 1)
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(selectedData[`select${i}`][j][columnName]);                             
                            });
                            xd.push(tmpArray);
                        }

                        columns.forEach(columnName => {
                            let tmpArray = [];
                            for(let key in categoryMapping[`select${i}`])
                            {
                                tmpArray.push(categoryMapping[`select${i}`][key]); 
                            }
                            xd_cate_col.push(tmpArray);
                            xd_name.push(columnName);
                        });
                        xd_num = columns.length;
                    }
                    else if(i == 3)
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(selectedData[`select${i}`][j][columnName]);
                            });
                            yd.push(tmpArray);
                        }
                        
                        columns.forEach(columnName => {
                            let tmpArray = [];
                            for(let key in categoryMapping[`select${i}`])
                            {
                                tmpArray.push(categoryMapping[`select${i}`][key]); 
                            }
                            yd_cate_col.push(tmpArray);
                            yd_name.push(columnName);
                        });
                        yd_num = columns.length;
                    }
                    else
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(selectedData[`select${i}`][j][columnName]);
                            });
                            zd.push(tmpArray);
                        }
                        
                        columns.forEach(columnName => {
                            let tmpArray = [];
                            for(let key in categoryMapping[`select${i}`])
                            {
                                tmpArray.push(categoryMapping[`select${i}`][key]); 
                            }
                            zd_cate_col.push(tmpArray);
                            zd_name.push(columnName);
                        });
                        zd_num = columns.length;
                    }

                } else {
                    // 不需要重新編碼，直接提取資料
                    let uniqueSet = new Set();
                    parsedData.forEach(row => {
                        let rowData = {};
                        if (prefixField) {
                            rowData[prefixField] = row[prefixField]; // 加入前置欄位的資料
                        }
                        columns.forEach(columnName => {
                            rowData[columnName] = row[columnName]; // 保持原始資料
                        });

                        // 使用 JSON.stringify 將每個 rowData 轉換為字符串來確保唯一性
                        let rowDataString = JSON.stringify(rowData);
                        if (!uniqueSet.has(rowDataString)) {
                            uniqueSet.add(rowDataString); // 添加到唯一集合中
                            selectedData[`select${i}`].push(rowData); // 只有當不重複時才 push 資料
                        }
                    });

                    if(i == 2)
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(Number(selectedData[`select${i}`][j][columnName]));
                            });
                            xc.push(tmpArray);
                        }
                        columns.forEach(columnName => {
                            xc_name.push(columnName);
                        });
                        xc_num = columns.length;
                        
                    }
                    else if(i == 4)
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(Number(selectedData[`select${i}`][j][columnName]));
                            });
                            yc.push(tmpArray);
                        }
                        columns.forEach(columnName => {
                            yc_name.push(columnName);
                        });
                        yc_num = columns.length;
                    }
                    else
                    {                        
                        for(let j = 0; j < selectedData[`select${i}`].length; j++)
                        {
                            let tmpArray = [];
                            columns.forEach(columnName => {
                                tmpArray.push(Number(selectedData[`select${i}`][j][columnName]));
                            });
                            zc.push(tmpArray);
                        }

                        columns.forEach(columnName => {
                            zc_name.push(columnName);
                        });
                        zc_num = columns.length;
                    }
                }
            }
            // 列印 selectedData 和 categoryMapping 來檢查結果
            console.log('Re-coded Selected Data:', selectedData);
            console.log('Category Mapping:', categoryMapping);
        }


        // 選擇 Example Data or Import Data 的 radio
        const defaultRadio = document.getElementById('defaultdata');
        const defaultDataSelect = document.getElementById('defaultdataselest');
        const importRadio = document.getElementById('importdata');
        const fileButton = document.getElementById('fileButton');
        const fileInput = document.getElementById('fileInput');
        const fileInputLabel = document.getElementById('fileInputLabel');

        var savedRadio = sessionStorage.getItem('selectedRadio');

        document.addEventListener("DOMContentLoaded", function() {
            // 恢復 radio 狀態
            savedRadio = sessionStorage.getItem('selectedRadio');

            if (savedRadio) {
                document.getElementById(savedRadio).checked = true;

                // 檢查 savedRadio 是否是 defaultdata
                if (savedRadio === 'defaultdata') {
                    // 把 savedRadio 的值存儲到 defaultRadio 中
                    defaultRadio.checked = true;
                } else if (savedRadio === 'importdata') {
                    importRadio.checked = true;
                }
            }
            // console.log(savedRadio);

            // 恢復下拉式選單狀態
            const savedDropdownValue = sessionStorage.getItem('selectedDropdown');
            if (savedDropdownValue) {
                document.getElementById('defaultdataselest').value = savedDropdownValue;
            }

            // 阻止 fileButton 的默認提交行為
            const fileButton = document.getElementById('fileButton');
            fileButton.addEventListener('click', function(event) {
                event.preventDefault(); // 阻止默認的表單提交行為
            });
            
            // 初始化根據當前選擇狀態繪製立方體
            if (defaultRadio.checked) {
                fileButton.disabled = true;
                fileButton.style.cursor = 'not-allowed';
                fileInput.disabled = true;
                fileInputLabel.style.cursor = 'not-allowed';
                fileInputLabel.style.opacity = '.5';

                defaultDataSelect.disabled = false;
                defaultDataSelect.style.cursor = 'auto';

                fetchAndPlotData();
            } else if (importRadio.checked) {
                defaultDataSelect.disabled = true;
                defaultDataSelect.style.cursor = 'not-allowed';

                fileButton.disabled = false;
                fileButton.style.cursor = 'pointer';
                fileInput.disabled = false;
                fileInputLabel.style.cursor = 'pointer';
                fileInputLabel.style.opacity = '1';
            }

            // 監聽下拉式選單變化
            defaultDataSelect.addEventListener('change', function() {
                // 將選中的 defaultDataSelect 的值保存到 sessionStorage (localStorage)
                sessionStorage.setItem('selectedDropdown', this.value);

                // 重新整理頁面
                refreshPage();

                fetchAndPlotData(); // 根據下拉式選單選擇不同資料文件
            });

            // 根據選擇的 radio 更新控件狀態
            document.querySelectorAll('input[name="datafile"]').forEach(function(radio) {
                radio.addEventListener("change", function(event) {
                    // 將選中的 radio 按鈕的值保存到 sessionStorage
                    sessionStorage.setItem('selectedRadio', event.target.id);

                    if (defaultRadio.checked) {
                        fileButton.disabled = true;
                        fileButton.style.cursor = 'not-allowed';
                        fileInput.disabled = true;
                        fileInputLabel.style.cursor = 'not-allowed';
                        fileInputLabel.style.opacity = '.5';

                        defaultDataSelect.disabled = false;
                        defaultDataSelect.style.cursor = 'auto';

                        // 重新整理頁面
                        refreshPage();
                    } else if (importRadio.checked) {
                        defaultDataSelect.disabled = true;
                        defaultDataSelect.style.cursor = 'not-allowed';

                        fileButton.disabled = false;
                        fileButton.style.cursor = 'pointer';
                        fileInput.disabled = false;
                        fileInputLabel.style.cursor = 'pointer';
                        fileInputLabel.style.opacity = '1';

                        // 重新整理頁面
                        refreshPage();
                    }
                });
            });
        });

        // 重新整理頁面
        function refreshPage() {
            window.location.reload();
        }

        // 讀取 CSV 檔案並繪製立方體 (Example Data)
        function fetchAndPlotData() {
            const defaultDataselectedOption = defaultDataSelect.value;

            // 根據選項選擇不同的檔案路徑
            let filePath;

            if (defaultDataselectedOption === 'airpollution') {
                filePath = 'data/df_air.csv';
            } else if (defaultDataselectedOption === 'premierleague') {
                filePath = 'data/df_football.csv';
            }

            // 使用 fetch API 讀取 CSV 文件
            fetch(filePath)
                .then(response => response.text()) // 讀取文件內容為文字
                .then(csvData => {
                    const parsedData = parseCSV(csvData); // 解析 CSV 資料

                    if (parsedData.data.length === 0) {
                        throw new Error("No data in CSV file");
                    }

                    // 從解析後的結果提取欄位名和數值
                    const headers = parsedData.headers; // 取得 CSV 檔案的欄位名
                    const dataRows = parsedData.data; // 取得 CSV 檔案的數值

                    // 前三個欄位為 selectedFields，第四個欄位為 selectedValueField
                    var defaultDataselectedFields = [
                        [headers[0]],
                        [headers[1]],
                        [headers[2]],
                    ];
                    var defaultDataselectedValueField = headers[3];

                    globalvaluedfields = defaultDataselectedValueField; // for tooltip

                    // console.log(defaultDataselectedFields);
                    // console.log(defaultDataselectedValueField);
                    // console.log(dataRows);

                    // 初始化 cubeSizeX, cubeSizeY, cubeSizeZ 為 1 或使用者指定的值
                    cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value) || 1;
                    cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value) || 1;
                    cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value) || 1;

                    document.getElementById('cubeSizeX').value = cubeSizeX;
                    document.getElementById('cubeSizeY').value = cubeSizeY;
                    document.getElementById('cubeSizeZ').value = cubeSizeZ;

                    // 繪製 cube
                    processDataAndPlot(dataRows, defaultDataselectedFields, defaultDataselectedValueField, cubeSizeX, cubeSizeY, cubeSizeZ);

                    // 先利用預設值計算並創建圖表
                    let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
                    let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
                    let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

                    // 建立圖表的容器元素
                    const chartContainerX = document.createElement('div');
                    const canvasX = document.createElement('canvas');
                    canvasX.id = 'chartX';
                    chartContainerX.appendChild(canvasX);

                    const chartContainerY = document.createElement('div');
                    const canvasY = document.createElement('canvas');
                    canvasY.id = 'chartY';
                    chartContainerY.appendChild(canvasY);

                    const chartContainerZ = document.createElement('div');
                    const canvasZ = document.createElement('canvas');
                    canvasZ.id = 'chartZ';
                    chartContainerZ.appendChild(canvasZ);

                    chartContainerX.style.width = '100%';
                    chartContainerX.style.height = '80%';

                    chartContainerY.style.width = '100%';
                    chartContainerY.style.height = '80%';

                    chartContainerZ.style.width = '100%';
                    chartContainerZ.style.height = '80%';

                    // 創建浮動視窗
                    createFloatingWindow_forchart('floatingChartX', 'Bar Chart of  X-axis', chartContainerX, 320, 'auto', 110, 300, 210);
                    createFloatingWindow_forchart('floatingChartY', 'Bar Chart of  Y-axis', chartContainerY, 320, 'auto', 340, 300, 210);
                    createFloatingWindow_forchart('floatingChartZ', 'Bar Chart of  Z-axis', chartContainerZ, 320, 'auto', 570, 300, 210);

                    // 更新或繪製長條圖
                    updateBarChart('chartX', chartDataX, 'X');
                    updateBarChart('chartY', chartDataY, 'Y');
                    updateBarChart('chartZ', chartDataZ, 'Z');

                    // 取得計算類型 (sum 或 mean)
                    document.getElementById('calculationType').addEventListener('change', function() {
                        calculationType = this.value;

                        let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
                        let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
                        let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

                        // 更新或繪製長條圖
                        updateBarChart('chartX', chartDataX, 'X');
                        updateBarChart('chartY', chartDataY, 'Y');
                        updateBarChart('chartZ', chartDataZ, 'Z');
                    });

                    const Histogram = document.createElement('div');
                    const canvas_Histogram = document.createElement('canvas');
                    canvas_Histogram.id = 'Histogram';
                    Histogram.appendChild(canvas_Histogram);

                    Histogram.style.width = '100%';
                    Histogram.style.height = '80%';

                    // 計算 Histogram 用之 bins, counts
                    let { bins, counts } = calculateBinsAndCounts(data_array, globalMin, globalMax);

                    // 創建浮動視窗
                    createFloatingWindow_forchart('floatingChartHistogram', 'Histogram', Histogram, 'auto', 205, 110, 300, 210);

                    // 繪製直方圖
                    drawHistogram('Histogram', bins, counts);
                })
                .catch(error => {
                    console.error('Error fetching or parsing CSV:', error);
                });
        }

        // 解析 CSV 檔案
        function parseCSV(csv) {
            const rows = csv.split('\n').map(row => row.split(',')); // 按 row 解析

            // 去掉欄位名中的引號，並修剪空白字符
            const headers = rows[0].map(header => header.replace(/['"]+/g, '').trim()); // 取得欄位名

            // 建構資料列，產生物件 array，每一列與欄位名稱匹配
            const data = rows.slice(1).map(row => {
                let rowData = {};
                row.forEach((cell, index) => {
                    // 去掉每個單元格中的引號和空白字符
                    rowData[headers[index]] = cell.trim().replace(/['"]+/g, '');
                });
                return rowData; // 傳回包含鍵值對的對象
            });

            return { headers, data }; // 傳回包含欄位名稱和資料物件的 array
        }

        // 當文件被選擇後處理 CSV 檔案 for import data
        document.getElementById('fileInput').addEventListener('change', function(event) {
            if (!this.files || this.files.length === 0) return;
            var file = event.target.files[0];
            var reader = new FileReader();

            reader.onload = function(e) {
                var csvData = e.target.result;

                // 使用 PapaParse 解析 CSV 資料
                Papa.parse(csvData, {
                    header: true,
                    complete: function(results) {
                        parsedData = results.data;
                        // console.log(parsedData);
                        if (parsedData.length === 0) return; // 沒有資料時直接返回

                        // 設置行數
                        var rowCount = parsedData.length;
                        document.getElementById('rowCount').textContent = rowCount;

                        // 如果有表頭，用表頭的數量作為列數
                        colCount = results.meta.fields ? results.meta.fields.length : parsedData[0] ? Object.keys(parsedData[0]).length : 0;
                        document.getElementById('colCount').textContent = colCount;

                        var columnNames = Object.keys(parsedData[0]);
                        
                        // 準備表格的表頭
                        var thead = document.getElementById('dataPreviewHead');
                        thead.innerHTML = ''; // 清空之前的表頭
                        var headerRow = thead.insertRow();
                        columnNames.forEach(function(columnName) {
                            var th = document.createElement('th');
                            th.textContent = columnName;
                            headerRow.appendChild(th);
                        });

                        // 顯示前 6 筆資料到表格中
                        var tbody = document.getElementById('dataPreviewBody');
                        tbody.innerHTML = ''; // 清空之前的資料
                        for (let i = 0; i < Math.min(6, parsedData.length); i++) {
                            let row = tbody.insertRow();
                            Object.values(parsedData[i]).forEach(function(value, index) {
                                var cell = row.insertCell();
                                cell.textContent = value;
                            });
                        }

                        // 顯示資料處理面板
                        document.getElementById('dataProcessingPanel').style.display = 'block';

                        fillSelectOptions('multiSelectX', columnNames);
                        fillSelectOptions('multiSelectY', columnNames);
                        fillSelectOptions('multiSelectZ', columnNames);
                        fillSelectOptions('singleSelect', columnNames);

                        // 監聽 XYZ 軸之單選下拉式選單的變化 更新單選下拉式選單的選項 移除已被 複選下拉式選單(3 單選下拉式選單) 選中的選項，並更新反白顏色
                        document.getElementById('multiSelectX').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectX', this.value, 'highlight-color-1');
                            fieldX = this.value;
                            uniqueX = getUniqueColumnValues(parsedData, fieldX);
                            document.getElementById('Xnum').textContent = uniqueX.length; // 在資料小面板中顯示 uniqueX, uniqueY, uniqueZ
                            clearSingleSelectHighlight(); // 檢查是否有 singleSelect 的選項被清除，移除其反白效果
                        });
                        document.getElementById('multiSelectY').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectY', this.value, 'highlight-color-2');
                            fieldY = this.value;
                            uniqueY = getUniqueColumnValues(parsedData, fieldY);
                            document.getElementById('Ynum').textContent = uniqueY.length;
                            clearSingleSelectHighlight();
                        });
                        document.getElementById('multiSelectZ').addEventListener('change', function() {
                            updateSelectOptions('singleSelect', 'multiSelectX', 'multiSelectY', 'multiSelectZ', columnNames);
                            highlightColumn('multiSelectZ', this.value, 'highlight-color-3');
                            fieldZ = this.value;
                            uniqueZ = getUniqueColumnValues(parsedData, fieldZ);
                            document.getElementById('Znum').textContent = uniqueZ.length;
                            clearSingleSelectHighlight();
                        });
                        document.getElementById('singleSelect').addEventListener('change', function() {
                            highlightColumn('singleSelect', this.value, 'highlight-color-4');
                            var minMax = findMinMax(parsedData, this.value);
                            document.getElementById('valuemin').textContent = minMax.min.toFixed(2);;
                            document.getElementById('valuemax').textContent = minMax.max.toFixed(2);;
                        });
                    }
                });
            };
            reader.readAsText(file);
        });

        // 小面板之 ok button = plot button
        document.getElementById('okButton').addEventListener('click', function() {
            // 獲取三個單選下拉式選單中選中的選項
            var selectedFields = [
                getSelectedOptions('multiSelectX'),
                getSelectedOptions('multiSelectY'),
                getSelectedOptions('multiSelectZ'),
            ];
            selectedValueField = document.getElementById('singleSelect').value;

            globalvaluedfields = selectedValueField;

            // console.log(selectedFields);
            // console.log(selectedValueField);
        
            // 初始化 cubeSizeX, cubeSizeY, cubeSizeZ 為 1 或使用者指定的值
            cubeSizeX = parseFloat(document.getElementById('cubeSizeX').value) || 1;
            cubeSizeY = parseFloat(document.getElementById('cubeSizeY').value) || 1;
            cubeSizeZ = parseFloat(document.getElementById('cubeSizeZ').value) || 1;

            document.getElementById('cubeSizeX').value = cubeSizeX;
            document.getElementById('cubeSizeY').value = cubeSizeY;
            document.getElementById('cubeSizeZ').value = cubeSizeZ;

            clearAllSceneObjects(); // 清除場景中的所有對象 (for 選擇不同映射 column)
            clearAllFloatingWindows(); // 清除所有浮動視窗

            // 儲存 select1 - select6 所選欄位的資料
            extractDataBasedOnSelectedColumns();

            processDataAndPlot(parsedData, selectedFields, selectedValueField, cubeSizeX, cubeSizeY, cubeSizeZ);
            
            // console.log(isDataLoaded);
            // console.log(parsedData);

            // let calculationType = 'sum'; // 預設值

            // 先利用預設值計算並創建圖表
            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

            // 建立圖表的容器元素
            const chartContainerX = document.createElement('div');
            const canvasX = document.createElement('canvas');
            canvasX.id = 'chartX';
            chartContainerX.appendChild(canvasX);

            const chartContainerY = document.createElement('div');
            const canvasY = document.createElement('canvas');
            canvasY.id = 'chartY';
            chartContainerY.appendChild(canvasY);

            const chartContainerZ = document.createElement('div');
            const canvasZ = document.createElement('canvas');
            canvasZ.id = 'chartZ';
            chartContainerZ.appendChild(canvasZ);

            chartContainerX.style.width = '100%';
            chartContainerX.style.height = '80%';

            chartContainerY.style.width = '100%';
            chartContainerY.style.height = '80%';

            chartContainerZ.style.width = '100%';
            chartContainerZ.style.height = '80%';

            // 創建浮動視窗
            createFloatingWindow_forchart('floatingChartX', 'Bar Chart of  X-axis', chartContainerX, 320, 'auto', 110, 300, 210);
            createFloatingWindow_forchart('floatingChartY', 'Bar Chart of  Y-axis', chartContainerY, 320, 'auto', 340, 300, 210);
            createFloatingWindow_forchart('floatingChartZ', 'Bar Chart of  Z-axis', chartContainerZ, 320, 'auto', 570, 300, 210);

            // 更新或繪製長條圖
            updateBarChart('chartX', chartDataX, 'X');
            updateBarChart('chartY', chartDataY, 'Y');
            updateBarChart('chartZ', chartDataZ, 'Z');

            // 取得計算類型 (sum 或 mean)
            document.getElementById('calculationType').addEventListener('change', function() {
                calculationType = this.value;

                let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType); // 為 X 軸計算資料
                let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType); // 為 Y 軸計算資料
                let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType); // 為 Z 軸計算資料

                // 更新或繪製長條圖
                updateBarChart('chartX', chartDataX, 'X');
                updateBarChart('chartY', chartDataY, 'Y');
                updateBarChart('chartZ', chartDataZ, 'Z');
            });

            const Histogram = document.createElement('div');
            const canvas_Histogram = document.createElement('canvas');
            canvas_Histogram.id = 'Histogram';
            Histogram.appendChild(canvas_Histogram);

            Histogram.style.width = '100%';
            Histogram.style.height = '80%';

            // 計算 Histogram 用之 bins, counts
            let { bins, counts } = calculateBinsAndCounts(data_array, globalMin, globalMax);

            // 創建浮動視窗
            createFloatingWindow_forchart('floatingChartHistogram', 'Histogram', Histogram, 'auto', 205, 110, 300, 210);

            // 繪製直方圖
            drawHistogram('Histogram', bins, counts);

            // filterCubes();
        });

        // 繪製 cube
        function processDataAndPlot(data, fields, valueField, cubeSizeX, cubeSizeY, cubeSizeZ) {
            var i, j, k;

            fieldX = fields[0];
            fieldY = fields[1];
            fieldZ = fields[2];

            // console.log(fieldX);
            // console.log(fieldY);
            // console.log(fieldZ);

            // 處理資料
            uniqueX = getUniqueColumnValues(data, fieldX);
            uniqueY = getUniqueColumnValues(data, fieldY);
            uniqueZ = getUniqueColumnValues(data, fieldZ);

            // console.log(uniqueX);
            // console.log(uniqueY);
            // console.log(uniqueZ);

            // 初始化資料結構
            data_array = createDataArray(uniqueX, uniqueY, uniqueZ);

            // 填充資料結構和 combined_text
            fillDataArray(data, data_array, uniqueX, uniqueY, uniqueZ, fieldX, fieldY, fieldZ, valueField);

            // 填充 2d heatmap 之下拉式菜单
            // fillSelectfor2dheatmap('xAxisCate', uniqueX);
            // fillSelectfor2dheatmap('yAxisCate', uniqueY);
            // fillSelectfor2dheatmap('zAxisCate', uniqueZ);

            // console.log(data_array);

            // 計算最小值和最大值 (for colour)
            var minMax = findMinMax(data, valueField);
            var min = minMax.min;
            var max = minMax.max;

            // // 將 data_array 展開為一維數組
            // const flattenedArray = data_array.flat(Infinity); // Infinity 確保無論幾維都能展開為一維

            // console.log(minMax);

            // 存儲全域最小值和最大值
            globalMin = minMax.min;
            globalMax = minMax.max;

            // 更新滑動條的最小值和最大值 (Restricted Display)
            $("#double-slider").slider("option", "min", globalMin);
            $("#double-slider").slider("option", "max", globalMax);

            // 重置滑動條的目前值到新的最小值和最大值 (Restricted Display)
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示 (Restricted Display)
            var handles = $("#double-slider .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            globalSliderMinforcolor = globalMin;
            globalSliderMaxforcolor = globalMax;

            // 更新滑動條的最小值和最大值 (Filter Cubes Value)
            $("#double-slider-cubesvalue").slider("option", "min", globalMin);
            $("#double-slider-cubesvalue").slider("option", "max", globalMax);

            // 重置滑動條的目前值到新的最小值和最大值 (Filter Cubes Value)
            $("#double-slider-cubesvalue").slider("values", [globalMin, globalMax]);

            // 同時更新手把上的數值顯示 (Filter Cubes Value)
            var handles = $("#double-slider-cubesvalue .ui-slider-handle");
            handles.eq(0).find(".ui-slider-value").text(globalMin.toFixed(2));
            handles.eq(1).find(".ui-slider-value").text(globalMax.toFixed(2));

            globalSliderMin = globalMin;
            globalSliderMax = globalMax;

            // console.log(globalSliderMin);
            // console.log(globalSliderMax);

            // 取得每一個 X 軸類別的 min、max
            uniqueX.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldX 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldX] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueX 對象
                minMaxByUniqueX[uniqueValue] = minMax;
                // console.log(minMaxByUniqueX);
            });

            // 取得每一個 Y 軸類別的 min、max
            uniqueY.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldY 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldY] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueY 對象
                minMaxByUniqueY[uniqueValue] = minMax;
                // console.log(minMaxByUniqueY);
            });

            // 取得每一個 Z 軸類別的 min、max
            uniqueZ.forEach(function(uniqueValue) {
                // 過濾出所有在 fieldZ 欄位上符合 uniqueValue 的記錄
                var filteredData = data.filter(function(row) {
                    return row[fieldZ] == uniqueValue;
                });
                
                // 計算這些記錄的最小值和最大值
                var minMax = findMinMax(filteredData, valueField); // valueField 是想要計算最小值和最大值的欄位
                
                // 為每個 uniqueValue 更新 minMaxByUniqueX 對象
                minMaxByUniqueZ[uniqueValue] = minMax;
                // console.log(minMaxByUniqueZ);
            });

            // 計算 uniqueX、uniqueY、uniqueZ 之長度
            numX = data_array.length;
            numY = data_array[0].length;
            numZ = data_array[0][0].length;

            // 初始化 cubes array 並添加立方體到場景
            for (i = 0; i < numX; i++) {
                cubes[i] = []; // 初始化二維 array
                cubesOpacity[i] = [];
                for (j = 0; j < numY; j++) {
                    cubes[i][j] = []; // 初始化三維 array
                    cubesOpacity[i][j] = [];
                    for (k = 0; k < numZ; k++) {
                        cubesOpacity[i][j][k] = currentOpacity; // 設初始透明度為 0.5

                        // 創建一個具有基本材料的立方體
                        let cubeMaterial = new THREE.MeshBasicMaterial({ 
                            transparent: true,
                            opacity: 0 // 初始設為完全透明
                        });

                        let cubeGeometry = new THREE.BoxGeometry(cubeSizeX, cubeSizeY, cubeSizeZ);
                        let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

                        // 計算立方體的位置
                        var posX = i * cubeSizeX - ((numX - 1) * cubeSizeX / 2);
                        var posY = j * cubeSizeY - ((numY - 1) * cubeSizeY / 2);
                        var posZ = k * cubeSizeZ - ((numZ - 1) * cubeSizeZ / 2);
                        cube.position.set(posX, posY, posZ);

                        // 將立方體加入場景中
                        scene.add(cube);

                        // 在 array 中保存立方體的引用
                        cubes[i][j][k] = cube;
                    }
                }
            }

            rowProxDataX = new Array(numX);
            for(i = 0; i < numX; i++) {
                rowProxDataX[i] = new Array(numX);
                for(j = 0; j < numX; j++) {
                    rowProxDataX[i][j] = 0;
                }
            }

            rowProxDataY = new Array(numY);
            for(i = 0; i < numY; i++) {
                rowProxDataY[i] = new Array(numY);
                for(j = 0; j < numY; j++) {
                    rowProxDataY[i][j] = 0;
                }
            }

            rowProxDataZ = new Array(numZ);
            for(i = 0; i < numZ; i++) {
                rowProxDataZ[i] = new Array(numZ);
                for(j = 0; j < numZ; j++) {
                    rowProxDataZ[i][j] = 0;
                }
            }

            // 取得更新後之 indices  
            //var currentXSortOrder = document.getElementById('sortXOrderSelect').value;
            //var currentYSortOrder = document.getElementById('sortYOrderSelect').value;
            //var currentZSortOrder = document.getElementById('sortZOrderSelect').value;

            //updateXOrder(currentXSortOrder);
            //updateYOrder(currentYSortOrder);
            //updateZOrder(currentZSortOrder);
            now_sortXOrderSelect = document.getElementById('sortXOrderSelect').value;
            now_sortYOrderSelect = document.getElementById('sortYOrderSelect').value;
            now_sortZOrderSelect = document.getElementById('sortZOrderSelect').value;
            updateXOrder();
            updateYOrder();
            updateZOrder();

            // 調用該函數，並根據目前 indices 映射顏色
            applyChangesBasedOnNewIndices(valueField);

            // 調用此函數以設定初始預設相機位置
            setDefaultCameraPosition();

            isDataLoaded = true; // 資料處理完成，允許更新軸線
        }

        // 創建 OrbitControls 讓使用者能夠操作 3D 圖形
        var controls = new OrbitControls(camera, renderer.domElement);

        // 設定相機的預設位置和焦點
        function setDefaultCameraPosition() {
            maxDimension = Math.max(numX, numY, numZ); // 找到最大的維度
            distance = Math.round(maxDimension / 2.5 + 1.5); // 設定相機距離

            camera.position.set(distance, distance, distance); // 設置相機位置
            camera.lookAt(new THREE.Vector3(numX * cubeSizeX / 2, numY * cubeSizeY / 2, numZ * cubeSizeZ / 2)); // 設定焦點點

            // 更新 OrbitControls 以符合新的相機位置
            controls.update();

            // 重新渲染場景
            renderer.render(scene, camera);
        }

        // 監聽 exportCube 按鈕的點擊事件
        document.getElementById('exportCube').addEventListener('click', function() {
            exportSceneToPNG();
        });

        // 匯出場景為 PNG 圖片並自動下載的函數
        // function exportSceneToPNG() {
        //     // 檢查場景是否有任何物件
        //     if (scene.children.length === 0) {
        //         console.log("Cube not found or scene is empty.");
        //         return; // 場景為空，返回不繼續執行
        //     }

        //     // 渲染當前場景
        //     renderer.render(scene, camera);
            
        //     // 取得渲染器的內容並轉換為 PNG 資料 URL
        //     var imgData = renderer.domElement.toDataURL('image/png');
            
        //     // 建立一個暫時的 <a> 元素用於觸發下載
        //     var link = document.createElement('a');
        //     link.href = imgData;
        //     link.download = 'Cube.png'; // 下載的檔案名稱
            
        //     // 觸發點擊事件下載圖片
        //     link.click();
        // }

        // 匯出場景為 PNG 圖片並自動下載的函數 with colorbar
        function exportSceneToPNG() {
            // 檢查場景是否有任何物件
            if (scene.children.length === 0) {
                // console.log("Cube not found or scene is empty.");
                return; // 場景為空，返回不繼續執行
            }

            // 渲染當前場景
            renderer.render(scene, camera);

            // 取得 WebGL 場景渲染結果的影像資料
            const sceneImageData = renderer.domElement.toDataURL('image/png');

            // 取得 colorbar 和它的高度
            var colorbarMinLabel = colorbarMinLabelforcube.textContent;
            var colorbarMaxLabel = colorbarMaxLabelforcube.textContent;

            // 使用 html2canvas 取得 colorbar 的圖像資料
            html2canvas(colorbarforcube).then(function (colorbarCanvas) {
                const colorbarImageData = colorbarCanvas.toDataURL('image/png');

                // 建立一個新的 canvas 用於合併場景和 colorbar
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // 設定 canvas 大小，包含場景和 colorbar 的寬高
                const rendererWidth = renderer.domElement.width;
                const rendererHeight = renderer.domElement.height;
                const colorbarWidth = colorbarCanvas.width;
                const colorbarHeight = colorbarCanvas.height;

                // 調整 canvas 的寬高，包含場景和 colorbar
                canvas.width = rendererWidth + colorbarWidth + 50; // 場景寬度 + colorbar 寬度 + 空隙
                canvas.height = Math.max(rendererHeight, colorbarHeight); // 高度取最大值

                // 繪製場景到新的 canvas 上
                const sceneImage = new Image();
                sceneImage.src = sceneImageData;
                sceneImage.onload = function () {
                    ctx.drawImage(sceneImage, 0, 0, rendererWidth, rendererHeight);

                    // 繪製 colorbar 到場景右側
                    const colorbarImage = new Image();
                    colorbarImage.src = colorbarImageData;
                    colorbarImage.onload = function () {
                        const colorbarX = rendererWidth;
                        const colorbarY = (rendererHeight - colorbarHeight) / 2; // colorbar 垂直居中

                        ctx.drawImage(colorbarImage, colorbarX, colorbarY);

                        // 繪製最小值和最大值標籤
                        ctx.font = "14px Arial";
                        ctx.fillStyle = "black";

                        // 繪製最大值標籤（在 colorbar 頂部）
                        ctx.fillText(colorbarMaxLabel, colorbarX + colorbarWidth + 5, colorbarY + 6); // +6 調整字體高度

                        // 繪製最小值標籤（在 colorbar 底部）
                        ctx.fillText(colorbarMinLabel, colorbarX + colorbarWidth + 5, colorbarY + colorbarHeight + 2);

                        // 匯出最終合併的圖片
                        const finalImageData = canvas.toDataURL('image/png');

                        // 建立一個 <a> 元素用於觸發下載
                        const link = document.createElement('a');
                        link.href = finalImageData;
                        link.download = 'Cube.png'; // 下載的檔案名稱

                        // 觸發點擊事件下載圖片
                        link.click();
                    };
                };
            });
        }

        // 監聽 exportProxImage 按鈕的點擊事件
        document.getElementById('exportProxImage').addEventListener('click', function() {
            exportWindowAsImage('windowProxforX', 'ProximityImage_X');
            exportWindowAsImage('windowProxforY', 'ProximityImage_Y');
            exportWindowAsImage('windowProxforZ', 'ProximityImage_Z');
        });

        // 匯出指定視窗的內容為圖片
        function exportWindowAsImage(windowID, name) {
            var element = document.getElementById(windowID); // 取得浮動視窗的 DOM 元素
            
            // 檢查元素是否存在
            if (!element) {
                // console.log("Element " + name + " not found.");
                return; // 找不到元素直接返回，不觸發錯誤
            }

            var header = element.querySelector('.window-header'); // 取得標題元素

            // 暫時隱藏標題
            if (header) {
                header.style.display = 'none';
            }

            // 使用 html2canvas 將指定元素渲染為畫布
            html2canvas(element).then(function(canvas) {
                // 將畫布轉換為圖片資料 URL
                var imgData = canvas.toDataURL('image/png');

                // 建立一個 <a> 元素用於觸發下載
                var link = document.createElement('a');
                link.href = imgData;
                link.download = name + '.png'; // 下載的檔案名稱

                // 觸發下載
                link.click();

                // 恢復標題的顯示
                if (header) {
                    header.style.display = 'flex';
                }
            }).catch(function(error) {
                console.error("Error rendering canvas: ", error);
                // 如果渲染失敗，也要恢復標題顯示
                if (header) {
                    header.style.display = 'flex';
                }
            });
        }

        // 監聽 exportChart 按鈕的點擊事件
        document.getElementById('exportChart').addEventListener('click', function() {
            // Bar Charts
            exportChartAsImage('chartX', 'BarChart_X');
            exportChartAsImage('chartY', 'BarChart_Y');
            exportChartAsImage('chartZ', 'BarChart_Z');

            // Histogram
            exportChartAsImage('Histogram', 'Histogram');
        });

        // 匯出 Chart.js 圖表為 PNG 的函數
        function exportChartAsImage(containerId, name) {
            if (window[containerId + 'ChartInstance']) {
                const chartInstance = window[containerId + 'ChartInstance'];
                const canvas = chartInstance.canvas;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                // 儲存目前的 canvas 狀態
                ctx.save();

                // 設定白色背景色
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 取得圖表的 base64 資料
                const chartImage = canvas.toDataURL('image/png');

                // 建立一個 <a> 元素用於下載圖片
                const link = document.createElement('a');
                link.href = chartImage;
                link.download = name + '.png'; // 下載的檔案名稱

                // 觸發點擊事件下載圖片
                link.click();

                // 恢復 canvas 的狀態（去掉白色背景）
                ctx.restore();
            }
            // else {
            //     console.log("Element " + name + " not found.");
            // }
        }

        // Reset camera to default
        document.getElementById('resetCameraIcon').addEventListener('click', function() {
            setDefaultCameraPosition();
        });

        // Reset To Original Cube
        document.getElementById('resetCube').addEventListener('click', function() {
            ResetToOriginalCube();
        });

        function ResetToOriginalCube() {
            // ### Order
            // 重置 sortXOrderSelect 下拉式選單回到預設選項 (original_X)
            document.getElementById('sortXOrderSelect').selectedIndex = 0;

            now_sortXOrderSelect = 'original_X';

            // 重置 sortYOrderSelect 下拉式選單回到預設選項 (original_Y)
            document.getElementById('sortYOrderSelect').selectedIndex = 0;

            now_sortYOrderSelect = 'original_Y';

            // 重置 sortZOrderSelect 下拉式選單回到預設選項 (original_Z)
            document.getElementById('sortZOrderSelect').selectedIndex = 0;

            now_sortZOrderSelect = 'original_Z';

            updateXOrder();
            updateYOrder();
            updateZOrder();

            // ### color
            // 重置 colorSchemeSelect 下拉式選單回到預設選項 (GAP_Rainbow)
            document.getElementById('colorSchemeSelect').selectedIndex = 0;

            currentColorScheme = 'GAP_Rainbow';

            // ### reverse color
            document.getElementById('reverseColors').checked = false;

            // 更新全域變數
            reverse = false;

            // ### Display Condition
            // 重置 DisplayCondition 下拉式選單回到預設選項 (RangeMatrix)
            displayCondition = document.getElementById('DisplayCondition').selectedIndex = 0;

            displayCondition = 'RangeMatrix';

            applyChangesBasedOnNewIndices(globalvaluedfields);

            // ### Opacity
            // 重置 Opacity 滑動條和顯示的值
            document.getElementById('opacityRange').value = .5;
            document.getElementById('opacityValue').textContent = .5;

            // 更新全域變數
            currentOpacity = .5;

            // ### filter
            for (let i = 0; i < Xindices.length; i++) {
                for (let j = 0; j < Yindices.length; j++) {
                    for (let k = 0; k < Zindices.length; k++) {
                        // 在立方體已經創建的基礎上進行
                        let cube = cubes[i][j][k]; // 取得現有的立方體

                        if (cube) {
                            // 使用排序後的索引從 data_array 取得值
                            let value = data_array[Xindices[i]][Yindices[j]][Zindices[k]];

                            if (value !== null) {

                                cube.material.opacity = currentOpacity;
                                // 追蹤透明度值
                                cubesOpacity[i][j][k] = cube.material.opacity; 

                            } else {
                                cube.material.opacity = 0; // 空值立方體保持完全透明
                            }
                        }
                    }
                }
            }
            clearbar();

            // 重置 calculationType 下拉式選單回到預設選項 (sum)
            document.getElementById('calculationType').selectedIndex = 0;

            calculationType = 'sum';

            // 根據 calculationType 重新繪圖
            let chartDataX = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'X', calculationType);
            updateBarChart('chartX', chartDataX, 'X');

            let chartDataY = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Y', calculationType);
            updateBarChart('chartY', chartDataY, 'Y');

            let chartDataZ = calculateDataPoints(data_array, uniqueX, uniqueY, uniqueZ, 'Z', calculationType);
            updateBarChart('chartZ', chartDataZ, 'Z');

            // 取得浮動視窗
            const floatWindowforchartX = document.getElementById('floatingChartX');
            const floatWindowforchartY = document.getElementById('floatingChartY');
            const floatWindowforchartZ = document.getElementById('floatingChartZ');
            const floatWindowforcharthis = document.getElementById('floatingChartHistogram');

            // 設置初始位置
            floatWindowforchartX.style.left = '320px';
            floatWindowforchartX.style.right = 'autopx';
            floatWindowforchartX.style.top = '110px';
            floatWindowforchartX.style.width = '300px';
            floatWindowforchartX.style.height = '210px';

            floatWindowforchartY.style.left = '320px';
            floatWindowforchartY.style.right = 'autopx';
            floatWindowforchartY.style.top = '340px';
            floatWindowforchartY.style.width = '300px';
            floatWindowforchartY.style.height = '210px';

            floatWindowforchartZ.style.left = '320px';
            floatWindowforchartZ.style.right = 'autopx';
            floatWindowforchartZ.style.top = '570px';
            floatWindowforchartZ.style.width = '300px';
            floatWindowforchartZ.style.height = '210px';

            floatWindowforcharthis.style.left = 'autopx';
            floatWindowforcharthis.style.right = '205px';
            floatWindowforcharthis.style.top = '110px';
            floatWindowforcharthis.style.width = '300px';
            floatWindowforcharthis.style.height = '210px';
            
            // 重置 UnionorIntersection 下拉式選單回到預設選項 (Union)
            document.getElementById('UnionorIntersection').selectedIndex = 0;

            selectionType = 'Union';

            // 重置滑動條到原始狀態 (Restricted Display)
            $("#double-slider").slider("values", [globalMin, globalMax]);

            // 更新滑動條上顯示的標籤 (Restricted Display)
            $("#double-slider .ui-slider-handle").eq(0).find(".ui-slider-value").text(globalMin.toFixed(1));
            $("#double-slider .ui-slider-handle").eq(1).find(".ui-slider-value").text(globalMax.toFixed(1));

            // 更新全域變數
            globalSliderMinforcolor = globalMin;
            globalSliderMaxforcolor = globalMax;

            // 重置滑動條到原始狀態 (Filter Cubes Value)
            $("#double-slider-cubesvalue").slider("values", [globalMin, globalMax]);

            // 更新滑動條上顯示的標籤 (Filter Cubes Value)
            $("#double-slider-cubesvalue .ui-slider-handle").eq(0).find(".ui-slider-value").text(globalMin.toFixed(1));
            $("#double-slider-cubesvalue .ui-slider-handle").eq(1).find(".ui-slider-value").text(globalMax.toFixed(1));

            // 更新全域變數
            globalSliderMin = globalMin;
            globalSliderMax = globalMax;

            // 重置 Filter Cubes Opacity 滑動條和顯示的值
            document.getElementById('filteropacityRange').value = 0;
            document.getElementById('filteropacityValue').textContent = 0;

            // 移除浮動視窗及其包含之變數列表
            const existingWindow = document.getElementById('filtersamplelist');
            if (existingWindow) {
                existingWindow.remove();
            }

            // ### Proximity
            // 重置 rowprox 下拉式選單回到預設選項 (null)
            document.getElementById('rowproxX').value = 'null';
            document.getElementById('rowproxY').value = 'null';
            document.getElementById('rowproxZ').value = 'null';

            // 移除浮動視窗及其包含之圖
            d3.select("#windowProxforX_svg").remove(); // 移除 SVG 圖形
            d3.select("#windowProxforX").remove(); // 移除浮動視窗
            d3.select("#colorbarX").remove(); // 移除 colorbarX

            d3.select("#windowProxforY_svg").remove();
            d3.select("#windowProxforY").remove();
            d3.select("#colorbarY").remove();

            d3.select("#windowProxforZ_svg").remove();
            d3.select("#windowProxforZ").remove();
            d3.select("#colorbarZ").remove();

            // ### Slices
            // 需直接操作對應單選按鈕的 checked 屬性
            document.getElementById('oAxis').checked = true;

            // 更新全域變數
            selectedAxis = 'O';
            sliceCubeByAxis(selectedAxis);

            // 重置 SliceRange 滑桿值為預設值
            SliceRange.value = 1; // 將滑桿值設定為初始值
            SliceValue.textContent = 1; // 同步更新顯示值
            
            // ### cube Size
            // 重置 cubeSize 滑動條和顯示的值
            document.getElementById('cubeSizeX').value = 1;
            document.getElementById('cubeSizeXValue').textContent = 1;
            document.getElementById('cubeSizeY').value = 1;
            document.getElementById('cubeSizeYValue').textContent = 1;
            document.getElementById('cubeSizeZ').value = 1;
            document.getElementById('cubeSizeZValue').textContent = 1;
            
            // 更新全域變數
            cubeSizeX = 1;
            cubeSizeY = 1;
            cubeSizeZ = 1;

            updateCubeSizesAndPositions();

            // ### Separate Cube
            // 重置 hollowSize 滑動條和顯示的值
            document.getElementById('hollowSize').value = 1;
            document.getElementById('hollowSizeValue').textContent = 1;

            // 更新全域變數
            newSize = 1;

            // ### Proximity Matrix color
            $("#colorforXproximity option[value='GAP_Rainbow']").prop('selected', true);
            $("#colorforXproximity").change();

            // ### reverse color
            document.getElementById('reverseColorforX').checked = false;

            $("#colorforYproximity option[value='GAP_Rainbow']").prop('selected', true);
            $("#colorforYproximity").change();

            // ### reverse color
            document.getElementById('reverseColorforY').checked = false;

            $("#colorforZproximity option[value='GAP_Rainbow']").prop('selected', true);
            $("#colorforZproximity").change();

            // ### reverse color
            document.getElementById('reverseColorforZ').checked = false;

            // ### Pan
            document.getElementById('panCheckBox').checked = false;

            // 更新全域變數
            pancheck = false;

            // 手動執行與 change 事件監聽器中相同的邏輯
            controls.enableRotate = true; // 啟用旋轉

            // ### Show Closest Data on Hover
            document.getElementById('tooltipCheckbox').checked = false;

            // 更新全域變數
            tooltipEnabled = false;

            // ### 投影方式
            document.getElementById('PerspectiveCamera').checked = true;

            selectedcamera = 'Pe';

            // 呼叫 PeorOrcamera 函數，傳入選中的軸
            camera = PeorOrcamera(selectedcamera);

            controls = new OrbitControls(camera, renderer.domElement);

            setDefaultCameraPosition();

            // renderer.render(scene, camera);

            // 設定控制相機的參數
            controls.rotateSpeed = .5;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 1.8;
            controls.noZoom = false;
            controls.noPan = false;

            animate();

            // ### Font
            // 重置 fontSize 滑動條和顯示的值
            document.getElementById('fontSize').value = 25;
            document.getElementById('fontSize').textContent = 25;

            // 重置 fontStyle
            document.getElementById('fontStyle').value = 'Arial';

            // 重置 fontColor
            document.getElementById('FontColor').value = '#0f0f0f';
        }

        // Pan
        document.getElementById('panCheckBox').addEventListener('change', function(event) {
            pancheck = event.target.checked;

            if (pancheck) {
                // 當勾選時 禁用旋轉
                controls.enableRotate = false;
            } else {
                // 當勾選時 允許旋轉
                controls.enableRotate = true;
            }
        });

        // 設定控制相機的參數
        controls.rotateSpeed = .5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 1.8;
        controls.noZoom = false;
        controls.noPan = false;

        // 渲染循環
        function animate() {
            requestAnimationFrame(animate);

            if (isDataLoaded) {
                updateAxesAndLabelByCamera(); // 只有在資料載入後才調用
                // 在立方體創建後添加軸線，且直接與邊長同步縮放
                createOrUpdateAxes(numX, numY, numZ, cubeSizeX, cubeSizeY, cubeSizeZ);
                // updateAxeslabelBasedOnVertex(cubeSizeX, cubeSizeY, cubeSizeZ, numX, numY, numZ, closestVertex_camera, uniqueX, uniqueY, uniqueZ);
            }
            
            controls.update();
            renderer.render(scene, camera);
            // 設定背景顏色
            renderer.setClearColor(0xFFFFFF, 0); // 參數 1 表示顏色值，參數 2 表示透明度值
        }

        animate();

    </script>

    <style>
        .side-nav-hide-on-closed {
            font-family: 'Encode Sans', sans-serif; /* Encode Sans  Ubuntu  kanit sans-serif*/
            font-size: 18px;
            font-weight: 550;
        }

        .node circle {
          fill: #fff;
          stroke-width: 1.5px;
        }

        .node {
          font-size: 13px;
        }

        #rowTree .link {
          fill: none;
          stroke-width: 1px;
        }

        .file-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            /* font-size: 16px; */
            margin: 4px 2px;
            margin-right: 5px;
            position: relative; /* 為懸停文本定位 */
            margin-left: 7px; /* Space on the left */
        }

        #fileInputLabel {
            /* margin-right: 50px; */
            /* margin-left: 2px; */
            color: black; /* 文字顏色 */
        }

        .navbar-brand {
            display: flex; /* 啟用Flexbox布局 */
            align-items: center; /* 垂直居中對齊所有項目 */
            justify-content: start; /* 從左側開始排列項目 */
        }

        .navbar-brand img,
        .navbar-brand div {
            display: inline-block; /* 確保元素以內聯塊的形式顯示 */
            vertical-align: middle; /* 垂直居中 */
            margin-left: 6px;
        }

        /* 如果需要，根據側邊導航的狀態調整顯示 */
        .sidebar-closed .side-nav-hide-on-closed {
            display: inline-block; /* 或其他顯示方式 */
        }

        /* 根據需求調整圖片和文字之間的間距 */
        .navbar-brand img + img, /* 第二個圖片和後續元素之間的間距 */
        .navbar-brand img + div { /* 圖片和文字之間的間距 */
            margin-left: 10px; /* 根據需求調整 */
        }

        .navbar-brand {
            display: flex;
            align-items: center;
            justify-content: start;
        }

        .side-nav-show-on-closed {
            width: 20px; /* 使用百分比，如100% */
            height: auto;
        }

        /* 在關閉側邊選單的時候，不要顯示 fileInputLabel (Import Data) */
        /* .side-nav-closed #fileInputLabel {
            display: none;
        } */

        #xAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #yAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #zAxisCate {
            width: 190px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #rowproxX {
            width: 190px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
            margin-bottom: 10px;
            /* font-size: 10px; */
        }

        #rowproxY {
            width: 190px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
            margin-bottom: 10px;
        }

        #rowproxZ {
            width: 190px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            padding: 1px;
            border-radius: 5px !important; /* 使用 !important 來確保樣式被套用 */
        }

        /* Modify the width of the range input */
        #SliceRange {
            width: 180px; /* or 100% if you want it to be responsive */
        }

        /* Modify the width of the range input */
        #opacityRange {
            width: 170px; /* or 100% if you want it to be responsive */
            margin-bottom: 13px;
        }

        /* Modify the width of the range input */
        #filteropacityRange {
            width: 170px; /* or 100% if you want it to be responsive */
        }

        /* Adjust the distance between the range input and its value display */
        #opacityValue {
            margin-left: 6px; /* Adjust as needed */
        }

        #colorSchemeSelect {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #DisplayCondition {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #cubeSizeX {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeY {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeZ {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #hollowSize {
            width: 160px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
        }

        #cubeSizeXValue {
            margin-left: 6px;
        }

        #cubeSizeYValue {
            margin-left: 6px;
        }

        #cubeSizeZValue {
            margin-left: 6px;
        }

        #hollowSizeValue {
            margin-left: 6px;
        }

        #fontSize {
            width: 165px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            /* margin-bottom: 11px; */
        }

        #fontSizeValue {
            margin-left: 6px;
        }

        #FontColor {
            width: 190px;
            border: none;
            padding: 0;
            margin: 0;
            margin-bottom: 10px;
        }

        #fontStyle {
            width: 190px;
            margin-bottom: 13px;
            margin-top: 4px;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        /* 設定下拉選單中每個選項的字型 */
        #fontStyle option[value="Arial"] {
            font-family: Arial, sans-serif;
        }
        #fontStyle option[value="Source Sans Pro"] {
            font-family: 'Source Sans Pro', sans-serif;
        }
        #fontStyle option[value="Encode Sans"] {
            font-family: 'Encode Sans', sans-serif;
        }
        #fontStyle option[value="Verdana"] {
            font-family: Verdana, sans-serif;
        }
        #fontStyle option[value="Tahoma"] {
            font-family: Tahoma, sans-serif;
        }
        #fontStyle option[value="Times New Roman"] {
            font-family: 'Times New Roman', serif;
        }
        #fontStyle option[value="Georgia"] {
            font-family: Georgia, serif;
        }
        #fontStyle option[value="Courier New"] {
            font-family: 'Courier New', monospace;
        }
        #fontStyle option[value="Lucida Console"] {
            font-family: 'Lucida Console', monospace;
        }
        #fontStyle option[value="Comic Sans MS"] {
            font-family: 'Comic Sans MS', sans-serif;
        }
        #fontStyle option[value="Trebuchet MS"] {
            font-family: 'Trebuchet MS', sans-serif;
        }
        #fontStyle option[value="Impact"] {
            font-family: Impact, sans-serif;
        }

        #colorbar-container {
            position: fixed; /* 固定位置 */
            right: 50px; /* 距離右邊邊緣的距離 */
            top: 50%; /* 置於畫面垂直中央 */
            transform: translateY(-50%); /* 垂直居中 */
            display: none; /* 初始時不顯示 */
        }

        #colorbar {
            width: 20px; /* colorbar 的寬度 */
            height: 256px; /* colorbar 的高度 */
            border: 1px solid #FFF; /* colorbar 的邊框 */
        }

        #colorbar-min-label,
        #colorbar-max-label {
            position: absolute;
            left: 90%; /* Adjust this value as needed to position labels to the left of the colorbar */
            font-size: 12px; /* font size */
            font-family: Arial, sans-serif; /* font family */
            margin-left: 8px; /* Add some space between the colorbar and the labels */
        }

        #colorbar-max-label {
            bottom: 95%; /* Align with the top of the colorbar */
        }

        #colorbar-min-label {
            top: 95%; /* Align with the bottom of the colorbar */
        }

        /* proximity matrix 之浮動視窗*/
        .floating-window {
            display: none; /* 預設情況下，浮動視窗是不可見的 */
            position: absolute;
            z-index: 1000;
            border: 1px solid rgba(169, 169, 169, 0.5); /* rgba(133, 163, 245, 0.7); /* 為視窗添加 1 像素寬、顏色為淡灰色 (#ddd) 的實線邊框 */
            border-radius: 5px; /* 為邊框添加 5 像素的圓角 使視窗邊緣呈現圓潤的效果 */
            overflow: auto; /* 允許內容超出時新增捲軸 */
            resize: both; /* 允許調整大小 (透過拖曳視窗的右下角來調整其大小) both:寬度和高度都可以調整 */
            background-color: #ffffff; /* 設定實心背景顏色為白色 */
        }

        .window-header {
            padding: 10px; /* 在視窗頭部內部的所有四個方向添加 10 像素的內邊距 以便於內容與邊框之間有一定的間隙 */
            cursor: move; /* 當滑鼠懸停在視窗頭部時，遊標會變成移動圖示 (一個帶有箭頭的十字)，提示使用者此區域可以拖曳 */
            background-color: #F5F5F5; /* 設定視窗頭部的背景顏色為淺灰色 */
            border-bottom: 1px solid #F0F8FF; /* 在視窗頭部的底部添加 1 像素寬、顏色為淡灰色的實線邊框， 視覺上區分頭部與內容區域 */
            height: 40px;
            /* color: #8E8E8E; /* 文字顏色 */
            /* font-weight: bold; /* 加粗文字 */
        }

        .close {
            float: right; /* 使關閉按鈕浮動到其父容器的右側 通常用於視窗頭部的右上角位置 */
            cursor: pointer; /* 當滑鼠懸停在關閉按鈕上時，遊標變為指針，提示使用者此區域是可點擊的 */
        }

        .reset-camera-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;
        }

        #calculationType {
            width: 172px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            margin-bottom: 11px;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        /* 外圍容器樣式 */
        .exportselect {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* height: 63px; */
            padding: 8px;
            /* margin-top: 10px; */
        }

        /* 每個選項的基礎樣式 */
        .exportselect-item {
            padding: 5px;
            /* font-family: Arial, sans-serif; */
            color: black;
            background-color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        /* 鼠標懸停時的反白樣式 */
        .exportselect-item:hover {
            background-color: #f3f5ff; /* 鼠標移上去的背景色 */
        }

        /* exportHelp */
        .exporthelp-icon {
            position: absolute;
            /* top: 1px; */
            right: 31px;
            margin-top: 0;
            cursor: pointer;
        }

        .exporthelp-icon i {
            font-size: 14px; /* 調整圖示大小 */
            color: #007bff; /* 調整圖示顏色 */
        }

        .exporthelp-icon i:hover {
            color: #0056b3 !important; /* 懸停時的顏色 */
        }

        /* Tooltip for exportHelp styling */
        .exporthelp-icon .tooltipforexporthelp-content {
            visibility: hidden;
            background-color: rgba(0, 0, 0, .82); /* 設置透明度 */
            color: white;
            padding: 8px;
            border: none;
            border-radius: 5px;
            width: 220px;
            top: 100%;
            left: 50%;
            margin-left: -197px; /* Use half of the width, to center the tooltip */
            position: absolute;
            z-index: 1;
            pointer-events: none; /* 禁用 span 的滑鼠事件 */
        }

        /* Show the tooltip text when you mouse over the tooltip container */
        .exporthelp-icon:hover .tooltipforexporthelp-content {
            visibility: visible;
        }

        .exporthelp-icon .tooltipforexporthelp-content::after {
            content: " ";
            position: absolute;
            bottom: 100%;  /* At the top of the tooltip */
            left: 89%;
            margin-left: -5px;
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, .82) transparent;
        }

        /* orderhelp */
        .orderhelp-icon {
            cursor: pointer;
            position: relative; /* 設定相對定位，以確保 tooltip 以它為基準 */
        }

        .orderhelp-icon i {
            font-size: 14px; /* 調整圖示大小 */
            color: #007bff; /* 調整圖示顏色 */
        }

        .orderhelp-icon i:hover {
            color: #0056b3 !important; /* 懸停時的顏色 */
        }

        /* Tooltip for orderHelp styling */
        .orderhelp-icon .tooltipfororderhelp-content {
            visibility: hidden;
            width: 180px;
            background-color: rgba(0, 0, 0, .82); /* 設置透明度 */
            color: white;
            padding: 8px;
            border: none;
            border-radius: 5px;
            top: 100%;
            left: 50%;
            margin-left: -90px; /* Use half of the width, to center the tooltip */
            position: absolute;
            z-index: 1;
            pointer-events: none; /* 禁用 span 的滑鼠事件 */
        }

        /* Show the tooltip text when you mouse over the tooltip container */
        .orderhelp-icon:hover .tooltipfororderhelp-content {
            visibility: visible;
        }

        .orderhelp-icon .tooltipfororderhelp-content::after {
            content: " ";
            position: absolute;
            bottom: 100%;  /* At the top of the tooltip */
            left: 50%;
            margin-left: -5px;
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, .82) transparent;
        }

        /* Hoverhelp */
        .Hoverhelp-icon {
            cursor: pointer;
            position: relative; /* 設定相對定位，以確保 tooltip 以它為基準 */
            margin-left: 3px;
            /* margin-top: 1px; */
            display: inline-block;
        }

        .Hoverhelp-icon i {
            font-size: 14px; /* 調整圖示大小 */
            color: #007bff; /* 調整圖示顏色 */
        }

        .Hoverhelp-icon i:hover {
            color: #0056b3 !important; /* 懸停時的顏色 */
        }

        /* Tooltip for HoverHelp styling */
        .Hoverhelp-icon .tooltipforHoverhelp-content {
            visibility: hidden;
            background-color: rgba(0, 0, 0, .82); /* 設置透明度 */
            color: white;
            padding: 8px;
            border: none;
            border-radius: 5px;
            width: 220px;
            top: 100%;
            left: 50%;
            margin-left: -188px; /* Use half of the width, to center the tooltip */
            position: absolute;
            z-index: 1;
            pointer-events: none; /* 禁用 span 的滑鼠事件 */
        }

        /* Show the tooltip text when you mouse over the tooltip container */
        .Hoverhelp-icon:hover .tooltipforHoverhelp-content {
            visibility: visible;
        }

        .Hoverhelp-icon .tooltipforHoverhelp-content::after {
            content: " ";
            position: absolute;
            bottom: 100%;  /* At the top of the tooltip */
            left: 84.6%;
            margin-left: -5px;
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, .82) transparent;
        }

        #defaultdataselest {
            width: 165px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            margin-top: 6px;
            margin-bottom: 17px;
            margin-left: 5px;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #UnionorIntersection {
            width: 172px;
            /* height: 2em; */
            border: 1px solid #ced4da;
            margin-bottom: 14px;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        .reset-Cube-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;

        }

        .reset-wholeCube-button {
            cursor: pointer;
            border: none; /* 移除邊框 */
            background-color: transparent; /* 背景透明 */
            padding: 0px;
            margin-top: 7px;
        }

        #sortXOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
            /* font-size: 16px; */
        }

        #sortYOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
            /* font-size: 16px; */
        }

        #sortZOrderSelect {
            width: 140px; /* Adjust the width as needed */
            height: 2em;
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            margin-right: 6px;
            /* font-size: 16px; */
        }

        .label-sortXOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            /* font-size: 16px; */
        }

        .label-sortYOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            /* font-size: 16px; */
        }

        .label-sortZOrderSelect{
            margin-right: 10px;
            position: relative;
            top: 4px; /* 向下移動 */
            /* font-size: 16px; */
        }

        #Xflip_side {
            line-height: 2em; /* 將行高設為與高度相同，確保文本垂直置中 */
            vertical-align: middle; /* 垂直對齊置中 */

            width: 125px;
            height: 2em;
            border: 1px solid #ced4da;
            border-radius: 5px;
            margin-right: 2.5px;
            /* font-size: 16px; */
        }

        #Yflip_side {
            width: 125px;
            height: 2em;
            border: 1px solid #ced4da;
            border-radius: 5px;
            margin-right: 2.5px;
        }

        #Zflip_side {
            width: 125px;
            height: 2em;
            border: 1px solid #ced4da;
            border-radius: 5px;
            margin-right: 12px;
        }

        .dropdown-separator {
            border-left: 1px solid #ced4da; /* 分隔線樣式 */
            height: 20px; /* 根據需要調整高度 */
            display: inline-block; /* 使 span 以行內塊級元素顯示 */
            margin: 0 10px; /* 在分隔線兩側新增空間 */
        }

        .chart-container {
            width: 100%; /* 佔滿浮動視窗的寬度 */
            height: 100%; /* 佔滿浮動視窗的高度 */
        }

        #dataProcessingPanel {
            width: 600px; /* 根據需要調整寬度 */
            height: 650px; /* 根據需要調整高度 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            overflow: auto; /* 允許內容超出時新增捲軸 */
        }

        #dataPreviewTable {
            border-collapse: collapse; /* 折疊邊框，使表格之間的邊框只顯示為一條線 */
            width: 100%; /* 表格寬度 */
            margin-top: 20px; /* 與上方內容的間距 */
            font-size: 13px;
            word-wrap: break-word; /* 讓內容自動換行 */
        }

        #dataPreviewTable, #dataPreviewTable th, #dataPreviewTable td {
            border: 1px solid #ddd; /* 設定邊框樣式 */
        }

        #dataPreviewTable th, #dataPreviewTable td {
            text-align: left; /* 單元格內容左對齊 */
            padding: 8px; /* 單元格內邊距 */
        }

        #dataPreviewTable th {
            background-color: #f2f2f2; /* 表頭背景色 */
        }

        .data-information-panel .card {
            border: 1px solid #ccc;
            border-radius: 5px;
            /* width: 557px; */
        }

        .data-information-panel .card-header {
            display: flex;
            align-items: center;
            /* justify-content: space-between; This will put space between the elements */
            padding: 0.75rem 1.25rem;
            background-color: #f7f7f7;
            border-bottom: 1px solid #ccc;
            height: 50px;
            position: relative; /* 使 .arrow 可以相對於這個元素進行定位 */
        }

        .data-information-panel .card-header .panel-title {
            display: flex;
            text-decoration: none;
            color: #4169e1;
            font-weight: bold;
            font-size: 1.25rem; /* Adjust the font size as needed */
            position: absolute;
            padding: 0.5rem 0;
            align-items: center;
            /* justify-content: space-between; This will align "Data Information" to the left and the arrow to the right */
            text-decoration: none;
            width: 100%; /* Ensure the link takes the full width */
            top: 7%;
        }

        .card-header .arrow {
            position: absolute;
            /* margin-left: auto; Pushes the arrow to the right */
            right: 20px; /* Remove this if you are not absolutely positioning the arrow */
            top: 35%;
        }

        .arrow {
            border: solid #A9A9A9;
            border-width: 0 2px 2px 0;
            display: inline-block;
            padding: 3px;
            /* margin-right: 40px; */
        }

        .down {
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
        }

        .up {
            transform: rotate(-135deg);
            -webkit-transform: rotate(-135deg);
        }

        .panel-collapse {
            transition: all 0.4s ease;
        }

        .panel-collapse.collapse {
            display: none;
        }

        .panel-collapse.collapse.show {
            display: block;
        }

        .highlight-color-1 {
            background-color: #b3cde3; /* 藍色 */
        }

        .highlight-color-2 {
            background-color: #ccebc5; /* 綠色 */
        }

        .highlight-color-3 {
            background-color: #ffecb3; /* 黃色 */
        }

        .highlight-color-4 {
            background-color: #bebada; /* 紫色 */
        }

        .highlight-1 { background-color: #ddffff; } /* 藍色 */
        .highlight-2 { background-color: #ddeeff; } /* 藍色 */
        .highlight-3 { background-color: #ddffee; } /* 綠色 */
        .highlight-4 { background-color: #D1EADE; } /* 綠色 */
        .highlight-5 { background-color: #ffffdd; } /* 黃色 */
        .highlight-6 { background-color: #ffffb3; } /* 黃色 */


        /* Specific styles for the OK button */
        #okButton {
            background-color: #4169e1; /* Royal blue background for the OK button */
            color: white;
            font-size: 1.25rem;
            border: none;
            margin-top: 11px;
            /* margin-bottom: 11px; */
            border-radius: 5px;
            width: 50px; /* Width of the button */
            height: 40px; /* Height of the button */
            position: absolute;
            right: 95px;;
        }

        /* Specific styles for the OK button */
        #cancelButton {
            background-color: #b3adad; /* Royal blue background for the OK button */
            color: white;
            font-size: 1.25rem;
            border: none;
            margin-top: 11px;
            border-radius: 5px;
            width: 70px; /* Width of the button */
            height: 40px; /* Height of the button */
            position: absolute;
            right: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 建立 4 個等寬的行 */
            gap: 10px; /* 方框之间的间隙 */
            grid-template-rows: repeat(2, 1fr); /* 建立 2 個等高的列 */
            height: 100%; /* 使容器填滿其父元素 */
            width: 100%;
        }

        .grid-item {
            border: 1px solid #ccc; /* 方框的邊框 */
            border-radius: 5px;
            /* justify-content: space-around; 平均分配空間 */
        }

        .grid-item.large {
            grid-row: span 2 / auto; /* 讓大方框跨越 2 個小方框的位置 (row 方向) */
        }

        .grid-item:nth-child(1) { 
            padding: 10px;
            display: flex;
            flex-direction: column; /* 將子元素排列在垂直方向 */
            justify-content: center; /* 在垂直方向上居中對齊子元素 */
            align-items: flex-start; /* 在水平方向上靠右對齊子元素 */
            height: 100%; /* 確保 .grid-item 的高度充分，來垂直居中 .info-row */
            font-size: 13px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .info-col {
            display: flex;
            justify-content: space-between; /* This will align the first span to the left and the second span to the right */
            align-items: center; /* Vertically center the content */
            width: 100%; /* Use the full width of the parent .grid-item */
        }

        .info-row span, .info-col span {
            white-space: nowrap; /* Prevents the text from wrapping */
        }

        .info-row > span:last-child {
            margin-left: auto; 
        }

        /* If you want to target only the spans inside .info-col */
        .info-col > span:last-child {
            margin-left: auto; /* Push the last span in .info-col to the right */
        }

        .grid-item:nth-child(2) {
            grid-column: span 2 / auto; /* 讓大方框跨越 2 個小方框的位置 (column 方向) */
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
        }

        .dropdown-row-1 {
            display: flex;
            justify-content: center; /* Center the dropdowns horizontally */
            width: 100%; /* Ensure the row takes full width */
            /* margin-bottom: 3px;  Adds space between each row */
        }

        .dropdown-row-2 {
            display: flex;
            justify-content: center; /* Center the dropdowns horizontally */
            width: 100%; /* Ensure the row takes full width */
            /* margin-bottom: 10px; Adds space between each row */
        }

        .dropdown-container {
            display: flex;
            align-items: center; /* Center the label and select horizontally */
            justify-content: center; /* Center children vertically */
        }

        .dropdown-container label {
            margin-right: 5px; /* Space between the label and the dropdown */
            margin-top: 8px;
        }

        #multiSelectX {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #b3cde3;
            margin-right: 15px; /* Adds space between each dropdown container */
        }

        #multiSelectY {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #ccebc5;
        }

        #multiSelectZ {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #ffecb3;
            margin-right: 15px; /* Adds space between each dropdown container */
        }

        #singleSelect {
            width: 65px; /* Adjust the width as needed */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
            background-color: #bebada;
        }

        .grid-item:nth-child(3) {
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
            padding: 15px;
        }

        .X-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .Y-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .Z-num {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .value-min {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            margin-bottom: 15px; /* Adds space below the .info-row */
        }

        .value-max {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Use the full width of the parent .grid-item */
            /* margin-bottom: 15px; Adds space below the .info-row */
        }

        .X-num span, .Y-num span, .Z-num span, .value-min span, .value-min span {
            white-space: nowrap; /* Prevents the text from wrapping */
        }

        .X-num > span:last-child {
            margin-left: auto; 
        }

        .Y-num > span:last-child {
            margin-left: auto;
        }

        .Z-num > span:last-child {
            margin-left: auto;
        }

        .value-min > span:last-child {
            margin-left: auto;
        }

        .value-max > span:last-child {
            margin-left: auto;
        }

        .grid-item:nth-child(4) {
            width: 100%;
            display: flex;
            flex-direction: column; /* Align children vertically */
            justify-content: center; /* Center children vertically */
            align-items: center; /* Center children horizontally */
            font-size: 13px;
            /* padding: 15px; */
            /* white-space: nowrap; */
        }

        #select1 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddffff;
        }

        #select2 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddeeff;
        }

        .dropdown4-row-1 label, .dropdown4-row-2 label {
            margin-right: 5px;
        }

        .grid-item:nth-child(5) {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 13px;
        }

        #select3 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ddffee;
        }

        #select4 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #D1EADE;
        }

        .dropdown5-row-1 label, .dropdown5-row-2 label {
            margin-right: 5px;
        }

        .grid-item:nth-child(6) {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 13px;
        }

        #select5 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ffffdd;
        }

        #select6 {
            width: 45px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #ffffb3;
        }

        .dropdown6-row-1 label, .dropdown6-row-2 label {
            margin-right: 5px;
        }

        .radiowhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 180px;
            margin-top: 10px;
            margin-bottom: 10px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 74px;
            padding: 8px;
        }

        .colorradiowhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* margin-top: 10px; */
            /* margin-bottom: 10px; */
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 275px;
            padding: 8px;
        }

        .colorwhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 169px;
            padding: 8px;
            margin-bottom: 15px;
        }

        .Slicewhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            height: 139px;
            padding: 8px;
            margin-bottom: 10px;
        }

        .filterwhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 182px;
            padding: 8px;
            margin-bottom: 15px;
        }

        .datawhite-background {
            background-color: white;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: 190px;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            height: 163px;
            padding: 8px;
        }

        #double-slider {
            width: 190px;
            margin-bottom: 35px;
        }

        #double-slider-cubesvalue {
            width: 190px;
            margin-bottom: 35px;
        }

        .ui-slider-handle .ui-slider-value {
            color: #000;
        }

        .ui-slider-value {
            position: absolute;
            top: 25px; /* 根据需要调整位置 */
            font-size: 12px;
            transform: translateX(-50%); /* 置中對齊 */
        }

        .ui-slider-handle {
            width: 20px; /* 手柄的寬度 */
            height: 20px; /* 手柄的高度 */
            border-radius: 10px; /* 圓角的大小 */
        }

        /* 已選取範圍的背景色 */
        .ui-slider .ui-slider-range {
            background: #007bff; /* 藍色背景 */
        }

        .ui-slider {
            border-radius: 10px; /* 圓角的大小 */
        }

        #colorforXproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #colorforYproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }

        #colorforZproximity {
            width: 172px; /* Adjust the width as needed */
            /* height: 2em; */
            border: 1px solid #ced4da; /* Similar to form-control styling for borders */
            border-radius: 5px; /* 加入圓角，根據需要調整圓角大小 */
        }
        </style>

</head>

<body class="has-sidebar has-fixed-sidebar-and-header">
<!-- Header -->
<header class="header bg-body">
    <nav class="navbar flex-nowrap p-0">
        <div class="navbar-brand-wrapper d-flex align-items-center col-auto">
            <!-- Logo For Mobile View -->
            <!-- <a class="navbar-brand navbar-brand-mobile" href="index.html">
                <img class="img-fluid w-100" src="img/gap.gif">
            </a> -->
            <!-- End Logo For Mobile View -->

            <!-- Logo For Desktop View -->
            <a class="navbar-brand navbar-brand-desktop" href="index.html">
                <!-- <img class="side-nav-show-on-closed" src="img/gap.gif"> -->
                <img class="side-nav-show-on-closed" src="img/cube.png"> <!-- cube3.ico cube4.png -->
                <div class="side-nav-hide-on-closed">3D GAP Online <sup>BETA</sup></div>
            </a>
            <!-- End Logo For Desktop View -->
        </div>

        <div class="header-content col px-md-3">
            <div class="d-flex align-items-center">
                <!-- Side Nav Toggle -->
                <a  class="js-side-nav header-invoker d-flex mr-md-2" href="#"
                    data-close-invoker="#sidebarClose"
                    data-target="#sidebar"
                    data-target-wrapper="body">
                    <i class="gd-align-left"></i>
                </a>
                <!-- End Side Nav Toggle -->

                <!-- Order -->
                <label for="sortXOrderSelect" class="label-sortXOrderSelect">Order X</label>
                <select id="sortXOrderSelect">
                    <option value="original_X">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option>
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_X">Random</option> 
                </select>
                <select id="Xflip_side" disabled="disabled">
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>

                <span class="dropdown-separator"></span> <!-- 分隔線 -->

                <label for="sortYOrderSelect" class="label-sortYOrderSelect">Order Y</label>
                <select id="sortYOrderSelect">
                    <option value="original_Y">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option>
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_Y">Random</option>
                </select>
                <select id="Yflip_side" disabled="disabled">
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>

                <span class="dropdown-separator"></span> <!-- 分隔線 -->

                <label for="sortZOrderSelect" class="label-sortZOrderSelect">Order Z</label>
                <select id="sortZOrderSelect">
                    <option value="original_Z">Original Order</option>
                    <option value="averagelinkage" disabled>Average-Linkage</option>
                    <option value="singlelinkage" disabled>Single-Linkage</option>
                    <option value="completelinkage" disabled>Complete-Linkage</option> <!-- <option value="completelinkage" disabled>Complete-Linkage</option> -->
                    <option value="null"> ----- </option>
                    <option value="r2e" disabled>R2E</option>
                    <option value="random_Z">Random</option>
                </select>
                <select id="Zflip_side" disabled="disabled"> <!-- class="form-control-none form-control-sm" -->
                    <option value="null" selected>Flip: None</option>
                    <option value="r2e" disabled="disabled">Flip: R2E</option>
                    <option value="uncle">Flip: Uncle</option>
                    <option value="grandpa">Flip: GrandPa</option>
                </select>
                <!-- Tooltip for orderHelp -->
                <div class="orderhelp-icon" id="orderHelp">
                    <i class="fa-solid fa-question-circle"></i>
                    <span class="tooltipfororderhelp-content" style="font-size: 14px;">Please apply the Proximity features before ordering.</span>
                </div>
                <!-- End Order -->

                <!-- User Avatar -->
                <!-- <div class="dropdown mx-3 dropdown ml-2">
                    <a id="profileMenuInvoker" class="header-complex-invoker" href="#" aria-controls="profileMenu" aria-haspopup="true" aria-expanded="false" data-unfold-event="click" data-unfold-target="#profileMenu" data-unfold-type="css-animation" data-unfold-duration="300" data-unfold-animation-in="fadeIn" data-unfold-animation-out="fadeOut">
                        img class="avatar rounded-circle mr-md-2" src="#" alt="John Doe"
                        <span class="mr-md-2 avatar-placeholder">J</span>
                        <span class="d-none d-md-block">John Doe</span>
                        <i class="gd-angle-down d-none d-md-block ml-2"></i>
                    </a>

                    <ul id="profileMenu" class="unfold unfold-user unfold-light unfold-top unfold-centered position-absolute pt-2 pb-1 mt-4 unfold-css-animation unfold-hidden fadeOut" aria-labelledby="profileMenuInvoker" style="animation-duration: 300ms;">
                        <li class="unfold-item">
                            <a class="unfold-link d-flex align-items-center text-nowrap" href="#">
                    <span class="unfold-item-icon mr-3">
                      <i class="gd-user"></i>
                    </span>
                                My Profile
                            </a>
                        </li>
                        <li class="unfold-item unfold-item-has-divider">
                            <a class="unfold-link d-flex align-items-center text-nowrap" href="#">
                    <span class="unfold-item-icon mr-3">
                      <i class="gd-power-off"></i>
                    </span>
                                Sign Out
                            </a>
                        </li>
                    </ul>
                </div> -->
                <!-- End User Avatar -->
            </div>
        </div>
    </nav>
</header>
<!-- End Header -->

<main class="main">
    <!-- Sidebar Nav -->
    <aside id="sidebar" class="js-custom-scroll side-nav">
        <ul id="sideNav" class="side-nav-menu side-nav-menu-top-level mb-0">
            <!-- Title -->
            <li class="sidebar-heading h6">DATA</li>
            <!-- End Title -->

            <!-- data information -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <!-- 資料處理面板 -->
                <div id="dataProcessingPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #ccc; padding: 20px; z-index: 1000;">
                    <div class="data-information-panel">
                        <div class="card">
                            <div class="card-header">
                                <h2 class="panel-title">
                                    Data Information
                                </h2>
                                <a data-toggle="collapse" href="#collapseDataOptions" aria-expanded="true">
                                    <i class="arrow down"></i>
                                </a>
                            </div>
                            <div id="collapseDataOptions" class="panel-collapse collapse show">
                                <div class="card-body">
                                    <div class="grid-container">
                                        <!-- 第一個小方框 -->
                                        <div class="grid-item">
                                            <div class="info-row">
                                                <span>No. Row:</span>
                                                <span id="rowCount"></span>
                                            </div>
                                            <div class="info-col">
                                                <span>No. Col.:</span>
                                                <span id="colCount"></span>
                                            </div>
                                        </div>

                                        <!-- 第二個小方框 -->
                                        <div class="grid-item">
                                            <!-- Dropdowns -->
                                            <div class="dropdown-row-1">
                                                <div class="dropdown-container">
                                                    <label for="multiSelectX">X Col.</label>
                                                    <select id="multiSelectX"></select>
                                                </div>
                                                <div class="dropdown-container">
                                                    <label for="multiSelectY">Y Col.</label>
                                                    <select id="multiSelectY"></select>
                                                </div>
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown-row-2">
                                                <div class="dropdown-container">
                                                    <label for="multiSelectZ">Z Col.</label>
                                                    <select id="multiSelectZ"></select>
                                                </div>
                                                <div class="dropdown-container">
                                                    <label for="singleSelect">Value</label>
                                                    <select id="singleSelect"></select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 一個大方框 (第三個小方框) -->
                                        <div class="grid-item large">
                                            <div class="X-num">
                                                <span>No. X Cat.:</span>
                                                <span id="Xnum"></span>
                                            </div>
                                            <div class="Y-num">
                                                <span>No. Y Cat.:</span>
                                                <span id="Ynum"></span>
                                            </div>
                                            <div class="Z-num">
                                                <span>No. Z Cat.:</span>
                                                <span id="Znum"></span>
                                            </div>
                                            <div class="value-min">
                                                <span>Min.:</span>
                                                <span id="valuemin"></span>
                                            </div>
                                            <div class="value-max">
                                                <span>Max.:</span>
                                                <span id="valuemax"></span>
                                            </div>
                                        </div>

                                        <!-- 第四個小方框 (下排第一個) -->
                                        <div class="grid-item">
                                            <div class="dropdown4-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select1">Xdiscr.</label>
                                                    <select name="select1" id="select1">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown4-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select2">Xconti.</label>
                                                    <select name="select2" id="select2">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 第五個小方框 -->
                                        <div class="grid-item">
                                            <div class="dropdown5-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select3">Ydiscr.</label>
                                                    <select name="select3" id="select3">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown5-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select4">Yconti.</label>
                                                    <select name="select4" id="select4">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 第六個小方框 -->
                                        <div class="grid-item">
                                            <div class="dropdown6-row-1">
                                                <div class="dropdown-container">
                                                    <label for="select5">Zdiscr.</label>
                                                    <select name="select5" id="select5">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                                
                                            </div>
                                            <!-- <br> -->
                                            <div class="dropdown6-row-2">
                                                <div class="dropdown-container">
                                                    <label for="select6">Zconti.</label>
                                                    <select name="select6" id="select6">
                                                        <option value="0">0</option>
                                                        <option value="1">1</option>
                                                        <option value="2">2</option>
                                                        <option value="3">3</option>
                                                        <option value="4">4</option>
                                                        <option value="5">5</option>
                                                        <option value="6">6</option>
                                                        <option value="7">7</option>
                                                        <option value="8">8</option>
                                                        <option value="9">9</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                                
                    <!-- 資料預覽的表格 -->
                    <table id="dataPreviewTable">
                        <thead id="dataPreviewHead"></thead>
                        <tbody id="dataPreviewBody"></tbody>
                    </table>

                    <button id="okButton">OK</button>
                    <button id="cancelButton">Cancel</button>
                </div>
            </li>
            <!-- End data information -->

            <!-- Import data -->
            <li class="side-nav-menu-item side-nav-has-menu side-nav-opened">
                <a class="side-nav-menu-link media align-items-center" href="#"
                data-target="#subdata">
                <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-folder-open"></i>
                </span>
                <span class="side-nav-fadeout-on-closed media-body">Select Data File</span>
                <span class="side-nav-control-icon d-flex">
                    <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
                </span>
                <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>
                
                <!-- subdata -->
                <ul id="subdata" class="side-nav-menu side-nav-menu-second-level mb-0" style="display: block;"> <!-- 確保展開 -->
                    <li class="side-nav-menu-item">
                        <div class="datawhite-background">
                            <form id="dataselection">
                                <!-- 預設資料 -->
                                <input type="radio" id="defaultdata" name="datafile" value="defaultdata" checked>
                                <label for="defaultdata">Example Data</label>
                                <br>
                                <select id="defaultdataselest">
                                    <option value="airpollution" selected>2023 Air Pollution in Taiwan</option>
                                    <option value="premierleague">23/24 Premier League</option>
                                </select>
                                <br>
                                <!-- 輸入資料 -->
                                <input type="radio" id="importdata" name="datafile" value="importdata">
                                <label for="importdata">Import Data</label><br>
                                <button id="fileButton" class="file-button">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <!-- 隱藏原始的檔案輸入 -->
                                <input type="file" id="fileInput" style="display: none;" />
                                <!-- 顯示一個自訂的標籤或按鈕 -->
                                <label for="fileInput" id="fileInputLabel" style="cursor: pointer;" class="side-nav-fadeout-on-closed media-body">Choose Data</label>
                            </form>
                        </div>
                    </li>
                </ul>
                <!-- End subdata -->
            </li>
            <!-- End Import data -->

            <!-- Export -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                data-target="#subexport">
                <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-file-export"></i>
                </span>
                <span class="side-nav-fadeout-on-closed media-body">Export</span>
                <span class="side-nav-control-icon d-flex">
                    <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
                </span>
                <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subexport -->
                <ul id="subexport" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <!-- Tooltip for exportHelp -->
                        <div class="exporthelp-icon" id="exporthelp">
                            <i class="fa-solid fa-question-circle"></i>
                            <span class="tooltipforexporthelp-content" style="font-size: 14px;">When exporting Proximity Images and Charts, please ensure that the windows are properly adjusted for the best result.</span>
                        </div>
                        <div class="exportselect">
                            <div class="exportselect-item" id="exportCube">Cube</div>
                            <div class="exportselect-item" id="exportProximity">Proximity</div>
                            <div class="exportselect-item" id="exportProxImage">Proximity Images</div>
                            <div class="exportselect-item" id="exportChart">Charts</div>
                        </div>
                    </li>
                </ul>
                <!-- End subexport -->
            </li>
            <!-- End Export -->

            <!-- Title -->
            <li class="sidebar-heading h6">SETTINGS</li>
            <!-- End Title -->

            <!-- raw MT -->
            <!-- <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subrawMT">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-table"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Raw Data Matrix</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a> -->

                <!-- subraw MT -->
                <!-- <ul id="subrawMT" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="xAxisCate">X-axis</label>
                        <select id="xAxisCate" name="xAxisCate"></select>

                        <label for="yAxisCate">Y-axis</label>
                        <select id="yAxisCate" name="yAxisCate"></select>

                        <label for="zAxisCate">Z-axis</label>
                        <select id="zAxisCate" name="zAxisCate"></select>
                    </li>
                </ul> -->
                <!-- End subraw MT -->
            <!-- </li> -->
            <!-- End raw MT -->

             <!-- Proximity -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subProx">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-gears"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Proximity</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <ul id="subProx" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <!-- <a class="side-nav-menu-link" href="users.html">Open File</a> -->
                        <label for="rowproxX">X Processing</label>
                        <select id="rowproxX"> <!-- class="form-control form-control-sm" -->
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                        
                        <label for="rowproxY">Y Processing</label>
                        <select id="rowproxY">
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                    
                        <label for="rowproxZ">Z Processing</label>
                        <select id="rowproxZ">
                            <option value="null" selected> ----- </option>
                            <optgroup label =  "Continuous">
                            <option value="euclidean_distance">Euclidean Distance</option>
                            <option value="pearson_correlation">Pearson's Correlation</option>
                            <option value="kendalls_tau">Kendall's tau</option>
                            <option value="spearman_rank">Spearman's Rank</option>
                            <option value="atan_correlation">atan Correlation</option>
                            <option value="city_block">City-Block (L1)</option>
                            <option value="abs_pearson_correlation">abs(Pearson's Correlation)</option>
                            </optgroup>
                            <!-- <optgroup label =  "Binary">
                            <option value="Hamman">Hamman</option>
                            <option value="Jaccard">Jaccard</option>
                            <option value="Phi">Phi</option>
                            <option value="Rao">Rao</option>
                            <option value="Rogers">Rogers</option>
                            <option value="Simple_Match">Simple Match</option>
                            <option value="Sneath">Sneath</option>
                            <option value="Yule">Yule</option>
                            </optgroup> -->
                            <!--<option value="covariance">Covariance</option>-->
                        </select>
                    </li>
                </ul>
                <!-- End Proximity -->
            </li>

            <!-- Title -->
            <li class="sidebar-heading h6">OPTIONS</li>
            <!-- End Title -->

            <!-- Filter -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subFilter">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-filter"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Filter</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subFilter -->
                <ul id="subFilter" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="filterwhite-background">
                            <!-- for bar chart -->
                            <label for="calculationType">Aggregation Type</label>
                            <select id="calculationType">
                                <option value="sum">sum</option>
                                <option value="mean">mean</option>
                            </select>
                            <label for="UnionorIntersection">Filter Type</label>
                            <select id="UnionorIntersection">
                                <option value="Union">Union</option>
                                <option value="Intersection">Intersection</option>
                            </select>
                            <br>
                            <button id="resetToOriginalCube" class="reset-Cube-button">
                                <i class="fa-solid fa-arrow-rotate-left"></i>
                            </button>
                            <span>Reset Filter Setting</span>
                        </div>
                        <label for="double-slider">Restricted Display</label>
                        <div>
                            <!-- 新增雙按鈕滑動條的容器 -->
                            <div id="double-slider"></div>
                            <span id="range-info"></span>
                        </div>
                        <label for="double-slider-cubesvalue">Filter Cubes Value</label>
                        <div>
                            <!-- 新增雙按鈕滑動條的容器 -->
                            <div id="double-slider-cubesvalue"></div>
                            <span id="range-cubesvalue"></span>
                        </div>
                    </li>
                </ul>
                <!-- End subFilter -->
            </li>
            <!-- End Filter -->

            <!-- Opacity -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subOpacity">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-paint-roller"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Opacity</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subOpacity -->
                <ul id="subOpacity" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="opacityRange">Cubes Opacity</label>
                        <input type="range" id="opacityRange" min="0.01" max="1" step="0.01" value="0.5">
                        <span id="opacityValue">0.5</span>
                        <br>
                        <label for="filteropacityRange">Filtered Cubes Opacity</label>
                        <input type="range" id="filteropacityRange" min="0" max="1" step="0.01" value="0">
                        <span id="filteropacityValue">0</span>
                    </li>
                </ul>
                <!-- End subOpacity -->
            </li>
            <!-- End Opacity -->

            <!-- color -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subcolour">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-palette"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Color</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subcolor -->
                <ul id="subcolour" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="colorwhite-background">
                            <label for="colorSchemeSelect">Color Spectrum</label>
                            <select id="colorSchemeSelect">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <!--<optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>-->
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColors" name="reverseColors">
                            <label for="reverseColors">Reverse</label>
                            <br>
                            <label for="DisplayCondition">Display Condition</label>
                            <select id="DisplayCondition">
                                <option value="RangeMatrix" selected>Range: Cube</option>
                                <option value="RangeX">Range: Col. X</option>
                                <option value="RangeY">Range: Col. Y</option>
                                <option value="RangeZ">Range: Col. Z</option>
                            </select>
                        </div>
                        
                        <!-- <br> -->
                        <div class="colorradiowhite-background">
                            <label for="colorforXproximity">X Proximity Matrix</label>
                            <select id="colorforXproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <!--<optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>-->
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforX" name="reverseColorforX">
                            <label for="reverseColorforX">Reverse</label>

                            <label for="colorforYproximity">Y Proximity Matrix</label>
                            <select id="colorforYproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <!--<optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>-->
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforY" name="reverseColorforY">
                            <label for="reverseColorforY">Reverse</label>

                            <label for="colorforZproximity">Z Proximity Matrix</label>
                            <select id="colorforZproximity">
                                <optgroup label =  "Sequential Palettes"></optgroup>
                                    <option value="GAP_Rainbow">GAP_Rainbow</option>
                                    <option value="YlOrRd">YlOrRd</option>
                                    <option value="YlOrBr">YlOrBr</option>
                                    <option value="YlGnBu">YlGnBu</option>
                                    <option value="YlGn">YlGn</option>
                                    <option value="Reds">Reds</option>
                                    <option value="RdPu">RdPu</option>
                                    <option value="Purples">Purples</option>
                                    <option value="PuRd">PuRd</option>
                                    <option value="PuBuGn">PuBuGn</option>
                                    <option value="PuBu">PuBu</option>
                                    <option value="OrRd">OrRd</option>
                                    <option value="Oranges">Oranges</option>
                                    <option value="Greys">Greys</option>
                                    <option value="Greens">Greens</option>
                                    <option value="GnBu">GnBu</option>
                                    <option value="BuPu">BuPu</option>
                                    <option value="BuGn">BuGn</option>
                                    <option value="Blues">Blues</option>
                                <!--<optgroup label =  "Qualitative Palettes"></optgroup>
                                    <option value="Set3">Set3</option>
                                    <option value="Set2">Set2</option>
                                    <option value="Set1">Set1</option>
                                    <option value="Pastel2">Pastel2</option>
                                    <option value="Pastel1">Pastel1</option>
                                    <option value="Paired">Paired</option>
                                    <option value="Dark2">Dark2</option>
                                    <option value="Accent">Accent</option>-->
                                <optgroup label =  "Diverging Palettes"></optgroup>
                                    <option value="GAP_Blue_White_Red">GAP_Blue_White_Red</option>
                                    <option value="Spectral">Spectral</option>
                                    <option value="RdYlGn">RdYlGn</option>
                                    <option value="RdYlBu">RdYlBu</option>
                                    <option value="RdGy">RdGy</option>
                                    <option value="RdBu">RdBu</option>
                                    <option value="PuOr">PuOr</option>
                                    <option value="PRGn">PRGn</option>
                                    <option value="PiYG">PiYG</option>
                                    <option value="BrBG">BrBG</option>
                            </select>
                            <br>
                            <input type="checkbox" id="reverseColorforZ" name="reverseColorforZ">
                            <label for="reverseColorforZ">Reverse</label>
                        </div>
                    </li>
                </ul>
                <!-- End subcolor -->
            </li>
            <!-- End color -->

            <!-- slice -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subslice">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-clone"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Slices</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subslice -->
                <ul id="subslice" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <div class="Slicewhite-background">
                            <form id="axisSelection">
                                <input type="radio" id="xAxis" name="axis" value="X">
                                <label for="xAxis">X-Slices</label><br>
                                <input type="radio" id="yAxis" name="axis" value="Y">
                                <label for="yAxis">Y-Slices</label><br>
                                <input type="radio" id="zAxis" name="axis" value="Z">
                                <label for="zAxis">Z-Slices</label><br>
                                <input type="radio" id="oAxis" name="axis" value="O" checked>
                                <label for="oAxis">Original Cube</label><br>
                            </form>
                        </div>
                        <label for="SliceRange">Slices Gap</label><br>
                        <input type="range" id="SliceRange" min="1" max="4" step=".1" value="1">
                        <span id="SliceValue">1</span>
                    </li>
                </ul>
                <!-- End subslice -->
            </li>
            <!-- End slice -->

            <!-- size -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subsize">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-cubes"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Cube Size</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subsize -->
                <ul id="subsize" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="cubeSizeX">X-axis</label>
                        <br>
                        <input type="range" id="cubeSizeX" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeXValue">1</span>
                        <br>
                        <label for="cubeSizeY">Y-axis</label>
                        <br>
                        <input type="range" id="cubeSizeY" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeYValue">1</span>
                        <br>
                        <label for="cubeSizeZ">Z-axis</label>
                        <br>
                        <input type="range" id="cubeSizeZ" min="0.1" max="1" value="1" step="0.1">
                        <span id="cubeSizeZValue">1</span>
                        <br>
                        <label for="hollowSize">Separate Cube</label>
                        <br>
                        <input type="range" id="hollowSize" min="0.1" max="1" value="1" step="0.1">
                        <span id="hollowSizeValue">1</span>
                    </li>
                </ul>
                <!-- End subsize -->
            </li>
            <!-- End size -->

            <!-- Font -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subfont">
                  <span class="side-nav-menu-icon d-flex mr-3">
                    <i class="fa-solid fa-font"></i>
                  </span>
                    <span class="side-nav-fadeout-on-closed media-body">Font</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subfont -->
                <ul id="subfont" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <label for="fontStyle">Font Style</label>
                        <br>
                        <select id="fontStyle">
                            <option value="Arial">Arial</option>
                            <option value="Source Sans Pro">Source Sans Pro</option>
                            <option value="Encode Sans">Encode Sans</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Tahoma">Tahoma</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Lucida Console">Lucida Console</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                            <option value="Trebuchet MS">Trebuchet MS</option>
                            <option value="Impact">Impact</option>
                        </select>
                        <br>
                        <label for="FontColor">Font Color</label>
                        <br>
                        <input type="color" id="FontColor" name="FontColor" value="#0f0f0f"><label for="fontSize">Font Size</label>
                        <br>
                        <input type="range" id="fontSize" min="1" max="50" value="25" step="1">
                        <span id="fontSizeValue">25</span>
                    </li>
                </ul>
                <!-- End subfont -->
            </li>
            <!-- End Font -->

            <!-- Interactive -->
            <li class="side-nav-menu-item side-nav-has-menu">
                <a class="side-nav-menu-link media align-items-center" href="#"
                   data-target="#subInteractive">
              <span class="side-nav-menu-icon d-flex mr-3">
                <i class="fa-solid fa-hand"></i>
              </span>
                    <span class="side-nav-fadeout-on-closed media-body">Interactive</span>
                    <span class="side-nav-control-icon d-flex">
                <i class="gd-angle-right side-nav-fadeout-on-closed"></i>
              </span>
                    <span class="side-nav__indicator side-nav-fadeout-on-closed"></span>
                </a>

                <!-- subInteractive -->
                <ul id="subInteractive" class="side-nav-menu side-nav-menu-second-level mb-0">
                    <li class="side-nav-menu-item">
                        <input type="checkbox" id="panCheckBox" name="panControl">
                        <label for="panControl">Pan</label>
                        <br>
                        <input type="checkbox" id="tooltipCheckbox" name="tooltipCheckbox">
                        <label for="tooltipCheckbox">Show Data on Hover</label>
                        <!-- Tooltip for orderHelp -->
                        <div class="Hoverhelp-icon" id="Hoverhelp">
                            <i class="fa-solid fa-question-circle"></i>
                            <span class="tooltipforHoverhelp-content" style="font-size: 14px;">If the Slices features or the Separate Cube slider is applied, hovering will display information for the individual inner cubes.</span>
                        </div>
                        <br>
                        <button id="resetCameraIcon" class="reset-camera-button">
                            <i class="fa-solid fa-camera-rotate"></i>
                        </button>
                        <span>Reset Camera to Default</span>
                        <br>
                        <button id="resetCube" class="reset-wholeCube-button">
                            <i class="fa-solid fa-rotate"></i>
                        </button>
                        <span>Reset To Original Cube</span>
                        <br>
                        <div class="radiowhite-background">
                            <form id="PeorOrCamera">
                                <input type="radio" id="PerspectiveCamera" name="Camera" value="Pe" checked>
                                <label for="PerspectiveCamera">Perspective Camera</label><br>
                                <input type="radio" id="OrthographicCamera" name="Camera" value="Or">
                                <label for="OrthographicCamera">Orthographic Camera</label><br>
                            </form>
                        </div>
                    </li>
                </ul>
                <!-- End subInteractive -->
            </li>
            <!-- End Interactive -->
        </ul>
    </aside>
    <!-- End Sidebar Nav -->

    <div id="threejs-container"></div>
    <div id="tooltip" style="display: none;
                            position: absolute;
                            background-color: white;
                            border: 1px solid #000;
                            padding: 10px;
                            font-size: 12px;
                            font-family: Arial,
                            sans-serif;
                            pointer-events: none;">
    </div>

    <div id="colorbar-container">
        <div id="colorbar-max-label" class="colorbar-label"></div>
        <div id="colorbar"></div>
        <div id="colorbar-min-label" class="colorbar-label"></div>
    </div>

    <div id="tableContainer"></div>

    <div id="floatingWindowContainer"></div>  <!-- 浮動窗口的容器 -->

    <!-- Footer -->
    <footer class="small p-3 px-md-4 mt-auto" style="position: fixed; right: 0; bottom: 0; text-align: right;">
        <div class="row justify-content-end">
            <div class="col-lg text-center text-lg-right mb-3 mb-lg-0" style="font-size: 10px; color: #acacac;">
                &copy; Lab for Information Visualzation
                <br>
                Institute of Statistical Science, Academia Sinica
                <br>
                Department of Statistics, Tamkang University
                <br>
                Web Design By Shu-Yu Lin, Chiun-How Kao 2024
            </div>
        </div>
    </footer>
    <!-- End Footer -->
</main>
</body>
</html>